<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="后端Java工程师"><title>JVM | dian的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM</h1><a id="logo" href="/.">dian的博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JVM</h1><div class="post-meta">2021-05-07</div><div class="post-content"><a id="more"></a>

<h1 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h1><h2 id="1、JVM与JAVA体系结构"><a href="#1、JVM与JAVA体系结构" class="headerlink" title="1、JVM与JAVA体系结构"></a>1、JVM与JAVA体系结构</h2><p><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">JVM规范</a>下载，这里使用Java8</p>
<p><img src="/2021/05/07/JVM/JVM%5Cimage-20201106102258137.png" alt="image-20201106102258137"></p>
<p>推荐书目：</p>
<ul>
<li>Java虚拟机规范：官方规范的翻译版不推荐阅读，需要时查阅</li>
<li>深入理解Java虚拟机-JVM高级特性与最佳实践：紫色</li>
<li>实战Java虚拟机-JVM故障诊断与性能优化</li>
<li>自己动手写Java虚拟机：用go语言实现，1w多行</li>
<li>Java虚拟机精讲</li>
<li>码出高效-Java开发手册</li>
</ul>
<p>JVM：跨语言的平台。</p>
<p>字节码文件可以通过不同的变成语言来编译如：Kotlin、Clojure、Groovy、Scala、Jython、JRuby、JavaScript等。</p>
<p>随着Java7发布，Java虚拟机设计者通过JSR-292规范实现Java虚拟机上运行非Java语言程序</p>
<p>以后每个版本都会发布OpenJDK、OracleJDK。区别基于协议不同OpenJDK基于JPL、OracleJDK基于OTN</p>
<p><strong>虚拟机</strong></p>
<ul>
<li>系统虚拟机：Visual Box，VMware。完全是对物理计算机的仿真，提供了可运行完整操作系统的软件平台</li>
<li>程序虚拟机：Java虚拟机。专门为执行单个计算机程序而设计，Java虚拟机中执行的指令成为Java字节码指令</li>
</ul>
<p><strong>JVM整体结构</strong></p>
<p>类装载器子系统：装载Class files生成Class对象</p>
<p>运行时数据区：方法区和堆为多线程共享，其余为每个线程独有一份</p>
<p>执行引擎：含有解释器、JIT Compliter和垃圾回收器。</p>
<p>JIT将字节码编译后会在方法区缓存</p>
<p><img src="/2021/05/07/JVM/JVM%5Cimage-20201106105442682.png" alt="image-20201106105442682"></p>
<p><strong>JVM的架构模型</strong></p>
<p>指令集的架构模型分两种：基于栈的指令集架构、基于寄存器的指令集架构</p>
<p>HotSpot虚拟机除了PC寄存器之外，再无其它寄存器。它的所有操作都需要出栈和入栈的操作。</p>
<p>俩种架构区别</p>
<ul>
<li>基于栈式架构的特点<ul>
<li>设计和实现更简单，适用于资源受限的系统。</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>典型的应用是x86的二进制指令集：如传统的PC以及Android的Davlik虚拟机</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li>
</ul>
</li>
</ul>
<p>栈(总结)：跨平台性、指令多、性能较低</p>
<p><strong>JVM的生命周期</strong></p>
<p>启动：通过引导类加载器创建一个初始类来完成的，这个类是由虚拟机的具体实现指定</p>
<p>执行：</p>
<ul>
<li>一个运行中的Java虚拟机有一个清晰的任务：执行Java程序</li>
<li>程序开始执行时他才运行，程序结束时就停止</li>
<li>执行一个所谓的Java程序时候，真正执行的是一个叫Java虚拟机的进程</li>
</ul>
<blockquote>
<p>可用jps命令查看Java程序进程</p>
</blockquote>
<p>退出：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
<li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作</li>
<li>除此之外，JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li>
</ul>
<p><strong>JVM发展历程</strong></p>
<ol>
<li>Sun Classic VM：第一款商用虚拟机，只提供了解释器。hotspot内置了此虚拟机</li>
<li>Exact VM：可以知道内存中某个位置的数据具体类型。编译器与解释器混合工作，热点探测(知道热点类)</li>
<li>HotSpot VM：市场占有率最高</li>
<li>JRockit：BEA公司，专注于服务器应用。不关注启动速度，全部代码都靠即时编译器编译后执行，最快的JVM。有全面的Java运行时解决方案。面对低延迟应用解决方案JRockit Real Time。MissionControl服务套件，以极低开销监控程序的工具。</li>
<li>J9：IBM公司。专注于IBM公司的产</li>
<li>Azul VM：特定硬件平台虚拟机</li>
<li>Microsoft JVM：只能在win下运行</li>
<li>Taobao JVM：基于OpenJDK定制AlibabaJDK，简称AJDK。基于OpenJDK HotSpot VM的虚拟机。严重依赖于intel的cpu</li>
<li>Dalvik VM：应用于Android系统，不遵循Java虚拟机规范，执行dex文件。寄存器的架构模型</li>
<li>Graal VM：最有可能取代HotSpot</li>
</ol>
<h2 id="2、类加载子系统"><a href="#2、类加载子系统" class="headerlink" title="2、类加载子系统"></a>2、类加载子系统</h2><p><strong>类的加载过程</strong></p>
<ol>
<li><p>加载</p>
<ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
<li>补充：加载.class文件方式<ul>
<li>从本地系统直接加载</li>
<li>从网络获取，如Web Applet</li>
<li>从zip压缩包读取，如jar、war格式</li>
<li>运行时计算生成，如动态代理</li>
<li>从其他文件生成，如JSP</li>
<li>从专有数据库中提取.class文件</li>
<li>从加密文件中获取，防class文件反编译</li>
</ul>
</li>
</ul>
</li>
<li><p>链接</p>
<ul>
<li><p>验证</p>
<ul>
<li>保证Class文件符合要求，不危害虚拟机安全</li>
<li>主要有四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
</li>
<li><p>准备</p>
<ul>
<li><p>为类变量赋默认初始值即零值。</p>
<blockquote>
<p>零值不为程序中指定的初始值，而是0或null或fals</p>
</blockquote>
</li>
<li><p>final修饰的static，在编译的时候就分配了，不在该阶段</p>
</li>
<li><p>也不会为实例变量分配初始化，类变量分配在方法区，而实例变量在Java堆中</p>
</li>
</ul>
</li>
<li><p>解析</p>
<ul>
<li>将常量池的符号引用转化为直接引用</li>
<li>实际上，解析往往会伴随JVM在执行完初始化后再执行</li>
</ul>
</li>
</ul>
</li>
<li><p>初始化</p>
<ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。</li>
<li><code>&lt;clinit&gt;()</code>方法不需定义，由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块的语句合并而来，</li>
</ul>
<blockquote>
<p>类中后面声明的静态属性，是可以在前面的静态代码块中赋值，但不能调用</p>
</blockquote>
<ul>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器，构造器是虚拟机视角下的<code>&lt;init&gt;()</code></li>
<li>若有父类，会先执行父类的<code>&lt;clinit&gt;()</code></li>
<li><code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
</ul>
</li>
</ol>
<p>可以在IDEA插件中搜索jclasslib Bytecode viewer直接查看字节码文件，然后在view-&gt;Show Bytecode with jclasslib可以显示。</p>
<p><strong>类加载器分类</strong></p>
<ul>
<li><p>引导类加载器：目前只有<code>Bootstrap Class Loader</code> </p>
</li>
<li><p>自定义加载器：所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</p>
</li>
</ul>
<p>虚拟机自带的类加载器：</p>
<ul>
<li><p>启动类加载器(引导类加载器，Bootstrap ClassLoader)：用C++实现，嵌套在JVM内部，用来加载Java核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下内容)，没有父加载器。用户创建的jar放在对应目录，它会自动由扩展类加载器加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看能加载api的路径</span></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL element : urls) &#123;</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用程序类加载器(系统类加载器、AppClassLoader)：父类加载器为扩展类加载器，程序默认的类加载器。</p>
</li>
</ul>
<p>用户自定义类加载器：</p>
<ul>
<li>为什么要自定义加载器：隔离加载类(避免包冲突)、修改类加载的方式、扩展加载源、防止源码泄露</li>
<li>实现步骤：JDK1.2之前需要继承ClassLoader类重写<code>loadClass()</code>方法，JDK1.2之后建议加载逻辑写在<code>findClass()</code>中。若没有过于复杂的需求，可以继承URLClassLoader类，避免编写<code>findClass()</code>和获取字节码流方式</li>
</ul>
<p><strong>ClassLoader</strong></p>
<p>ClassLoader类，是抽象类，所有类加载器都继承它。(除了启动类加载器)</p>
<ul>
<li><code>getPrent()</code>：返回它的超类加载器</li>
<li><code>loadClass(String name)</code>：加载name类，返回java.lang.Class实例</li>
<li><code>findClass(String name)</code>：查找name类，返回java..Class实例</li>
<li><code>finLoadedClass(string name)</code>：查找已被加载过的name类，返回java.lang.Class实例</li>
<li><code>defineClass(String name,byte[] b,int off,int len)</code>：将字节数组b转化类Java类，返回java.lang.Class实例</li>
<li><code>resolveClass(Class&lt;?&gt; c)</code>：连接指定的一个Java类</li>
</ul>
<p>获取ClassLoader方式</p>
<ul>
<li><code>clazz.getClassLoader()</code>：获取当前类的ClassLoader</li>
<li><code>Thread.currentThread().getContextClassLoader()</code>：获取当前线程上下文的ClassLoader</li>
<li><code>ClassLoader.getSystemClassLoader()</code>：后去系统的ClassLoader</li>
<li><code>DriverManager.getCallerClassLoader()</code>：获取调用者的CLassLoader</li>
</ul>
<p><strong>双亲委派机制</strong></p>
<p>Java虚拟机对class文件采用按需加载方式，需要使用才会加载生成class对象。加载class时，采用双亲委派模式，把请求交给父类处理，一种任务委派模式。</p>
<p>工作原理：类加载器收到类加载请求，会先将该请求委托给父类加载器执行。父类也会如此，直到顶层启动类加载器。如果父类加载器可以完成加载，就成功返回。如果父类加载器无法加载，子加载器才会尝试自己加载。</p>
<p>优势：避免类的重复加载、保护程序安全，防止核心API被随意篡改</p>
<blockquote>
<p>避免重复加载：因为双亲委派机制使得类加载也有此次关系</p>
</blockquote>
<p>沙箱安全机制：自定义String时，加载器会加载rt.jar下的String，以保证堆源代码保护。</p>
<p>JVM中表示两个Class对象是否为同一个类的俩必要条件：包名+类名完全一致、类加载器一致</p>
<p>类的主动使用和被动使用</p>
<p>主动使用：</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或堆它赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果，REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
<p>被动使用：除了以上七种情况，其他使用都被看做被动使用，不会导致初始化类</p>
<h2 id="3、运行时数据区及线程"><a href="#3、运行时数据区及线程" class="headerlink" title="3、运行时数据区及线程"></a>3、运行时数据区及线程</h2><p>JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略。保证JVM的运行。不同JVM堆内存的划分方式和管理机制存在一些差异。</p>
<p>元空间：1.8以后叫永久代</p>
<p><img src="/2021/05/07/JVM/JVM%5Cimage-20201107141945023.png" alt="image-20201107141945023"></p>
<p>线程独有：程序计数器、栈、本地站</p>
<p>线程间共享：堆、堆外内存(永久代或元空间、代码缓存)</p>
<p>每个JVM只有一个Runtime实例，即为运行时环境，相当于内存结构中的框框：运行时环境</p>
<p>在HotSpot JVM中，每个线程都与操作系统的本地线程直接映射。</p>
<p>如果程序中只有剩下守护线程，虚拟机就退出了。如果当前线程是最后一个普通线程，终止后，虚拟机就停了。</p>
<p>HotShot JVM的后台线程主要有：</p>
<ul>
<li>虚拟机线程：JVM达到安全点才出现。主要执行垃圾收集、线程栈收集、线程挂起以及偏向锁撤销</li>
<li>周期任务线程：用于时间周期时间的体现，一般用于周期性调度执行</li>
<li>GC线程：垃圾收集</li>
<li>编译线程：将字节码编译为本地代码</li>
<li>信号调度线程：接受信号发给JVM，在内部调度进行处理。</li>
</ul>
<h2 id="4、PC寄存器"><a href="#4、PC寄存器" class="headerlink" title="4、PC寄存器"></a>4、PC寄存器</h2><p>PC寄存器(程序计数寄存器)：用来存储下一条指令的地址。</p>
<p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<p>特点：内存空间小、速度最快，每个线程都有私有，与线程生命周期一致。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，或未指定值(undefned)。程序控制流程都依赖它完成。字节码解释器工作时，通过改变计数器的值来选取吓一跳执行的字节码指令。唯一一个在Java虚拟机中没规定如何oom情况的区域</p>
<blockquote>
<p>未指定值是在执行native方法时 </p>
</blockquote>
<p>为了能记录各个线程正在执行的字节码地址，就给每个线程分配一个pc寄存器</p>
<p>并发：是可以交替执行。</p>
<p>并发：同时执行。</p>
<h2 id="5、虚拟机栈"><a href="#5、虚拟机栈" class="headerlink" title="5、虚拟机栈"></a>5、虚拟机栈</h2><p>栈是运行时的单位，堆是存储的单位</p>
<p>栈解决程序运行问题，堆解决数据的存储问题 </p>
<p>Java虚拟机栈：每个线程创建时都会创建一个虚拟机栈，内部保存一个个的栈帧，对应一次次的Java方法调用。线程私有的。</p>
<ul>
<li><p>生命周期：与线程生命周期一致。</p>
</li>
<li><p>做哦那个：主管Java程序运行，保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
</li>
<li><p>特点：</p>
<ul>
<li>快速有效的分配存储方式，速度仅次于程序计数器</li>
<li>JVM对栈的操作只有两个：方法执行时入栈操作、结束后出栈</li>
<li>栈不存在垃圾回收问题</li>
</ul>
</li>
</ul>
<p>栈常见异常</p>
<ul>
<li>Java虚拟机规范允许栈的大小是动态或固定不变的<ul>
<li>如果是固定大小，如果线程请求分配的栈容量超过虚拟机栈允许的最大容量，虚拟机会抛出StackOverflowError异常</li>
<li>如果是动态扩展，在尝试扩展时无法申请到足够内存，或在创建新线程时没有足够内存去创建对应虚拟机栈，虚拟机会抛出OutOfMemoryError</li>
</ul>
</li>
</ul>
<p>设置栈空间大小在<a href="https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html" target="_blank" rel="noopener">官网</a>查看信息说明</p>
<p>通过<code>-Xss size</code>设置栈空间大小(以字节为单位)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IDEA可以在Run-&gt;Edit Configuration…设置VM options</p>
</blockquote>
<p>栈的存储内容：栈中数据都是以栈帧的格式存在，这个线程上正在执行的每个方法都对应一个栈帧，栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p>
<p>运行原理：</p>
<ul>
<li>遵循：先进后出原则</li>
<li>在一条活动线程中，一个时间点上只能有一个活动的栈帧(栈顶栈帧)，成为当前栈帧，与之对应的方法就是当前方法，定义该方法得类就是当前类</li>
<li>执行引擎运用的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果调用了其它方法，会创建新的栈帧并放在栈顶</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的</li>
<li>两种返回函数的方式都会导致栈帧被弹出：一是正常的函数返回，使用return指令、二是抛出异常(没有处理)</li>
</ul>
<p>栈帧内部结构</p>
<ul>
<li>局部变量表(Local Variables或本地变量表)：</li>
<li>操作数栈(Operand Stack或表达式栈)</li>
<li>动态链接(Dynamic Linking或指向运行时常量池的方法引用)</li>
<li>方法返回地址(Return Address或方法正常退出或异常退出的定义)</li>
<li>一些附加信息</li>
</ul>
<blockquote>
<p>方法返回地址、动态链接、一些附加信息，统称帧数据区</p>
</blockquote>
<p><strong>局部变量表</strong>：</p>
<ul>
<li><p>定义为一个数字数组，主用与存储方法参数和定义在方法体内的局部变量。数据类型包括基本数据类型、对象应用和returnAddress类型。</p>
<ul>
<li><p>局部变量表，最基本存储单元是Slot(变量槽)</p>
</li>
<li><p>在局部变量表里32位以内的类型只占一个slot(包括returnAddress类型)，64位的类型(long和double)占两个slot</p>
<ul>
<li>byte、short、char在存储前被转化为int，boolean也被转化为int，0表示false，非0表示true。</li>
<li>long和double，则占俩slot</li>
</ul>
</li>
<li><p>每个Slot都会分配一个访问索引，通过索引访问指定局部变量值。</p>
</li>
<li><p>当实例方法被调用，它的方法参数和方法体内部定义的局部变量会被顺序复制到局部变量表的每个slot上。</p>
</li>
<li><p>如果访问64bit的局部变量值时，只需要使用前一个索引即可</p>
</li>
<li><p>如果当前帧是构造方法或实例方法创建，那么对象应用this会存放在index为0的slot上，其余参数按序排列。</p>
</li>
<li><p>没有声明的变量在局部变量表里是没有的。</p>
</li>
<li><p>slot槽位是可以重用的，如果一个局部变量过了其作用域，之后声明的新局部变量可以重复使用槽位，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>局部变量表是建立在线程栈上，线程私有的，不存在数据安全问题</p>
</li>
<li><p>局部变量所需的容量大小在编译器就确定下来，并保存在方法的属性maximum local variables数据项中。方法运行期间不改变它的大小</p>
<ul>
<li>在反编译后就是locals=?指的就是大小</li>
</ul>
</li>
<li><p>在方法调用结束后，随着方法栈桢的销毁，局部变量表也会随之销毁</p>
</li>
<li><p>在class文件里，LineNumberTable记录的是指令行号和Java代码行号对应关系</p>
</li>
<li><p>在class文件里，LocalVariableTable就是局部变量表</p>
<ul>
<li>里面startPC就是字节码指令行号，length和startPC结合是描述当前变量作用域的范围</li>
</ul>
</li>
<li><p>在class文件里Descriptor就是描述参数和返回值，Access flags指权限(如public static)</p>
</li>
</ul>
<p>变量分类：</p>
<ul>
<li>按数据类型：基本数据类型、引用数据类型</li>
<li>按类中声明位置：<ul>
<li>成员变量：在使用前，都经历默认初始化赋值<ul>
<li>类变量：linking的prepare阶段：给类变量赋默认值–&gt;initial阶段：给类变量赋值即静态代码块赋值</li>
<li>实例变量：随着对象的创建在堆空间中分配变量空间，并进行默认赋值</li>
</ul>
</li>
<li>局部变量：在使用期，必须显式赋值。</li>
</ul>
</li>
</ul>
<p>补充</p>
<ul>
<li>在栈帧中，与性能调优关系最密切的就是局部变量表<ul>
<li>局部变量表的引用会涉及垃圾回收，并且局部变量表的大小比较严重的影响了栈帧的大小。</li>
<li>局部变量表中变量也是重要的垃圾回收根节点，只要被局部变量直接或间接引用的对象都不会被回收</li>
</ul>
</li>
</ul>
<p>操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈</p>
<ul>
<li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再把结果压入栈。如执行复制、交换、求和等</p>
</li>
<li><p>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时存储空间</p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行，新的栈帧也会被创建，这个方法的操作数栈是kk哦那个的</p>
</li>
<li><p>每个操作数栈都有一个明确的栈深度用于存储数值，所需的最大深度，在编译器就定义好，保存在方法的Code属性中，为max_stack的值</p>
</li>
<li><p>32bit占一个栈单位深度、63bit占两个栈单位深度</p>
</li>
<li><p>操作数栈并非采用索引的方式来访问，而是入栈和出栈操作来完成一次数据访问。</p>
</li>
<li><p>如果调用的方法带有返回值，返回值也会被压如操作数栈中，并更新PC寄存器的指令</p>
</li>
<li><p>操作数栈中元素的数据类型和字节码指令的序列严格匹配。由编译器在编译期间验证，在类加载过程中的类检验阶段的数据流分析阶段再验证</p>
</li>
<li><p>Java虚拟机的解释引擎是基于栈的执行引擎，栈就是指操作数栈</p>
</li>
</ul>
<p>栈式架构虚拟机的入栈和出栈指令次数多。由于操作数存储在内存中，大量的出栈入栈会频繁的执行内存读写操作，影响执行深度，HotSpot引入了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，来降低对内存的读写次数，提升执行效率</p>
<p><strong>动态链接</strong></p>
<p>大部分字节码执行的时候需要进行常量池访问，每个栈帧内部都包含一个执行运行时常量池中该栈帧所属方法的引用。为了能使得当前方法的代码能够实现动态链接。动态链接的作用就是将这些符号引用转换为调用方法的直接引用。</p>
<blockquote>
<p>这里的#2就是动态链接</p>
</blockquote>
<p><img src="/2021/05/07/JVM/image-20201108173715382.png" alt="image-20201108173715382"></p>
<p>方法的调用：</p>
<p>在JVM中，将符号引用转化为调用方法的直接引用与方法的绑定机制有关</p>
<ul>
<li>静态链接：被调用的目标方法在编译期可知，且在运行期保持不变，这时将调用方法的符号引用转为直接引用，过程称为静态链接</li>
<li>动态链接：被调用的方法在编译期无法确定下来，只能在程序运行期将调用方法的符号引用转化为直接引用，被称为动态引用</li>
</ul>
<p>方法的绑定机制：绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，这仅仅发生一次</p>
<ul>
<li>早期绑定：被调用的目标方法如果在编译器可知，且运行期保持不变，即可将该方法和所属类型绑定。</li>
<li>晚期绑定：若被调用的方法在编译期无法确定，只能在运行期根据实际的类型绑定相关方法。则称晚期绑定。</li>
</ul>
<blockquote>
<p>Java中任何一个普通方法都具备虚函数的特征，相当于C++中虚函数，如果不希望某个方法拥有虚函数的特征时，可以用final来修饰该方法</p>
</blockquote>
<ul>
<li>虚方法：除非虚方法都为虚方法</li>
<li>非虚方法：在编译期间就确定了具体的调用版本，在运行期不变的，这样的方法被称为非虚方法(如：静态方法、私有方法、final方法、实例构造器、父类方法)</li>
</ul>
<p>虚拟机提供了几条方法调用指令：</p>
<ul>
<li>普通调用指令<ul>
<li>invokestatic：调用静态方法，解析阶段确定为一方法版本</li>
<li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有以及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析出需要调用的方法，再执行</li>
</ul>
</li>
</ul>
<blockquote>
<p>在子类调用父类的final方法，不加<code>super.</code>指令可能是invokevirtual，但我们不认为它是虚方法</p>
</blockquote>
<p>区分动态类型语言和静态类型语言：区别在于对类型的检查是在编译期还是运行期，前者静态类型语言，后者动态类型语言。</p>
<p>Java中重写本质</p>
<ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记c</li>
<li>若类型c中找到与常量中描述符合简单名称都相符的方法，则进行访问权限校验，如果通过，就返回方法引用，如果不通过返回<code>java.lang.IllegalAccessError</code>异常</li>
<li>否则就按照继承关系网上找</li>
<li>如果始终没找到，抛出<code>java.lang.AbstractMethodError</code></li>
</ul>
<blockquote>
<p><code>java.lang.IllegalAccessError</code>：当程序试图访问或修改一个属性或调用一个方法，这个属性或方法，没有权限访问时，会引起编译器异常，若错误发生在运行时，会报错。maven项目中jar包冲突经常会发生。</p>
</blockquote>
<p>虚方法表：如果每次都动态分派，寻找相应目标，会影响效率，为了提高性能，JVM在类的方法区建立一个虚方法表。</p>
<ul>
<li>每个类都有一个虚方法表，表中存放各个方法实际入口。</li>
<li>虚方法表在类加载的链接阶段被创建并开始初始化，类的变量初始化准备完之后，JVM会把该类的方法表也初始化完毕</li>
</ul>
<p><strong>方法返回地址</strong></p>
<p>方法返回地址：存放调用该方法的pc寄存器的值</p>
<p>方法结束后，会返回到该方法被调用的位置，方法正常退出时，调用者的pc计数器的值作为返回地址，就是调用该方法指令的下一条指令的地址。若异常退出，返回地址要通过异常表来确定，栈帧中一般不保存这部分信息。</p>
<blockquote>
<p>异常完成出口退出的不会给他的上层调用者产生任何返回值</p>
</blockquote>
<p>返回指令：ireturn(boolean、byte、char、short、int)、lreturn、freturn、dreturn、areturn(引用)、return(void)</p>
<p>附加信息：可选。</p>
<p><strong>面试题</strong></p>
<ul>
<li>举例栈溢出情况：StackOverflow</li>
<li>调整栈大小，能保证不出现溢出吗？不能</li>
<li>分配的栈内存越大越好吗?可能会挤占别的空间</li>
<li>垃圾回收是否会涉及到虚拟机栈?不会！<ul>
<li>程序计数器：无error无GC</li>
<li>虚拟机栈：存在error无GC。只有进栈出栈，出栈就相当于垃圾回收</li>
<li>本地方法栈：和虚拟机栈类似</li>
<li>堆：存在error有GC</li>
<li>方法区：存在溢出有error有GC</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全?具体问题具体分析。如果是方法内部创建销毁，不由参数传入或返回则是安全的。不然是不安全的<ul>
<li>如果只有一个线程才可以操作此数据，必然是线程安全的。如果多个线程操作可能不安全</li>
<li>StringBuilder线程不安全、StringBuffer线程安全。</li>
</ul>
</li>
</ul>
<h2 id="6、本地方法接口"><a href="#6、本地方法接口" class="headerlink" title="6、本地方法接口"></a>6、本地方法接口</h2><p>一个Native Method就是一个Java调用非Java代码的接口</p>
<p>为何要用Native Method</p>
<ul>
<li>与Java环境外交互：如与底层系统交换信息等。为我们提供一个简洁的接口，无需区了解Java外的细节</li>
<li>与操作系统交互：通过本地方法，可以用Java实现jre与底层系统的交互</li>
<li>Sun’s Java：sun的解释器是c实现的，使得它能像c一样与外部交互</li>
</ul>
<h2 id="7、本地方法栈"><a href="#7、本地方法栈" class="headerlink" title="7、本地方法栈"></a>7、本地方法栈</h2><p>本地方法栈用于管理本地方法的调用。</p>
<ul>
<li>线程私有</li>
<li>可以设置为固定或动态扩展的大小<ul>
<li>如果超过分配大小报StackOverflowError异常</li>
<li>如果动态扩展，没有足够内存去创建本地方法栈。会抛出OutOfMemoryError异常</li>
</ul>
</li>
<li>当线程调用本地方法时，就进入不再受虚拟机限制的世界，它和虚拟机拥有同样的权限<ul>
<li>本地方法可以通过本地方法接口访问虚拟机内部运行时数据区</li>
<li>甚至可以使用本地处理器的寄存器</li>
<li>直接从本地内存的堆里分配任意数量的内存</li>
</ul>
</li>
</ul>
<p>不是所有JVM都都支持本地方法。Java虚拟机规范没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。也可以不实现本地方法栈。</p>
<p>在HotShot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>
<h2 id="8、堆"><a href="#8、堆" class="headerlink" title="8、堆"></a>8、堆</h2><p>方法区和堆对于一个进程(一个JVM实例)是唯一的。一个进程有多个线程。</p>
<p>堆是Java内存管理的核心区域。在JVM启动的时候就创建了，大小也就确定了，是JVM管理的最大的内存空间。</p>
<p>堆可以处于物理上不连续的内存空间，但逻辑上应该被视为连续的。</p>
<p>所有的线程共享Java堆，这里还能划分线程私有缓冲区(TLAB )</p>
<p>JVM规范描述：所有对象实例以及数组都应当在运行时分配在堆上。(实际上是”几乎”都在堆分配内存)</p>
<p>堆中对象，仅在垃圾收集时才会移除。</p>
<p>堆，是GC执行垃圾回收的重点区域。</p>
<blockquote>
<p>堆内存大小可以调节</p>
<p>因为都共享的话并发能力较弱</p>
</blockquote>
<p>在jdk/bin目录下的<code>jvisualvm.exe</code>工具可以查看进程的详细信息。并且可以在<code>工具</code>装插件</p>
<p><strong>堆内存</strong></p>
<p>现代垃圾收集器大部分基于粉黛收集理论设计，将堆空间细分</p>
<ul>
<li>Java7以前：新生区、养老区、永久区</li>
<li>Java8及以后：新生区、养老区、元空间</li>
</ul>
<p>新生区又分：伊甸园区、幸存者0区、幸存者1区(0区和1区不会同时使用，会选择一个使用)</p>
<blockquote>
<p>新生区=新生代=年轻代、养老区=老年区=老年代、永久区=永久代</p>
<p>幸存者0、1区，又称from区和to区。</p>
<p>to区是指空的幸存者区</p>
</blockquote>
<p>堆内存大小的设置：</p>
<ul>
<li>“-Xms”：用于表示堆区的起始内存等价于”-XX:InitialHeapSize”</li>
<li>“-Xmx”：用于表示堆区的最大内存等价于“-XX:MaxHeapSize”</li>
</ul>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，为了能够在垃圾回收机制清理完堆区后不需要重新分隔计算堆区大小，从而提高性能</p>
<p>默认：初始内存大小为物理电脑内存大小/64、最大内存大小为物理电脑内存大小/4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms1m</span><br><span class="line">-Xms1024k</span><br><span class="line">-Xms1048576</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    System.out.println(<span class="string">"-Xms : "</span> + initialMemory + <span class="string">"M"</span>);</span><br><span class="line">    System.out.println(<span class="string">"-Xmx : "</span> + maxMemory + <span class="string">"M"</span>);</span><br><span class="line">    System.out.println(<span class="string">"系统内存大小为："</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">"G"</span>);</span><br><span class="line">    System.out.println(<span class="string">"系统内存大小为："</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">"G"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>jstat gc 线程号</code>查看进程的内存使用情况</p>
<blockquote>
<p>查看堆空间参数：</p>
<ul>
<li>1.<code>jps</code> 2.<code>jstat -gc 进程id</code></li>
<li><code>-XX:+PrintGCDetails</code></li>
</ul>
</blockquote>
<p>S：幸存者区</p>
<p>E：伊甸园区</p>
<p>O：老年代</p>
<p>C：可用</p>
<p>U：用完</p>
<p><img src="/2021/05/07/JVM/image-20201109192417710.png" alt="image-20201109192417710"></p>
<p><strong>年轻代与老年代</strong></p>
<p>JVM中的Java对象可以分为两类：</p>
<ul>
<li>生命周期较短的瞬时对象</li>
<li>生命周期长，甚至与JVM生命周期一致</li>
</ul>
<p><img src="/2021/05/07/JVM/image-20201109211619066.png" alt="image-20201109211619066"></p>
<p>配置新生代与老年代在堆结构占比(<strong>一般不会改</strong>)：</p>
<ul>
<li>默认 <code>-XX:NewRatio=2</code>，表示新生代1，老年代2</li>
<li>可以修改<code>-XX:NewRation=4</code>，表示新生代1，老年代4</li>
<li><code>-Xmn</code>可以设置新生代空间大小(一般用不到)。可能会使得比例失效</li>
</ul>
<blockquote>
<p><code>jinfo -flag NRation 进程id</code>可以查看进程的新生代与老年代占比</p>
</blockquote>
<p>在HotSpot中，Eden空间和另外两个Survivor空间比例是8:1:1。可以通过<code>-XX:SurvivorRatio=数字</code>调整占比，默认为8。</p>
<p>几乎所有对象都是在Eden区new出来，绝大部分对象在新生代销毁</p>
<blockquote>
<p>但实际情况，比例可能不是8。因为有一个适合设置，可以通过配置<code>-XX:-UseAdaptiveSizePolicy</code>关闭自适应，自适应也会影响，两个幸存者区，可能使得两个大小不一样。</p>
</blockquote>
<p><strong>分配对象过程</strong>：新创建的对象分配在伊甸园区，直到伊甸园区，放满。进行垃圾回收(YGC/Minor GC)。判断为垃圾的对象销毁，剩余对象放入幸存者区并且为每个对象分配一个年龄计数器(age)为1。再往伊甸园区创建对象，直到放满。触发GC。将伊甸园区未被销毁的对象和幸存者区未被销毁的对象age+1，放入另一个线程者区。然后循环往复。当幸存者区的对象age为15，晋升入老年代age为16。在老年代就不再考虑age值。</p>
<ul>
<li><p>YGC/Minor GC触发的时候会将幸存者区和伊甸园区一起回收</p>
</li>
<li><p>幸存者满了不会触发垃圾回收，如果满了但没有达到15，会放入老年代。</p>
</li>
<li><p>可以设置<code>XX:MaxTenuringThreshold=&lt;N&gt;</code>设置区养老区的次数，默认15</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>幸存者S0、S1区：复制之后有交换，谁空谁是to。(复制指的是用到的复制算法)</li>
<li>垃圾回收：频繁在新生区，很少在养老区，几乎不在永久区/元空间</li>
</ul>
<p><img src="/2021/05/07/JVM/image-20201110121201621.png" alt="image-20201110121201621"></p>
<p><strong>GC对比</strong></p>
<p>GC的时候会导致用户线程的暂停</p>
<p>jVM进行GC时，并非每次都对三个内存(新生代、老年代、方法区)区域一起回收。大部分回收是在新生代。</p>
<p>HotSpot VM的实现，GC按照回收区域分俩类：</p>
<ul>
<li>部分收集(Partial GC)：又分<ul>
<li>新生代收集(Minor GC / Young GC)：当Eden代满，触发Minor GC。Survivor满不会触发。Minor GC非常频繁，回收深度快。会引发STW，暂停其它用户的线程，等结束再恢复。</li>
<li>老年代收集（Major GC / Old GC)：对象从老年代消失时，Major GC就发生了，往往还会伴随至少一次的Minor GC。老年代空间不足会先尝试触发Minor GC，空间还不足则触发major GC。Major比Minor慢10倍以上，STW时间更长。如果内存还不足报OOM<ul>
<li>目前只有CMS GC会单独收集老年代</li>
<li>很多时候Major GC和Full GC混淆使用。需要具体分辨。</li>
</ul>
</li>
<li>混合收集(Mixed GC)：收集整个新生代和部分老年代<ul>
<li>目前只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集(Full GC) ：收集整个堆和方法区的垃圾收集<ul>
<li>触发机制<ul>
<li><code>System.gc()</code>，但不是必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代可用内存</li>
<li>由Eden、From区向To区复制时，对象大小大于To区可用内存，则把该对象转存到老年代且老年代的可用内存小于该对象大小。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>分代思想</strong></p>
<p>为何分代：不同的对象生命周期不同，70%—99%的对象都是临时对象</p>
<p>不分代也是完全可以的，分代的原因是为了<strong>优化GC性能</strong>。</p>
<p>大对象往往直接分配到老年代。因为幸存者区往往比伊甸园区小，伊甸园区都放不下一般直接到老年代。尽量避免大对象。</p>
<p>动态对象年龄判断：若Survivor区中相同年龄的对象大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象直接进入老年代。无需达到阈值</p>
<p>空间分配担保：当GC后仍有大量对象存活。因为幸存者区较小，需要老年代担保，幸存者区无法容纳的对象放入老年代。</p>
<p><code>-XX:HandlePromotionFailure</code>：在Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有的总空间。</p>
<ul>
<li>若大于，则Minor GC安全</li>
<li>若小于，会查看<code>-XX:HandlePromotionFailure</code>是否为true<ul>
<li>若为true，会检查老年代的连续空间是否大于历次晋升到老年代对象的平均大小<ul>
<li>若大于，则尝试Minor GC，但仍有风险</li>
<li>若小于，则进行Full GC</li>
</ul>
</li>
<li>若为false，则进行一次Full GC</li>
</ul>
</li>
</ul>
<p>现在的规则变为：只要老年代的连续空间大于新生代对象总大小或历次晋升的平均大小就会进行Minor GC，否则Full GC。</p>
<blockquote>
<p>在JDK7以及之后，HandlePromotionFailure不会影响空间分配担保策略，但源码中仍然定义，只是不起作用。</p>
</blockquote>
<p><strong>TLAB</strong></p>
<p>TLAB解决的问题：堆区是线程共享区域，任何线程都能访问，由于对象实例化在JVM中非常频繁，因此在并发环境下堆区中划分内存空间是不安全的，为避免并发操作同一地址，需要加锁等机制进而影响分配速度。</p>
<p>TLAB：是从内存模型而不是垃圾收集的角度，对Eden区域进行划分。JVM在Eden区为每个线程分配了一个私有缓存区域。TLAB可以避免一系列非线程安全问题，同时还能提升内存分配的吞吐量，所以称为快速分配策略。</p>
<blockquote>
<p>由Open JDK衍生的JVM都提供了TLAB的支持。</p>
</blockquote>
<p>不是所有对象都在TLAB中成功分配，但TLAB确是JVM内存分配的首选。可以通过<code>-XX:UseTLAB</code>设置是否开启TLAB。默认情况下TLAB仅占Eden的1%。可以通过<code>-XX:TLABWasteTargetPercent</code>设置占比大小。一旦TLAB失败，JVM会通过加锁机制确保操作原子性。</p>
<p><strong>堆空间参数设置</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">官网参数说明</a></p>
<ul>
<li>测试堆空间常用的jvm参数：</li>
<li><code>-XX:+PrintFlagsInitial</code> : 查看所有的参数的默认初始值</li>
<li><code>-XX:+PrintFlagsFinal</code> ：查看所有的参数的最终值（可能会存在修改，不再是初始值<ul>
<li>具体查看某个参数的指令：<code>jps</code>：查看当前运行中的进程，<code>jinfo -flag SurvivorRatio 进程id</code></li>
</ul>
</li>
<li><code>-Xms</code>：初始堆空间内存 （默认为物理内存的1/64）</li>
<li><code>-Xmx</code>：最大堆空间内存（默认为物理内存的1/4）</li>
<li><code>-Xmn</code>：设置新生代的大小。(初始值及最大值)</li>
<li><code>-XX:NewRatio</code>：配置新生代与老年代在堆结构的占比</li>
<li><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0/S1空间的比例</li>
<li><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄</li>
<li><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志</li>
<li>打印gc简要信息（用的少）：① <code>-XX:+PrintGC</code>   ② <code>-verbose:gc</code></li>
<li><code>-XX:HandlePromotionFailure</code>：是否设置空间分配担保</li>
</ul>
<p><strong>堆分配对象不是唯一的选择</strong></p>
<p>如果经过逃逸分析，一个对象没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需垃圾回收</p>
<p>此外，TaoBao VM中创新的GCIH技术实现off-heap，将生命周期较长的Java对象移到heap外，且GC不能管理GCIH内部Java对象。以此达到降低GC频率和提高效率的目的。</p>
<blockquote>
<p>《深入理解Java虚拟机》：随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了</p>
</blockquote>
<p>只要在该方法外部引用就是逃逸了。jdk开始就开启逃逸分析。</p>
<p><code>-XX:+DoEscapeAnalysis</code>：老版本可以通过该参数开启逃逸分析</p>
<p><code>-XX:+PrintEscapeAnalysis</code>：查看逃逸分析的筛选结果</p>
<p>使用逃逸分析后，可以做以下优化：</p>
<ul>
<li>栈上分配：将堆分配转化为栈分配。</li>
<li>同步省略：如果一个对象被发现只能从一个线程被访问，对这个对象的操作可以不考虑同步<ul>
<li>线程同步的代价是相当高的，代价是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，JIT编译器在编译时会取消对这部分代码的同步，也叫锁消除。</li>
</ul>
</li>
<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也能被访问，那么对象的部分或全部可以不存储在内存，而是CPU寄存器中(Java是放入栈中)<ul>
<li>标量：指无法再分解为更小的数据的数据。如Java中的基本数据类型</li>
<li>聚合量：可以分解的数据</li>
<li>标量替换：经过逃逸分析，如果一个对象不被外界访问，可以把它分解成若干个成员变量还代替。</li>
<li>标量替换后，就存入栈中，减少GC和内存占用</li>
<li><code>-XX:-EliminateAllocations</code>：关闭标量替换</li>
</ul>
</li>
</ul>
<p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:PrintGC -XX:+EliminateAllocations</code></p>
<ul>
<li><code>server</code>：启动Server模式，在Server模式下才可以打开逃逸模式。默认打开</li>
<li><code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</li>
<li><code>-Xmx100m</code>：指定堆空间最大10MB</li>
<li><code>-XX:PrintGC</code>：打印GC日志</li>
<li><code>-XX:+EliminateAllocations</code>：开启标量替换(默认打开)</li>
</ul>
<blockquote>
<p>逃逸分析并不成熟，因为无法保证逃逸分析的性能小号一定高于它的性能消耗。</p>
<p>HotSpot并未使用栈上分配，使用了标量替换。所以所有的对象实例都是创建在堆cc上。</p>
</blockquote>
<h2 id="9、方法区"><a href="#9、方法区" class="headerlink" title="9、方法区"></a>9、方法区</h2><p>元空间、永久代都是方法区的实现。</p>
<p><strong>栈、堆、方法区交互关系</strong></p>
<p>线程共享的角度看：</p>
<blockquote>
<p>计数器是没有GC和异常，虚拟机栈和本地方法栈没有GC。堆和元空间都有</p>
</blockquote>
<p><img src="/2021/05/07/JVM/image-20201111131710220.png" alt="image-20201111131710220"></p>
<p><code>Person person = new Persion()</code>：中Person类是放在方法区，new对象是放入Java堆，person引用变量放入Java栈。</p>
<p>方法区逻辑上是堆空间一部分，但方法区可以即不GC也不压缩。规范没有要求方法区为堆的一部分，或不是。也没要求具体存储哪些数据。既可以动态扩展，也可以固定大小。</p>
<p>但对于HotSpot而言，方法区别名Non-Heap(非堆)，就是为了区分堆。所以<strong>方法区看作一块独立于Java堆的内存空间</strong></p>
<p>方法区：</p>
<ul>
<li>与堆一样，各个线程共享的内存区域</li>
<li>方法区在jvm启动时创建，实际的物理内存空间和堆一样可以不连续</li>
<li>方法区大小，可固定，可扩展</li>
<li>方法区的大小决定了可以保存多少类。太多类可能会导致方法区溢出，抛OOM<ul>
<li>如加载大量第三方jar包；Tomcat部署工程过多；大量动态生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放该区域内存</li>
</ul>
<p>到JDK8，完全废弃永久代概念，与JRoctit、J9一样在本地内存中实现的元空间来代替。</p>
<p>元空间与永久代最大的区别：元空间不再虚拟机设置的内存中，而是本地内存</p>
<p>设置方法区内存大小(jdk7)</p>
<ul>
<li><code>-XX:PermSize</code>：设置永久代初始分配空间，默认20.75m。jdk8替换为<code>-XX:MetaspaceSize=size</code></li>
<li><code>--XX:MaxPermSize</code>：设置永久代最大可分配空间，32位默认64m，4位默认82m。jdk8替换为<code>-XX:MaxMetaspaceSize</code></li>
</ul>
<blockquote>
<p><code>jinfo -flag MetaspaceSize 进程id</code>查看元空间大小</p>
</blockquote>
<p>设置方法区内存大小(jdk8)</p>
<ul>
<li><code>-XX:MetaspaceSize=size</code>：windows下默认21M。当超过该值，会触发Full GC。为避免频繁触发GC，可以设置较高的值 </li>
<li><code>-XX:MaxMetaspaceSize：</code>：值为-1，没有限制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m 设置元空间大小</span></span><br><span class="line"><span class="comment">//循环使得方法区溢出代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">"Class"</span> + i, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何解决OOM</strong></p>
<ul>
<li>要解决OOM异常或heap space异常，一般先通过内存映像分析工具，堆dump出来的堆存储快照分析，重点确认内存中对象是否必要的，分清楚是内存泄漏还是内存溢出</li>
<li>若是内存泄漏，通过工具查看泄露对象到GC Roots的引用链。找到泄漏对象是怎样的路径导致无法回收。然后定位泄漏代码的位置<ul>
<li>内存泄漏，指内存中对象后续不会用到，但仍然被引用，使得无法被GC</li>
</ul>
</li>
<li>若不存在内存泄漏，就要检查虚拟机堆参数。与机器物理内存对比，是否可以调大。从代码上检查是否存在生命周期过长的对象</li>
</ul>
<p><strong>方法区的内部结构</strong></p>
<p>方法区主要存储：类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><img src="/2021/05/07/JVM/image-20201111141411942.png" alt="image-20201111141411942"></p>
<p>类型信息：clss、interface、enum、annotation。JVM必在方法区存储以下类型信息。</p>
<ul>
<li>这个类型的完整院校名称(全名=包名.类名)</li>
<li>这个类型直接父类的完整有效名(对于interface或是java.lang.Object，都没有父类)</li>
<li>类型的修饰符(public,abstract,final)</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<p>域信息(Field)信息</p>
<ul>
<li>所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符(public，private，protected，static，final，volatile，transient)</li>
</ul>
<p>方法信息</p>
<ul>
<li>声明顺序</li>
<li>方法名称</li>
<li>返回类型</li>
<li>参数的数量和类型</li>
<li>方法的修饰符</li>
<li>方法的字节码、操作数栈、局部变量表及大小</li>
<li>异常表<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<p>全局常量：static final。被声明为final的类变量在编译的时候就被分配了</p>
<p><strong>运行时常量池/常量池</strong></p>
<p>方法区内部含运行时常量池。字节码文件内部含常量池。</p>
<p>字节码文件中常量池，加载到内存后，就是运行时常量池。</p>
<p>常量池表：包含各种字面量和对类型、域和方法的符号引用。</p>
<p>运行时常量池，在加载每个类和接口到虚拟机后，都会维护一个常量池。常量池内的数据像数组，通过索引访问。运行时常量池不仅包括编译器已经确定的数值字面量，也包括到运行期解析后才能获得的方法或字段引用。此时不再是常量池的符号地址，而是真实地址。运行时常量池具备动态性。能够扩展一些字节码文件内无的数据。</p>
<p><strong>HotSpot中方法区变化</strong></p>
<table>
<thead>
<tr>
<th>jdk1.6及以前</th>
<th>有永久代，静态变量放永久代</th>
</tr>
</thead>
<tbody><tr>
<td>jdk1.7</td>
<td>有永久代，但已逐步”去永久代”，字符串常量池、静态变量移除，保存在堆</td>
</tr>
<tr>
<td>jdk1.7及以后</td>
<td>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，的那字符串常量池，静态变量仍在堆</td>
</tr>
</tbody></table>
<p>为何替换永久代</p>
<ul>
<li>永久代空间大小的设置是很难确定的：在某些场景下，动态加载类过多，很容易产生OOM</li>
<li>永久代进行调优是很困难的：主要回收常量池中<strong>废弃的常量</strong>和<strong>不再使用的类型</strong></li>
</ul>
<p>总结：本地内存可以很大，减少GC</p>
<p>StringTable为何让如堆：因为永久代的回收率很低，只有在full gc才会触发，而full gc是老年代空间不足、永久代不足时才会触发。这导致StringTable回收效率低，而开发中有大量字符串会创建。</p>
<p>只要是对象实例，不管是不是静态都在Java堆中分配。</p>
<p>JDK7以后的HotSpot把静态变量与类型在Java语言一端的映射class对象存放在译器，存储于Java堆中。</p>
<p>JDK8以前静态变量的引用名是放在方法区。</p>
<p><strong>方法区的垃圾回收</strong></p>
<p>Java虚拟机规范，规范可以不在方法区实现垃圾收集。</p>
<p>这个区域的回收效果也不那么令人满意，尤其是类型的卸载，条件相当苛刻。但这部分的回收有时是必要的。曾经因为低版本HotSpot虚拟机未完全回收而导致内存泄漏。</p>
<p>方法区的垃圾回收，主要回收常量池中<strong>废弃的常量</strong>和<strong>不再使用的类型</strong></p>
<ul>
<li>常量(字面量和符号引用)主要有三类：这类回收比较简单，只要没有被任何地方引用，就可以被回收<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>类的回收比较苛刻，需要同时满足三个条件<ul>
<li>该类的所有实例都被回收了。就是堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器以及被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI、JSP的重加载等，否则通常很难达成<ul>
<li>字节码文件是没有记录类加载器的。在被类加载器加载后，放入方法区。方法区里关于当前类记录了由谁进行加载，同时加载器也记录了加载过谁。</li>
</ul>
</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<p>严格来说，major GC指的是老年代的GC，Full GC指的是整个堆区和方法区的GC</p>
<h2 id="10、对象的实例化内存布局与访问定位"><a href="#10、对象的实例化内存布局与访问定位" class="headerlink" title="10、对象的实例化内存布局与访问定位"></a>10、对象的实例化内存布局与访问定位</h2><p>对象的实例化</p>
<ul>
<li><p>创建对象的方式</p>
<ul>
<li><code>new</code><ul>
<li>最常见的方式</li>
<li>单例模式下，构造器不对外暴露，调用它的静态方法。</li>
<li>工厂模式，创建。 </li>
</ul>
</li>
<li>Claa的<code>newInstance()</code>：反射方式，只能调用空参构造器，权限必须为public</li>
<li>Constructor的<code>newInstance(Xxx)</code>：反射方式，可以调用空参、带参的构造器，权限没要求</li>
<li>使用<code>clone()</code>：不调用任何构造器，需要类实现Cloneable接口，实现<code>clone()</code></li>
<li>使用反序列化：从文件中、网络中获取对象的二进制流</li>
<li>第三方库Ojbenesis</li>
</ul>
</li>
<li><p>创建对象的步骤</p>
<ol>
<li>判断对象对应的类是否加载、链接、初始化。如果已经加载直接下一步，如果没有就在双亲委派模式下使用类加载器进行查找对应class文件，如果有就加载，如果没有就抛出ClassNotFoundException异常。</li>
<li>为对象分配内存<ul>
<li>如果内存规整：使用指针碰撞法<ul>
<li>指针碰撞法：在剩余空间和已使用空间之间会有指针指向。如果剩余空间足够，指针相应移动到分界点。</li>
</ul>
</li>
<li>如果内存不规整：虚拟机需要维护一个列表、空闲列表分配。<ul>
<li>空闲列表：记录哪些内存块可用，再分配时从列表中找到一块足够的空间划分，任何更新列表。</li>
</ul>
</li>
<li>说明：Java堆是否规整取决于所采纳的垃圾收集器是否带有压缩整理功能来决定</li>
</ul>
</li>
<li>处理并发安全问题：因为Java堆是共享空间，多线程操作可能有并发安全问题。<ul>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配一块TLAB：通过<code>-XX:+/-UseTLAB</code>参数设定jdk8 默认打开</li>
</ul>
</li>
<li>初始化分配到空间：所有属性设置默认值，保证对象实例字段不在赋值时可以直接使用</li>
<li>设置对象的对象头：将对象所属类、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程具体取决于JVM实现。</li>
<li>执行init方法进行初始化：显式初始化、代码块中初始化、构造器中初始化</li>
</ol>
<p>字节码角度创建对象：</p>
<ol>
<li>new：判断运行时常量池中是否有Object类，没的话用类加载器加载到方法区。再在堆空间确定空间大小和临时初始化。</li>
<li>dup：复制，将栈空间操作数栈中引用复制，共有俩个引用指向堆空间。一个是在栈底用于赋值操作。上面的用于调用相关方法</li>
<li>invokespecial：调用<code>&lt;init&gt;</code>方法，如果构造器有形参，也需要放入操作数栈。可能会属性进行初始化</li>
<li>astore_1：最后将变量从操作数栈取出，放入局部变量表。</li>
</ol>
</li>
</ul>
<p><strong>对象的内存布局</strong></p>
<ul>
<li><p>对象头</p>
<ul>
<li>运行时元数据<ul>
<li>哈希值</li>
<li>GC分代年龄：age</li>
<li>锁状态标志：同步时锁</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
<li>类型指针：指向类元素InstanceKlass，确 定该对象所属的类型(getclass)</li>
</ul>
<blockquote>
<p>若是数组，还要记录数组长度</p>
</blockquote>
</li>
<li><p>实例数据：实体内真正存储的有效信息。包括父类继承下来的和本身拥有的</p>
<ul>
<li>规则：<ul>
<li>相同宽度的字段总是被分配在译器</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙</li>
</ul>
</li>
</ul>
</li>
<li><p>对齐填充：不是必须，单纯的占位符</p>
</li>
</ul>
<p><img src="/2021/05/07/JVM/image-20201112124514721.png" alt="image-20201112124514721"></p>
<p>对象访问：</p>
<p>JVM通过栈帧上referencec定位访问对象实例</p>
<p>对象访问的两种方式：</p>
<ul>
<li>句柄访问<ul>
<li>句柄池：堆空间的一片区域，放了大量句柄。一个对象对应一个句柄。存放俩个信息，一是存放实例数据的指针，二是到对象类型数据的指针</li>
<li>特点：速度慢，对象地址修改只需要修改句柄</li>
</ul>
</li>
<li>直接指针：栈空间的引用直接指向对象实体，对象实体中有类型指针指向，对象类型数据<ul>
<li>特点：速度快，但对象地址修改也要跟随变动</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/07/JVM/image-20201112154022617.png" alt="image-20201112154022617"></p>
<p><img src="/2021/05/07/JVM/image-20201112154047321.png" alt="image-20201112154047321"></p>
<h2 id="11、直接内存"><a href="#11、直接内存" class="headerlink" title="11、直接内存"></a>11、直接内存</h2><p>直接内存：位于Java堆外，直接向系统申请的内存区间。通常直接内存的访问速度优于Java堆。</p>
<blockquote>
<p>NIO库允许使用直接内存</p>
</blockquote>
<p>使用IO读写文件时，需与磁盘交互，需要由用户态切换到内核态。就需要俩份内存存储重复数据，效率低使用NIO读写文件，操作系统划出直接缓冲区直接被Java代码访问，只有一份，提高效率。</p>
<p>直接内存也可能导致OOM异常。它的大小受系统能给出的最大内存限制。</p>
<p>缺点：分配回收成本较高、不受JVM内存回收管理。</p>
<p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。如果不指定默认和堆最大值一致。</p>
<h2 id="12、执行引擎"><a href="#12、执行引擎" class="headerlink" title="12、执行引擎"></a>12、执行引擎</h2><p>前端编译：Java程序到字节码文件</p>
<p>后端编译：执行引擎将字节码编译为机器指令</p>
<p>执行引擎在执行过程中执行什么字节码指令完全依赖于PC寄存器。每执行完一项指令操作后，PC寄存器就会更新下一条将被执行的指令地址。在执行过程中，执行引擎可能会通过存储在局部变量表中的对象引用定位到存储在堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。     </p>
<p>Java程序编译解释运行：</p>
<p>绿色为解释过程，蓝色为编译过程</p>
<p><img src="/2021/05/07/JVM/image-20201112165040864.png" alt="image-20201112165040864"></p>
<p>解释器：虚拟机启动时会对字节码采用逐行解释的方式执行。</p>
<p>JIT编译器：虚拟机将源代码直接编译成和本地机器平台相关的机器语言</p>
<blockquote>
<p>Java是半解释半编译型语言，可以编译执行也可解释执行。</p>
</blockquote>
<p>机器在热机状态可以承受的负载大于冷机状态。如果以热机状态时流量切流，可能使冷机服务器过载假死。</p>
<blockquote>
<p>因为热机状态有一部分字节码以及编译缓存为机器指令效率更高</p>
</blockquote>
<p>编译器：</p>
<ul>
<li><p>前端编译器：将.java文件变成.class文件的过程</p>
</li>
<li><p>后端运行期编译器：将字节码变成机器码的过程</p>
</li>
<li><p>静态提前编译器：直接将.java文件编译为本地机器代码</p>
</li>
</ul>
<p><strong>热点代码及探测方式</strong></p>
<p>是否启动JIT编译器将字节码编译为本地机器指令，需根据执行的频率。执行频率高的代码，称之为”热点代码”，JIT编译器会在运行时针对这些代码做出深度优化。</p>
<p>栈上替换：一个被调用多次的方法，或是方法内部循环多次的循环体都能被称为”热点代码”，都可以通过JIT编译器编译为本地机器指令，由于这种编译方式发生在方法执行过程中，因此也被称为栈上替换，简称OSR。</p>
<p>目前HotSpot采用的热点探测方式是基于计数器的热点探测。HotSpot为每个方法都建立了2个不同类型的计数器，分别为方法调用计数器和回边计数器</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数<ul>
<li>该计数器的默认阈值在Client模式下1500次，在Server模式下10000次。超过该阈值，就会触发JIT</li>
<li><code>-XX:CompileThreshold</code>：可以设定阈值</li>
</ul>
</li>
<li>回边计数器用于统计循环体执行的循环次数</li>
</ul>
<p>热度衰减：</p>
<ul>
<li>如果不做设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是相对频率，即一段时间内方法被调用的次数。当超过一定时间限度，如果仍然达不到阈值，就计数器就会变少一半。该过程称为衰减。这段时间称为半衰周期</li>
<li><code>-XX:UseCounterDecay</code>可以关闭热度衰减</li>
<li><code>-XX:CounterHalfLifeTime</code>设置半衰周期的时间，单位秒</li>
</ul>
<p><img src="/2021/05/07/JVM/image-20201112215616284.png" alt="image-20201112215616284"></p>
<p>HotSpot可以通过命令显式的指定虚拟机式完全采用解释器执行，还是完全采用即使编译器执行，或是混合：</p>
<ul>
<li><code>-Xint</code>：完全采用解释器模式执行程序</li>
<li><code>-Xcomp</code>：完全采用即时编译器模式执行程序，如果即时出问题，解释器会介入</li>
<li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式</li>
</ul>
<blockquote>
<p>如在命令行内<code>java -Xmixed version</code>：改模式</p>
</blockquote>
<p>JIT分类</p>
<p>HotSpot内嵌俩个JIT编译器，Client Compiler和Server Compiler，简称C1和C2</p>
<ul>
<li><code>-client</code>：使用C1编译器。编译器对字节码简单和可靠的优化，耗时短。<ul>
<li>优化策略：<ul>
<li>方法内联：将引用的函数代码编译到引用点出，减少栈帧生成，减少参数传递以及跳转</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
</ul>
</li>
<li><code>-server</code>：使用C2编译器，进行耗时长的，激进的优化，执行效率高。用C++编写的<ul>
<li>优化策略：<ul>
<li>标量替换</li>
<li>栈上分配</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分层编译策略：程序解释执行不开启性能监控可以触发C1编译，将字节码编译成机器码，也可以加上监控，C2会根据性能监控信息激进优化，优化失败就退回C1。<code>-server</code>模式下默认开启分层编译策略。互相协作完成编译任务</p>
<blockquote>
<p>64位默认用server。使用client会被忽略。</p>
</blockquote>
<p>JDK10起，HotSpot加入全新即时编译器Graal编译器，编译效果追平C2编译器，目前带“实验状态”标签，要使用开关参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code>激活才能用。</p>
<p>JDK9引入AOT编译器(静态提前编译器，和JIT一个性质)，AOT编译指的是在程序运行之前将代码转化为机器码的过程</p>
<p>即时编译指的是，在程序运行过程中，将字节码转化为机器指令并部署到托管环境中的过程</p>
<p>AOT的特点</p>
<ul>
<li>优点：以即编译为二进制，不必等编译器预热，减少Java程序第一次运行慢的体验</li>
<li>缺点：破坏了一次编译，到处运行，必须为不同硬件、os编译对应发行包。降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。还需继续优化最初支持linux x64</li>
</ul>
<h2 id="13、StringTable"><a href="#13、StringTable" class="headerlink" title="13、StringTable"></a>13、StringTable</h2><p> JDK9及以后底层又char改为byte，String是主要的空间存储对象，大部分String是拉丁字符。拉丁字符一个byte就能存。其它String结构底层同样做了修改</p>
<p>String基本特性：</p>
<ul>
<li>字符串常量池中不会存储相同内容的字符串</li>
<li>String的String Pool是固定大小的Hashtable，默认值1009(JDK7中默认长度60013，JDK8开始1009是可设最小值)若String Pool中String非常多，会造成hash冲突，从而导致链表很长，影响调用String.intern时的性能</li>
<li><code>-XX:StringTableSize</code>可设置StringTable长度</li>
</ul>
<blockquote>
<p><code>String.inter()</code>如果字符串常量池中没有对应的字符的话，则在常量池中生成，并返回常量池中地址。有就直接返回。</p>
</blockquote>
<p>常量池：为了使8种基本数据类型和String运行过程中速度更快、更节省内存，都提供了一种常量池的概念。类似Java系统级别提供的缓存，由系统协调。</p>
<p>String的常量池比较特殊使用方法有两种</p>
<ul>
<li><code>String info = &quot;xxx&quot;</code>：双引号直接声明的String对象存储在常量池中</li>
<li>如果不是双引号声明的String对象，可以用intern()方法</li>
</ul>
<p>Java6及以前，字符串常量池放在永久代，7</p>
<p>中Oracle工程师对字符串池的逻辑做了很大改变，将字符串常量池的位置调整到Java堆内</p>
<ul>
<li>所有的字符串都保存在堆内，和其它普通对象一样，调优时仅需调整堆大小即可</li>
<li>字符串常量池概念原本使用的较多，该改动使我们有足够理由重新考虑Java7中使用String.intern()</li>
</ul>
<p>为何调整StringTable：1.因为永久代默认比较小，容易溢出2.永久代回收效率低</p>
<p>Java语言规范要求完全系统的字符串字面量，应该包含同意的Unicode序列，并且必须指向同一个String实例</p>
<p><strong>字符串拼接操作</strong></p>
<ul>
<li><p>常量与常量(或常量引用)的拼接结果在常量池，原理是编译器优化。非StringBuilder</p>
</li>
<li><p>常量池中不存在相同内容的常量</p>
</li>
<li><p>只要其中有一个是变量，结果就在堆中。变量拼接原理是StringBuilder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1+s2的实质 5.0之前是StringBuffer</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(s1);</span><br><span class="line">stringBuilder.append(s2);</span><br><span class="line">stringBuilder.toString();<span class="comment">//约等于new String("s1和s2的内容")</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果拼接结果调用intern()，则主动将常量池中还没的字符串对象放入池中，并返回此对象地址。</p>
</li>
</ul>
<p>总结：如果拼接符号前后出现了变量，则相当于在堆空间中new String()，具体的内容位拼接的结果</p>
<blockquote>
<p>在开发中，如果基本确定前后添加字符串的长度不高于一个值，可以在创建StringBuilder的时候就指定它的容量</p>
</blockquote>
<p> 题目：</p>
<ul>
<li><code>new String(&quot;ab&quot;)</code>会创建几个对象<ul>
<li>从字节码看是两个，一个是new关键字在堆空间创建的，一个是常量池中的”ab”，用指令ldc取出入栈</li>
</ul>
</li>
<li><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code>：有几个对象？<ul>
<li>对象1：new StringBuilder</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池“a“</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池中的”b”</li>
<li>对象5：StringBuuilder的toString()会new String(“ab”)，但常量池中是没有ab的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk7后intern方法的变化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了"1"</span></span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);<span class="comment">//s3变量记录的地址为：new String("11")</span></span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！</span></span><br><span class="line">    s3.intern();<span class="comment">//在字符串常量池中生成"11"。如何理解：</span></span><br><span class="line">    <span class="comment">// jdk6:在常量池创建了一个新的对象"11",也就有新的地址。</span></span><br><span class="line">    <span class="comment">// jdk7:此时常量中并没有创建"11",而是创建一个指向堆空间中new String("11")的地址</span></span><br><span class="line">    String s4 = <span class="string">"11"</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intern扩展</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//StringIntern.java中练习的拓展：</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);<span class="comment">//new String("11")</span></span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！</span></span><br><span class="line">    String s4 = <span class="string">"11"</span>;<span class="comment">//在字符串常量池中生成对象"11"</span></span><br><span class="line">    String s5 = s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>intern总结：</p>
<ul>
<li>jdk1.6中，将字符串尝试放入串池<ul>
<li>若有，则不放入，返回串池中的地址</li>
<li>若无，则复制对象放入串池，并返回串池中地址</li>
</ul>
</li>
<li>jdk1.7起，将字符串尝试放入串池<ul>
<li>若有，则不放入，返回串池中地址</li>
<li>若无，则将对象的引用地址复制放入，并返回串池中引用地址</li>
</ul>
</li>
</ul>
<p><code>-XX:+PrintStringTableStatistics</code>：打印字符串常量池的统计信息</p>
<p><strong>G1的String去重</strong></p>
<p>堆许多Java应用中，堆存活数据集合里String占25%、重复的String有13.5%、String的平均长度位45.</p>
<p>垃圾收集器工作时，会访问堆上存活的对象，对每个访问的对象都检查是否是候选的要去重的String对象。</p>
<ul>
<li>若是，将该对象的一个引用插入到对象中等待处理。一个去重线程在后台运行处理该队列。处理一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象</li>
<li>使用hashtable来记录所有被String对象使用的不重复的cahr数组，去重时，查询该hashtable，看堆上是否有一样的cahr数组<ul>
<li>若存在，String对象会调整引用那个数组，释放堆原来的数组的引用，然后被回收</li>
<li>若无，char数组会插入hashtable。</li>
</ul>
</li>
</ul>
<p>命令行选项：</p>
<ul>
<li><code>UseStringDepublication</code>：开启String去重，默认不开启</li>
<li><code>PrintStringDeduplicationStatistics</code>：打印详细的去重统计信息</li>
<li><code>StringDeduplicationAgeThreshold</code>：达到该年龄的String对象被认为是去重的候选对象</li>
</ul>
<h2 id="14、垃圾回收概述"><a href="#14、垃圾回收概述" class="headerlink" title="14、垃圾回收概述"></a>14、垃圾回收概述</h2><p>垃圾：指在运行程序中没有任何指针指向的对象，就是需要被回收的垃圾</p>
<p>内存泄漏：垃圾对象无法被清除。</p>
<p>垃圾回收是对于堆和方法区，堆是工作重点。频繁收集Young区，较少收集Old区，基本不动Perm区</p>
<h2 id="15、垃圾回收相关算法"><a href="#15、垃圾回收相关算法" class="headerlink" title="15、垃圾回收相关算法"></a>15、垃圾回收相关算法</h2><ul>
<li><p>垃圾标记阶段：对象存活判断</p>
<ul>
<li>一个对象不再被任何存活对象继续引用时，就宣判死亡</li>
</ul>
</li>
</ul>
<p>判断对象存活方式：</p>
<ul>
<li><p><strong>引用计数算法</strong>：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。有一个对象引用了它，计数器+1，引用失效计数器-1。当计数器值位0，就可以回收</p>
<ul>
<li><p>优点：实现简单、易于辨识、效率高、没有延迟</p>
</li>
<li><p>缺点：需要单独字段存储，增加空间开销、每次赋值都要更新计数器，增加了时间开销、计数器无法处理循环引用的情况，导致Java的垃圾回收器没有使用这类算法</p>
</li>
<li><p>python引用了这个算法，如何解决循环引用</p>
<ul>
<li>手动解除：在合适时机解除引用关系</li>
<li>使用弱引用weakref，weakref是python提供的标准库，旨在解决循环引用</li>
</ul>
<blockquote>
<p>因为Java中没选择该算法，所以Java中不会出现引用计数算法的内存泄漏</p>
</blockquote>
</li>
</ul>
</li>
<li><p>可达性分析算法(或根搜索算法、追踪性垃圾收集)：以根对象集合为起始点，按从上至下方式搜索被根对象集合所连接的目标对象是否可达，不可达意味着该对象死亡，可标记为垃圾对象</p>
<ul>
<li><p>“GC Roots”根集合：一组必须活跃的引用</p>
<ul>
<li>GC Roots包括以下几类元素<ul>
<li>虚拟栈中引用的对象：如各线程被调用的方法中使用的参数、局部变量</li>
<li>本地方法栈内JNI引用的对象</li>
<li>方法区中类静态属性引用的对象：如Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象：字符串常量池里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>虚拟机内部的引用：基本数据类型对于的Class对象，一些常驻的异常对象、系统类加载器</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
<li>除了固定的GC Roots集合外，根据用户所选的垃圾收集器以及当前回收的内存区域不同，还会有其它对象“临时性”加入，共同构成根集合如：分代收集和局部收集</li>
</ul>
</li>
</ul>
</li>
<li><p>如果使用可达性分析算法来判断内存是否可回收，分析工作必须在一个能保障一致性的快照中进行。这点不满足的话准确性就无法保证。这也是导致GC时必须”Stop The World”的一个重要原因</p>
<blockquote>
<p>即使号称几乎不会发生停顿的CMS手机其中，枚举根节点时也是必须要停顿的</p>
</blockquote>
</li>
<li><p>引用链：搜索所走过的路径称为引用链</p>
</li>
<li><p>可用MAT来查看GC Roots</p>
<ul>
<li>MAT：Memory Analyzer简称，强大的Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况。基于eclipse开发的免费性能分析工具。<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">官网下载地址</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>finalization机制</strong></p>
<p>Java语言提供了对象终止机制允许开发人员提供对象被销毁之前的自定义处理逻辑。垃圾回收对象之前，会调用该对象的<code>finalize()</code>方法，该方法允许在子类中被重写，通常用于一些资源释放和清理工作</p>
<p>不要主动调用<code>finalize()</code>方法，应该交由垃圾回收机制调用。理由三点：</p>
<ul>
<li>在<code>finalize()</code>时可能会导致对象复活</li>
<li><code>finalize()</code>的指向时间是没保障的，完全由GC线程决定，可能永远不会执行</li>
<li>一个糟糕的<code>finalize()</code>会严重影响GC性能</li>
</ul>
<p>由于<code>finalize()</code>方法的存在，虚拟机中对象一般处于三种可能状态：</p>
<ul>
<li>可触及的：从根节点可以达到</li>
<li>可复活的：对象的所有引用被释放，但可能在<code>finalize()</code>中复活</li>
<li>不可触及的：<code>finalize()</code>调用后，没有复活。</li>
</ul>
<blockquote>
<p>对象只有在不可触及时才可以被回收</p>
</blockquote>
<p>判断对象是否可回收，至少要经历两次标记；</p>
<ol>
<li>如果该对象到GC Roots没有引用链，进行第一次标记</li>
<li>进行筛选，判断是否有必要执行<code>finalize()</code>方法<ul>
<li>如果没有重写<code>finalize()</code>或意境调用过，则视为“没有必要执行”，判定为不可触及</li>
<li>如果重写了<code>finalize()</code>还未执行过，该对象会被插入F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发<code>finalize()</code>方法执行</li>
<li><code>finalize()</code>是对象逃脱死亡的最后机会，如果对象在<code>finalize()</code>方法与引用链上任一对象建立联系，该对象会被移出”即将回收”集合。若该对象再次出现没有引用，这个情况下<code>finalize()</code>不会被再次调用，对象直接判定为不可触及状态。</li>
</ul>
</li>
</ol>
<p>获取dump文件</p>
<ul>
<li>命令行使用jmap</li>
<li>JVisualVM导出<ul>
<li>在左侧“Application”子窗口中右击相应的应用程序，选择heap dump</li>
<li>在Monitor子标签页中点击Heap Dump按钮。</li>
<li>如果关闭JVisualVM快照就消失了，可以另存为。</li>
</ul>
</li>
</ul>
<blockquote>
<p>开发中因为GC Roots比较多，我们通常只看一个引用变量的一支上，对应的对象。</p>
</blockquote>
<p><code>-XX:+HeapDumpOnOutOfMemoryError</code>：当堆空间出现OOM，生成dump</p>
<p><strong>清除阶段</strong></p>
<p>标记清除(Mark-Sweep)算法：当堆中有效内存空间被耗尽时，停止整个程序，然后进行两项工作，标记和清除</p>
<ul>
<li><p>标记：Collector从引用根节点开始遍历，标记所有被引用对象，一般是可达对象(非清除对象)</p>
</li>
<li><p>清除：Collector堆堆内存所有对象线性遍历，如果发现对象不是可达对象，就清除。</p>
</li>
<li><p>缺点：效率不算高，需要STW，体验差。清除出的内存不连续，产生内存碎片，需维护一个空闲表</p>
</li>
<li><p>优点：易于理解</p>
</li>
</ul>
<blockquote>
<p>清除：并不是真置空，而是将需清除的对象地址保存在空闲地址列表</p>
</blockquote>
<p>复制算法：</p>
<ul>
<li>核心思想：将活着的内存空间分为两块，每次只使用其中一块，回收时将存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中所有对象，交换两内存的角色。</li>
<li>优点：没有标记和清除过程，效率高、保证空间连续性，不会出现”碎片“问题</li>
<li>缺点：需要两倍内存空间、对于G1这种分拆大量region的GC，复制而不是移动，意味着GC要维护region之间对象引用关系，内存和时间开销变大。<ul>
<li>若存活对象很多，复制算法就不会很理想</li>
</ul>
</li>
</ul>
<blockquote>
<p>在新生代，对象通常朝生夕死，复制算法性价比很高</p>
</blockquote>
<p>标记-压缩(或标记-整理、Mark-Compact)算法</p>
<ul>
<li>第一阶段：和标记-清除算法一样</li>
<li>第二阶段：将所有存活对象压缩到内存的一段，按顺序排放</li>
<li>第三阶段：清理边界外所有空间</li>
<li>优点：消除了内存区域分散的缺点、消除了复制算法中内存消耗的缺点</li>
<li>缺点：效率低于复制算法、移动时如果对象被其它对象引用，还要调整引用地址、移动时需要STW</li>
</ul>
<p>对比三种算法</p>
<table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少(会堆积碎片)</td>
<td>少(不会堆积碎片)</td>
<td>通常需要活对象的2倍大小</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>分代收集算法：不同生命周期的对象可以采用不同的收集方式，来提高效率。</p>
<p>目前所有GC都采用分代收集</p>
<p>增量收集算法：每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成。</p>
<ul>
<li>总的来说，增量收集算法的基础仍然是标记-清除和复制算法</li>
<li>缺点：因为线程切换和上下文转换的消耗，使得垃圾回收总成本上升，造成系统吞吐量下降</li>
</ul>
<blockquote>
<p>为解决一次性所有垃圾处理时间过长。</p>
</blockquote>
<p>分区算法：将大的内存区域分割称多个小块，每次合理收集若干个小区间，将整个堆划分成连续的不同的小区间region。每个小区见都独立使用、独立回收。可以控制一次回收多少小区间。</p>
<h2 id="16、垃圾回收相关概念"><a href="#16、垃圾回收相关概念" class="headerlink" title="16、垃圾回收相关概念"></a>16、垃圾回收相关概念</h2><p><strong>System.gc()</strong></p>
<ul>
<li><p><code>System.gc();</code>和<code>Runtime.getRuntime().gc();</code>的调用，会显示触发Full GC。</p>
</li>
<li><p>然而<code>System.gc();</code>调用附带一个免责声明，无法保证堆垃圾收集器的调用</p>
</li>
<li><p>一般情况下无需手动触发，应该自动进行。特殊情况下，如编写性能基准，可以在运行之间调用</p>
</li>
</ul>
<p><code>System.runFinalization();</code>会强制调用失去引用的对象的finalize()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System.gc()回收情况</span></span><br><span class="line"><span class="comment">//不会回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    buffer = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不会回收，因为在局部变量表里，buffer还占据第二个位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会回收，value会替换掉buffer占的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    localvarGC1();</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存溢出(OOM)</strong></p>
<p>javadoc对OutOfMemoryError的解释：没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>由于GC一直在发展，一般情况下，很难出现OOM的情况</p>
<p>Java虚拟机堆内存不够主要原因有二</p>
<ul>
<li>Java虚拟机的堆内存设置不够</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集</li>
</ul>
<p>通常情况下抛出OOM之前，通常垃圾收集器会被触发，但在分配超大对象超出堆最大值时，可能直接抛出OOM</p>
<blockquote>
<p>老版本jdk由于永久代大小有限，永久代出现oom非常多见，随着元数据的映入，方法区内存不再那么窘迫，相应的OOM有所改观</p>
</blockquote>
<p><strong>内存泄漏</strong></p>
<p>也称”存储渗漏”：严格来说，只有对象不会再被程序用到了，但GC又不能回收他们的情况，才叫内存泄漏。</p>
<ul>
<li>实际情况中很多时候，一些不太好的处理会导致对象生命周期变得很长，甚至导致OOM，也可叫做宽泛意义上的“内存泄漏”<ul>
<li>如类的静态变量</li>
</ul>
</li>
<li>Java中举例：<ul>
<li>单例模式：单例的生命周期和应用程序一样长，如果单例程序中，持有外部对象的引用，那么外部对象是不能被回收，导致内存泄漏</li>
<li>一些提供close的资源未关闭</li>
</ul>
</li>
</ul>
<p><strong>STW事件</strong></p>
<p>STW：指的是在GC过程中，会产生应用程序的停顿。停顿产生时整个程序线程都会暂停，没有任何响应，有点像卡死。</p>
<p>并发：不是真正意义上的“同时进行”，只是CPU快速切换，让用户感觉多个应用程序同时进行</p>
<p>并行：当CPU有多核时，一个核执行一个进程，另一个执行另一个。互不抢占CPU资源，可以同时进行</p>
<p><strong>垃圾回收的并发与并行</strong></p>
<p>并行：多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</p>
<p>串行：相较于并行，单线程执行，内存不够，程序暂停，启动JVM垃圾回收器进行回收，回收玩，在启动程序的线程</p>
<p>并发：用户线程和垃圾收集线程同时执行，垃圾回收线程在执行时不停顿用户程序的运行。如CMS、G1</p>
<p>安全点：程序不是在任意地方都能停顿下来开始GC，只有在特定位置才能停顿开始GC，这种位置称为“安全点”</p>
<blockquote>
<p>Safe Point，太少可能导致GC等待时间太长，如果太多可能影响性能。</p>
<p>大部分指令执行时间非常短，通常会根据“是否具有让程序长时间执行的特征”为标准，如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
</blockquote>
<p>如何在GC发生时，让所有线程停顿(两种方式)：</p>
<ul>
<li>抢先式中断(没有虚拟机采用)：先这段所有线程，如果有线程不在安全点，就再恢复线程，让线程跑到安全点</li>
<li>主动式中断：设置中断标志，各个线程运行到Safe Point时主动轮询这个标志，如果中断标志为真，则自行中断挂起</li>
</ul>
<p>安全区域：指的是在一段代码中，对象的引用关系不会发生变化，在该区域中任何位置开始GC都是安全的。</p>
<blockquote>
<p>当线程处于“Sleep”状态或“Blocked：无法响应中断请求，走到安全点，JVM也不大可能去等待线程被唤醒。</p>
</blockquote>
<p>安全区域实际执行：</p>
<ol>
<li>当线程运行到Safe Region时，标识进入Safe Region，如果这段时间发生GC，JVM会忽已标示的线程</li>
<li>当离开Safe Region时，会检查JVM是否完成GC，如果完成则运行，否则等待直到收到可以安全离开Safe Region的信号为止</li>
</ol>
<p><strong>引用</strong></p>
<p>JDK1.2以后，Java堆引用的概念进行了扩充：强、软、弱、虚。引用强度依次减弱。后三个继承自<code>java.lang.ref.Reference</code></p>
<ul>
<li><p>强引用：最传统的”引用“定义，代码中普遍存在的引用赋值。无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用对象</p>
</li>
<li><p>软引用：系统将要发生内存溢出之前，将会把这些对象列入回收范围之内进行二次回收。</p>
<ul>
<li>通常用来实现高速缓存，内存不足时清理掉。如Mybatis就用到</li>
<li>垃圾回收器在某个时刻决定回收软可达对象时，会清理软引用，并可选地将引用存放到一个引用队列</li>
<li>当内存足够时不会回收软引用。不够时才回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软引用代码示例，别忘了销毁强引用</span></span><br><span class="line">SoftReference&lt;&gt; softRef = <span class="keyword">new</span> SoftReference&lt;类型&gt;(具体对象);</span><br><span class="line">类型 对象 = softRef.get()</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用：只要垃圾收集器工作时，物理看见是否足够，都要被回收被弱引用关联的对象</p>
<ul>
<li>由于垃圾回收器线程优先级很低，因此弱引用可能可以存在较长的时间。</li>
<li>弱引用和软引用一样，在构造弱引用时，可以指定一个由于队列，当被弱引用对象被回收时，就会加入指定由于队列，可以通过该队列追踪对象的回收情况。</li>
<li><code>WeakHashMap</code>弱引用的HashMap，只要看到就回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;<span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用：虚引用不会对对象生成时间构成影响，无法通过虚引用来获得一个对象实例。为一个对象设置虚引用关联的目的就是能在该对象被收集器回收时收到一个系统通知。</p>
<ul>
<li>虚引用的<code>get()</code>方法返回总是null</li>
<li>设置虚引用关联的唯一目的就是在于追踪垃圾回收过程。如：在该对象被回收时收到一个系统通知。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建时必须指定引用队列</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用来判断是否被GC</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    PhantomReference&lt;Object&gt; reference = (PhantomReference&lt;Object&gt;)phantomQueue.remove();</span><br><span class="line">    <span class="keyword">if</span> (reference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"已经被GC了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>thread.setDaemon(true);</code>可以设置为守护线程，当程序中没有非守护线程了，守护线程也就自动结束</p>
</blockquote>
</li>
</ul>
<p><del>终结器引用(Final reference)</del>：用以实现对象的<code>finalize()</code>方法，无需手动编码，其内部配合引用队列使用。在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的<code>finalize()</code>方法，第二次GC才能回收被引用对象</p>
<h2 id="17、垃圾回收器"><a href="#17、垃圾回收器" class="headerlink" title="17、垃圾回收器"></a>17、垃圾回收器</h2><p>按线程数分，可分为：</p>
<ul>
<li>串行垃圾回收器：在单CPU或硬件平台不是很好的场合。串行回收器的性能表现可以超过并行、并发回收器。所以串行回收默认被应用在客户端的Client模式下的jvm中</li>
<li>并行垃圾回收器：多个CPU同时执行垃圾回收，提升应用吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用STW机制</li>
</ul>
<p>按照工作模式，可分为</p>
<ul>
<li>并发式垃圾回收器：并发式垃圾回收器与应用程序交替工作，尽可能减少停顿时间</li>
<li>独占式垃圾回收器：一旦运行，就停止应用程序中所以用户线程，直到完全结束</li>
</ul>
<p>按碎片处理方式分，可分为</p>
<ul>
<li>压缩式：回收完成后，对存活对象进行压缩整理，消除回收后的碎片</li>
<li>非压缩式：不进行整理</li>
</ul>
<p>按工作的内存区间分：年轻代<del>、老年代</del></p>
<p><strong>评估GC的性能指标</strong></p>
<ul>
<li>吞吐量：运行用户代码的时间占总运行时间的比例</li>
<li>暂停时间：STW的时间</li>
<li>内存占用：Java堆区所占用内存大小</li>
<li>快速：一个对象从诞生到回收所经历时间</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总时间的比例</li>
<li>收集频率：收集操作发生的频率</li>
</ul>
<blockquote>
<p>前三个为重点，这三个构成“不可能三角”。暂停时间的重要性日益凸显。吞吐量也比较重要</p>
</blockquote>
<p>吞吐量和暂停时间，式一顿矛盾体，无法兼得。</p>
<p>现在标准：在最大吞吐量优先的情况下，降低停顿时间</p>
<p><strong>常见的垃圾回收器</strong></p>
<p>7款经典的垃圾收集器：</p>
<ul>
<li>串行回收器：Serial、Serial Old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel Old</li>
<li>并发回收器：CMS、G1</li>
</ul>
<p>垃圾分代 收集器</p>
<ul>
<li>新生代收集器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代收集器：Serial Old、Parallel Old</li>
<li>整堆收集器：G1</li>
</ul>
<p>图中为垃圾收集器的组合关系：</p>
<ul>
<li>连线为JDK8之前不包括8的组合方案(CMS GC和MSC组为后备方案)</li>
<li>红色虚线：JDK8时将红虚线的两个组合声明废弃，在JDK9彻底移除</li>
<li>绿色虚线：JDK14弃用该组合</li>
<li>青色虚线：JDK14中，删除CMS垃圾回收器</li>
</ul>
<blockquote>
<p>Parallel Scavenge和Parallel Old为JDK8默认的组合，</p>
</blockquote>
<p>Parallel Scavenge和ParNew都是串行回收器，为何CMS不能和Parallel Scavenge搭配。Parallel Scavenge底层框架和CMS不兼容。<img src="/2021/05/07/JVM/image-20201116180009311.png" alt="image-20201116180009311"></p>
<p>查看默认的垃圾收集器：</p>
<ul>
<li><code>-XX:+PrintCommandLineFlags</code>查看命令行相关参数(包含使用的垃圾收集器)</li>
<li>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></li>
</ul>
<p>JDK8版本下</p>
<p><img src="/2021/05/07/JVM/image-20201116224230104.png" alt="image-20201116224230104">)<img src="/2021/05/07/JVM/image-20201116224406637.png" alt="image-20201116224406637"></p>
<p>JDK9版本下 </p>
<p><img src="/2021/05/07/JVM/image-20201116224417202.png" alt="image-20201116224417202"></p>
<p><strong>Serial回收器</strong></p>
<p>串行回收</p>
<ul>
<li><p>作为HotSpot中Client模式下默认新生代垃圾收集器</p>
</li>
<li><p>采用复制算法、串行回收和“STW”机制的方式执行内存回收</p>
</li>
<li><p>在老年代的Serial Old收集器，采用串行回收、STW，标记-压缩算法</p>
<ul>
<li>在Client模式下默认老年代垃圾收集器</li>
</ul>
</li>
<li><p>在Server模式下的用途</p>
<ul>
<li>与新生代的Parallel Scavenge配合使用</li>
<li>作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
</li>
</ul>
<p>优势：简单高效(与其他收集器的单线程比)</p>
<p><code>-XX:+UseSerialGC</code>可以指定年轻代和老年代都使用串行收集器</p>
<p>总结：现在很少使用串行垃圾收集器，只在限定单核才用。</p>
<p><strong>ParNew回收器</strong></p>
<p>并行回收</p>
<ul>
<li>ParNew和Serial除了并行和串行外，几乎没有区别。在新生代同意采用复制算法、STW。</li>
<li>ParNew是许多JVM在Server模式下新生代默认垃圾收集器</li>
</ul>
<p>在单CPU场景下，Serial效率更高。</p>
<p>除了Serial，目前只要ParNew能与CMS配合使用。</p>
<p><code>-XX:+UseParNewGC</code>手动指定ParNew</p>
<p><code>-XX:ParallelGCThreads</code>指定线程数量， 默认和CPU核数一样。</p>
<p><strong>Parallel Scavenge回收器</strong></p>
<p>效率算法，机制方面和ParNew类似。不同的是它的目标是达到一个可控制的吞吐量。也被称为吞吐量优先垃圾收集器。自适应策略是俩回收器之间重要区别。</p>
<p>自适应调节策略：在JVM运行中，根据实际情况，动态调整内存分配情况。以达到最优策略。</p>
<p>高吞吐量可以高效利用CPU时间，尽快完成程序的运算，适合在后台运算，而不需要太多交互的任务。</p>
<p>Parallel收集器在JDK1.6提供了Parallel Old收集器来代替Serial Old收集器。</p>
<p>Parallel Old采用标记-压缩算法，同样基于并行和STW机制。</p>
<p>在程序吞吐量优先场景中，Parallel收集器和Parallel Old的组合，在Server模式下回收性能很不错。</p>
<p>JDK8中，默认此收集器</p>
<p><code>-XX:+UseParallelGC</code>：指定年轻代使用Parallel</p>
<p><code>-XX:+UseParallelOldGC</code>：指定老年代使用并行回收收集器</p>
<blockquote>
<p>上面俩参数，相互激活，开启一个另一个也会打开。JDK8中默认开启</p>
</blockquote>
<p><code>-XX:ParallelGCThreads</code>：设置收集器线程数。一般设置与核数一直</p>
<blockquote>
<p>当CPU核数小于8时，该值等于CPU核数</p>
<p>当大于8时，等于3+[5*CPU_count]/8</p>
</blockquote>
<p><code>-XX:MaxGCPauseMillis</code>设置STW最大停顿时间，单位ms</p>
<p><code>-XX:GCTimeRatio</code>垃圾收集时间占总时间比例，默认为99，即垃圾回收时间不超过百分之1。与前面参数有一定矛盾性。</p>
<p><code>-XX:+UseAdaptiveSizePolicy</code>设置Parallel Scavenge收集器具有自适应策略。默认打开</p>
<ul>
<li>在该模式下，年轻代、eden、survivor的比例、晋升老年代的对象年龄等参数会自动调整。</li>
<li>在手动调优困难的场合，可以使用自适应方式。仅指定虚拟机的最大堆、目标的吞吐量、停顿时间。让虚拟机自动调优。</li>
</ul>
<p><strong>CMS回收器</strong></p>
<p>低延迟</p>
<ul>
<li><p>HotSpot虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
</li>
<li><p>有很多Java应用集中在互联网站或B/S系统的服务端，要求低延迟，CMS符合需求。</p>
</li>
<li><p>CMS采用标记-清除算法，也会STW</p>
</li>
</ul>
<p>CMS无法和Parallel Scavenge配合，所以在JDK1.5中，配合CMS，往往在ParNew或Serial中选择一个</p>
<p>CMS工作过程较为复杂，分为4个主要阶段：</p>
<ul>
<li>初始标记阶段：程序中所有工作线程都STW，仅仅只是标记出GC Roots能总结关联到的对象。速度很快</li>
<li>并发标记阶段：从GC Roots的直接关联对象，遍历整个对象图。耗时长，但不需要停顿用户线程</li>
<li>重新标记阶段：在并发标记阶段，会STW，收集线程和用户线程同时执行，会导致，对象标记变更。因此在修正比并发标记期间，会修正并发标记期间导致的变更的记录。时间比初始标记长，远比并发标记时间短</li>
<li>并发清除阶段：清理删除标记阶段判断的已死亡对象。释放内存空间。由于不移动存活对象，该阶段也能与用户线程并发。</li>
</ul>
<p>因为，在CMS回收时，用户线程仍在运行，需要足够的内存。因此CMS应该是在堆内存使用率达到阈值时，开始回收。</p>
<p>若CMS过程中，预留内存无法满足程序需要，会出现”Concurrent Mode Failure”，这时，虚拟机会启用后备预案，临时启用Serial Old收集器。</p>
<p>优势：低延迟、并发收集</p>
<p>劣势：会产生内存碎片、对CPU资源非常敏感(总吞吐量降低)、无法处理浮动垃圾。</p>
<ul>
<li>浮动垃圾：出现”Concurrent Mode Failure”时，并发标记产生的新垃圾，没被标记，导致新垃圾要到下一次GC才能释放</li>
</ul>
<p><code>-XX:+UseConMarkSweepGC</code>手动指定使用CMS，开启后会自动打开<code>-XX:+UseParNewGC</code>即：ParNew+CMS+Serial Old</p>
<p><code>-XX:CMSlnitiatingOccupanyFraction</code>设置要回收的阈值。若内存增长缓慢，可以设置较大值，若增长快，可以设置较小。</p>
<blockquote>
<p>jdk5以前默认值为68%，6以上为92%</p>
</blockquote>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定执行完Full GC后是否对内存空间进行压缩整理。</p>
<p><code>-XX:CMSFullGCsBeforeCompaction</code>：设置多少次Full GC后压缩整理</p>
<p><code>-XX:ParallelCMSThreads</code>设置CMS线程数。默认是<code>(ParallelGCThreads+3)/4</code>。</p>
<ul>
<li>ParallelGCThreads是年轻代并行收集器的线程数。</li>
</ul>
<p>在JKD9中CMS被标记为Deprecate。JDK14删除了CMS。在JDK14<code>-XX:+UseConMarkSweepGC</code>，不会报错，只会报warning，然后以默认GC方式启动JVM</p>
<p><strong>G1回收器(垃圾优先)</strong></p>
<p>区域分代化</p>
<p>G1是一个并行回收器，将堆内存分割为很多不相关的区域。使用不同的Region表示Eden、幸存者区、老年代等。</p>
<p>有计划的避免了在整个Java堆中进行全区域垃圾收集。G1跟踪每个Region里，垃圾堆积的价值大小，在后台维护一个优先列表。每次根据允许收集时间，优先回收价值最大的Region。</p>
<p>G1面向服务器端，主要针对多核CPU和大容量内存的机器。</p>
<p>JDK7正式启用，JDK9以后的默认垃圾回收器。取代了CMS以及Parallel + Parallel Old组合。称为”全功能的垃圾收集器。”</p>
<p>G1使用了全新的分区算法，特点：</p>
<ul>
<li>并行与并发<ul>
<li>并行性：G1回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li>分代收集<ul>
<li>G1仍然属于分代型垃圾回收器，会区分年轻代老年代，依然有Eden区和Survivor区，但它不要求整个Eden区、年轻代或老年代是连续的，也不再固定大小和数量</li>
<li>将堆空间分为若干个区域(Region)，包含了逻辑上的年轻代和老年代</li>
<li>它同时兼顾年轻代和老年代。</li>
</ul>
</li>
<li>空间整合<ul>
<li>G1将region之间用复制算法，整体上可看作标记-压缩算法。可以避免内存碎片，有利于长时间运行，在大内存优势更加明显。</li>
</ul>
</li>
<li>可预测的停顿时间模型(软实时(小误差))：能让使用者明确指定在长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<ul>
<li>由于分区的原因，G1可以只选取部分区域。</li>
<li>G1跟踪各个Region内垃圾堆积的价值大小(回收所得的空间大小以及回收所需时间的经验值)。后台维护一个优先列表，每次根据允许的时间，优先回收价值最大的Region。保证了在有限时间尽可能高的收集效率</li>
</ul>
</li>
</ul>
<p>缺点：相较于CMS，在程序运行过程中，G1无论是内存占用还是程序运行时的额外执行负载都比CMS高。</p>
<blockquote>
<p>G1在大内存上优势比较大，6~8G式，俩差不多</p>
</blockquote>
<p><strong>G1参数设置</strong></p>
<p><code>-XX:+UseG1GC</code>：手动指定使用G1</p>
<p><code>-XX:G1HeapRegionSize</code>：设置Region的大小。2的幂。范围为1到32MB。通常分为2048个区域，默认式堆内存的1/2000。</p>
<p><code>-XX:MaxGCPauseMillis</code>：设置预期的最大GC停顿时间，默认200ms。JVM会尽量实现</p>
<p><code>-XX:ParallelGCThread</code>：设置STW工作线程数，最多为8</p>
<p><code>-XX:ConcGCThreads</code>：设置并发标记的线程数，将n设置为并行垃圾回收线程数(上个参数)的1/4左右。</p>
<p><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发GC周期的Java堆占用率阈值。超过此值就触发GC，默认45。</p>
<p><strong>常见操作步骤</strong></p>
<ol>
<li>开启G1</li>
<li>设置堆最大内存</li>
<li>设置最大停顿时间</li>
</ol>
<p>剩下的都能交给JVM调优</p>
<p><strong>G1使用场景</strong></p>
<p>用来替换掉JDK1.5中的CMS，下面情况中，G1表现可能比CMS好</p>
<ul>
<li>超过50%的Java堆被活动数据占用</li>
<li>对象分配频率或年代提升频率变化大</li>
<li>GC停顿时间过长(长于0.5至1秒)</li>
</ul>
<p><strong>Region</strong></p>
<p>一个region，只有一个角色。但是角色是可变的。有Eden、Survivor或OldTenured区域。</p>
<p>G1还增加了，新的内存区域，Humongous区域用于存储大对象，如果超过1.5region，就放到这</p>
<p>为了解决短期存在大对象，放入老年代影响性能的问题，划分了Humongous区来存放大对象，大多情况下，会把他当老年代的一部分来看待。</p>
<p><strong>G1回收过程主要包括三个环节</strong></p>
<ul>
<li>年轻代GC</li>
<li>老年代并发标记过程</li>
<li>混合回收</li>
<li>(若需要，单线程、独占式、高强度的Full GC。是一种失败保护机制)</li>
</ul>
<p><img src="/2021/05/07/JVM/image-20201124220320117.png" alt="image-20201124220320117"></p>
<p>过程概述：当年轻代Eden区用尽时开始年轻代回收，G1的年轻代收集阶段是一个并行的独占式收集器。回收期间，暂停所有应用程序线程，启动多线程执行年轻代回收，然后将年轻代区间移动存活对象到Survivor区间或老年区间。当堆内存使用达到阈值后，开始老年代并发标记。标记完成开始混合回收，将老年区间移动存活对象到空闲区间。老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一部分老年代的Region。老年代Region和年轻代一起被回收的。</p>
<p><strong>记忆集与写屏障</strong></p>
<p>问题：一个对象被不同区域应用，回收新生代也不得不扫描老年代。这样会降低GC效率。</p>
<p>解决：每个记忆集对应一个region，记录引用该区域的region的引用。当垃圾收集时，在GC根节点的枚举范围内加入记忆集，这样避免全局扫描和遗漏。</p>
<p>写屏障：每次对引用类型写操作时都会产生写屏障。会中断操作，检查是否引用在其它region。如果不同，就卡表，将相关引用信息记录到记忆集</p>
<p><strong>回收过程详细(三大必过程+一个可选过程)</strong></p>
<ul>
<li>年轻代GC：在JVM启动时，G1会准备好eden，当Eden区空间耗尽，G1启动年轻代垃圾回收过程。只回收Eden区和Survivor区<ul>
<li>TGC会STW，创建回收集。回收集指的是需要被回收的内存分段的集合。YGC的回收集包含Eden和Survivor</li>
<li>具体回收过程<ol>
<li>扫描根：GC Roots，记忆集</li>
<li>更新RSet：处理dirty card queue中的card，更新RSet。此阶段完成后RSet可以准确的反映老年代对所在的内存分段中对象的引用。<ul>
<li>dirty card queue：在引用赋值语句之前和之后执行特殊操作，在该队列入队一个对象引用信息card。以更新Rset。</li>
<li>这样性能更好</li>
</ul>
</li>
<li>处理RSet：识别存活对象</li>
<li>复制对象：Eden区内存活对象复制到Survivor区，Survivor年龄+1，若达到阈值，或空间不够，晋升入老年代</li>
<li>处理引用：处理Soft，weak，phantom，Final，JNI Weak等引用，最终Eden为空，GC终止活动。</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Survivor区满，是不会触发回收的</p>
</blockquote>
<ul>
<li><p>并发标记过程</p>
<ol>
<li>初始标记阶段：STW，只是标示从根节点直接可达的对象</li>
<li>根区域扫描：扫描Survivor区直接可达的老年代区域对象，标记被引用的。这一过程必须在YGC之前完成。</li>
<li>并发标记：应用程序和标记并发执行。此过程可能被YGC中断。若发现区域对象中所有对象都是垃圾，那此区域立即回收。并发标记过程中，会计算每个region的对象活性(存活比例)</li>
<li>再次标记：修正上次的标记结果，STW。G1采用了比CMS更快的初始快照算法：snapshot-at-the-beginning(SATB)</li>
<li>独占清理：计算各个区域的存活对象和GC回收比例。进行排序。为下阶段做铺垫。STW</li>
<li>并发清理阶段：识别，并清空完全空闲区域</li>
</ol>
</li>
<li><p>混合回收：当越来越多对象晋升到老年代，为会触发混合的垃圾收集器，Mixed GC。会回收整个Young Region和一部分Old Region。复制算法</p>
<ul>
<li>并发标记结束后，老年代中全为垃圾的内存分段被回收了，部分为垃圾的内存被计算出来。默认情况下，老年代的内存分段会分8次(可以通过<code>-XX:G1MixedGCCountTarget</code>设置)</li>
<li>混合回收的回收集包括1/8的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收完全一样，只是回收集多了老年代的内存分段。</li>
<li>老年代中，G1会优先回收垃圾多的分段。有一个阈值会决定内存分段是否回收<code>-XX:G1MixedGCLiveThresholdPercent</code>默认为65%。</li>
<li>混合回收并不一定要进行8此，阈值<code>-XX:G1HeapWastePercent</code>默认10%，意为允许堆内存有10%的空间被浪费。表面如果发现可以回收的垃圾占堆内存比例低于10%，就不再混合回收。</li>
</ul>
</li>
<li><p>可选过程：Full GC</p>
<ul>
<li>G1会尽量避免Full GC。但如果上述不能正常工作，G1会停止应用程序的执行，使用单线程的内存回收算法，进行垃圾回收。</li>
<li>导致Full GC的原因：Evacuation(回收阶段)时候没有足够的to-space来存放晋升对象、并发处理过程完成之前空间耗尽。</li>
</ul>
</li>
</ul>
<p><strong>G1优化</strong></p>
<ul>
<li>年轻代大小设置<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等选项显示设置年轻代大小。该选项是独占式，可能会覆盖暂停时间目标，使得无法达到。让JVM动态调整</li>
</ul>
</li>
<li>暂停时间目标不要过于严苛<ul>
<li>太严苛的暂停时间会使得，影响吞吐量。</li>
</ul>
</li>
</ul>
<p><strong>垃圾回收器总结</strong></p>
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU的client模式</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU的Server模式与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>后台运算，少交互的环境</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行运行</td>
<td>老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>单CPU的client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行运行</td>
<td>老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>后台运算，少交互的环境</td>
</tr>
<tr>
<td>CMS</td>
<td>并发运行</td>
<td>老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>互联网或B/S业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发、并行</td>
<td>老年代、新生代</td>
<td>标记-压缩、复制算法</td>
<td>响应速度优先</td>
<td>面向服务器端应用</td>
</tr>
</tbody></table>
<p><code>-XX:+PrintCommandLineFlags</code>：查看程序使用的默认JVM参数</p>
<p><code>-XX:+UseSerialGC</code>:表明新生代使用Serial GC ，同时老年代使用Serial Old GC</p>
<p><code>-XX:+UseParNewGC</code>：标明新生代使用ParNew GC</p>
<p><code>-XX:+UseParallelGC</code>:表明新生代使用Parallel GC</p>
<p><code>-XX:+UseParallelOldGC</code>: 表明老年代使用 Parallel Old GC</p>
<p>说明：二者可以相互激活</p>
<p><code>-XX:+UseConcMarkSweepGC</code>：表明老年代使用CMS GC。同时，年轻代会触发对ParNew 的使用</p>
<p><strong>常用GC日志参数</strong></p>
<p><code>-XX:+PrintGC</code>：输出GC日志</p>
<p><code>-XX:+PrintGCDetails</code>：输出GC详细日志</p>
<p><code>-XX:+PrintGCTimeStamps</code>：输出GC的时间戳</p>
<p><code>-XX:+PrintGCDateStamps</code>：输出GC时间戳，以日期的形式</p>
<p><code>-XX:+PrintHeapAtGC</code>：在进行GC的前后打印出堆信息</p>
<p><code>-Xloggc:../logs/gc/log</code>：日志输出路径</p>
<blockquote>
<ul>
<li><code>[GC</code>和<code>[Full GC</code>说明此次停顿类型，若有Full则说明发生了STW</li>
<li>Serial在新生代名字是Default New Generation，显示为<code>DefNew</code></li>
<li>ParNew在新生代为<code>[ParNew</code></li>
<li>Parallel Scavenge在新生代为<code>[PSYoungGen</code></li>
<li>G1显示为garbage-first heap</li>
<li>Allocation Failure：失败原因，在年轻代没有足够空间</li>
<li>[PSYoungGen: 5986k-&gt;696K(8704K) 5986K-&gt;704K(9216K)：中括号内表示回收前年轻代大小、回收后大小。外表示回收前年轻代和老年代大小，回收后大小</li>
<li>user代表用户态回收好事、sys内核态回收耗时、rea实际耗时。由于多核时间总和可能会超过real</li>
</ul>
</blockquote>
<p><img src="/2021/05/07/JVM/image-20201125164157554.png" alt="image-20201125164157554"></p>
<p>jdk7中，空间不足，会先将eden区的晋升到老年代，然后再放入eden</p>
<p>jdk8中，空间不足，直接放入老年代</p>
<p><strong>垃圾回收器的新发展</strong></p>
<p>串行的Full GC、Card Table扫描的低效等都被大幅改进</p>
<p>JDK10以后Full GC是并行运行的，很多场景下表现略优于Parallel GC</p>
<p>随着云计算兴起，在Serverless等新应用场景下，有了新舞台。</p>
<p>CMS在jdk9标记为废弃，14中移除</p>
<p>A No-Op Garbage Collector(无操作回收器)<a href="http://openjdk.java.net/jeps/318" target="_blank" rel="noopener">官网</a>：只做内存分配，不做回收。JDK11新特性</p>
<p>Shenandoah GC：低停顿时间JDK12，OpenJDK9开始是默认回收器。RedHat出品。在OracleJDK不支持。宣称停顿时间与堆大小无关。</p>
<blockquote>
<p>从结果看，吞吐量有明显下降</p>
</blockquote>
<p><strong>ZGC</strong></p>
<p>革命性的ZGC：ZGC是一款基于Region内存布局的，(暂时)不设分代，使用读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法，以低延迟为首要目标的垃圾收集器。</p>
<p>工作过程4个阶段：并发标记、并发预备重分配、并发重分配、并发重映射等</p>
<p>除了初始标记是STW，这部分时间非常少，其余都并发。</p>
<p>JDK14前，ZGC仅Linux支持，现在mac或windows也能使用ZGC<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></p>
<p>吞吐量差不多，延迟极低。</p>
<p>ALiGC：基于G1，面向大堆</p>
<h2 id="18、Class文件结构"><a href="#18、Class文件结构" class="headerlink" title="18、Class文件结构"></a>18、Class文件结构</h2><p> <strong>编译器</strong></p>
<ul>
<li>前端编译器：将代码编译为字节码文件。javac是默认前端编译器。前端编译器不直接设计编译优化等方面的技术。<ul>
<li>Eclipse使用ECJ编译器，一种增量式编译器。把为编译部分进行编译，效率较高<ul>
<li>Tomcat也用的是ECJ</li>
</ul>
</li>
<li>Idea默认使用javac。也可设置位AspectJ编译器ajc</li>
</ul>
</li>
<li>后端编译器：</li>
</ul>
<p>jit即使编译器，在运行过程中，将热点代码翻译为机器指令</p>
<p>AOT在运行之前，翻译为机器指令。但这样会打破动态性</p>
<blockquote>
<p>Integer xx= 1这里调用的是Integer.valueOf(1)，如果在-128到12之间，返回的是提前生成好的对象 </p>
</blockquote>
<p><strong>字节码</strong></p>
<p>字节码：二进制的类文件，内容是JVM指令。</p>
<p>字节码指令：JVM的指令由一个字节长度的、代表某种特定操作的操作码以及后跟随的零或多个所需参数的操作数构成。</p>
<blockquote>
<p>可以通过javap或idea的插件查看class文件</p>
</blockquote>
<p><strong>class的本质和内部结构</strong></p>
<p>class文件的本质是以8位字节为基础单位的二进制流</p>
<p>class文件格式类似C语言结构体。结构中只有两种数据类型，无符号数和表。</p>
<ul>
<li>无符号数属于基本数据类型，u1、u2、u4、u8来代表1、2、4、8哥字节的无符号数。可用来描述数字、索引引用、数量值或按utf-8编码</li>
<li>表是多个无符号数或其他表作为数据项。所有表习惯性以<code>_info</code>结尾。因为表没有固定长度，所以通常会在其前加个数说明</li>
</ul>
<p>class总体内部结构：</p>
<ul>
<li><p>魔数：标识该文件为class文件</p>
<ul>
<li>每个class文件开头4字节无符号数字</li>
<li>只要是合法的都以<code>ca fe ba be</code>开头</li>
</ul>
</li>
<li><p>class文件版本：紧接着魔数的4字节为版本号。5、6字节为副版本号minor_version，7、8字节为主版本号major_version。</p>
<ul>
<li>主版本从45开始，JDK1.1开始每个JDK大版本发布，主版本+1。副版本除了主版本为45以外为3其它都为0。</li>
<li>向下兼容</li>
</ul>
</li>
<li><p>常量池：class文件内容最丰富的区域</p>
<ul>
<li><p>紧跟版本号的是常量池的数量，以及若干个常量池表项。</p>
</li>
<li><p>常量池容量计数器：计数从1开始。第0项空出来，为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义(相当于占用不表示什么)，这种情况用索引值0表示</p>
<ul>
<li>如：<code>0x0016</code>就是22，实际为21个常量。索引1~21。</li>
</ul>
</li>
<li><p>常量池表项中，存放编译期生成的各种字面量和符号引用。类加载后放入运行时常量池中。</p>
</li>
<li><p>常量池：存放字面量和符号引用。</p>
<ul>
<li><p>字面量：文本字符串、声明为final的常量值</p>
</li>
<li><p>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p>
<ul>
<li>全限定名：将全限定类名的分隔<code>.</code>改成<code>/</code>。最后加个<code>;</code></li>
</ul>
</li>
<li><p>描述符描述字段的数据类型、方法的参数列表和返回值</p>
<ul>
<li></li>
</ul>
</li>
<li><p>包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其它常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，确定该项的格式，称为tag byte。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>访问标志：用来区别接口类和访问权限级别</p>
</li>
<li><p>类索引、父类索引、接口索引集合</p>
</li>
<li><p>字段表集合</p>
</li>
<li><p>方法表集合</p>
</li>
<li><p>属性表集合</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>魔数，识别class文件格式</td>
<td>4字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attribute</td>
<td>属性表</td>
<td>n字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</div><div class="tags"><a href="/tags/Java/"><i class="fa fa-tag"></i>Java</a><a href="/tags/JVM/"><i class="fa fa-tag"></i>JVM</a></div><div class="post-nav"><a class="pre" href="/2021/05/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Git笔记</a><a class="next" href="/2021/04/27/%E7%88%AC%E8%99%AB/">爬虫</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Scala/" style="font-size: 15px;">Scala</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/nosql/" style="font-size: 15px;">nosql</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 15px;">后端</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/scala/" style="font-size: 15px;">scala</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/springsecurity/" style="font-size: 15px;">springsecurity</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/wordpress/" style="font-size: 15px;">wordpress</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/marjora/" style="font-size: 15px;">marjora</a> <a href="/tags/virtualbox/" style="font-size: 15px;">virtualbox</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 15px;">服务器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 15px;">博客</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机基础</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E6%B5%81%E7%A8%8B/" style="font-size: 15px;">流程</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 15px;">开发</a> <a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/06/Redis/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Git笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/07/JVM/">JVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/27/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/Git%E7%AC%94%E8%AE%B0/">Git笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/manjaro%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">manjaro配置开发环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/docker%E7%AC%94%E8%AE%B0/">docker笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">dian的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>