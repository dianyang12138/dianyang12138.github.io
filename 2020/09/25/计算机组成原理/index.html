<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="后端Java工程师"><title>计算机组成原理 | dian的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">计算机组成原理</h1><a id="logo" href="/.">dian的博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">计算机组成原理</h1><div class="post-meta">2020-09-25</div><div class="post-content"><a id="more"></a>

<p>计算机组成原理—硬件</p>
<p>前置知识：数电</p>
<p>该课程是计算机课程中唯一一门讲授计算机硬件实现的课程。</p>
<p>什么是组成？组成是指计算机硬件系统的逻辑实现。</p>
<blockquote>
<p>非物理实现</p>
</blockquote>
<p>什么是逻辑实现：使用数电的知识来实现计算机的硬件系统</p>
<p><strong>讲授内容</strong></p>
<ul>
<li>基本部件的结构和组织方式</li>
<li>基本运算的操作原理</li>
<li>基本部件和单元的设计思想</li>
</ul>
<p><strong>特色</strong></p>
<ul>
<li><p>计算机组成的一般原理，不以具体机型为依托</p>
</li>
<li><p>采用自顶向下的方式、层层细化</p>
</li>
</ul>
<p>教材：唐朔飞 计算机组成原理(第2版)</p>
<blockquote>
<p>因为不以具体机型为依托，学完后会觉得有点空，推荐两本教材可以实现课程的落地：《计算机组成与设计：硬件·软件接口》、《数字设计和计算机体系结构》</p>
<p>可以通过以上教材简单实现一个处理器(2)</p>
</blockquote>
<h2 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h2><h3 id="1-1计算机系统简介"><a href="#1-1计算机系统简介" class="headerlink" title="1.1计算机系统简介"></a>1.1计算机系统简介</h3><p>现代计算机的多态性</p>
<p>将感应器嵌入、装备到各种物体中，形成“物联网”，实现人类社会与物理系统的整合</p>
<p><strong>计算机系统</strong></p>
<ul>
<li>硬件：计算机的实体</li>
<li>软件：由具有各类特殊功能的信息（程序）组成<ul>
<li>系统软件：用来管理整个计算机系统<ul>
<li>语言处理程序</li>
<li>操作系统</li>
<li>服务性程序</li>
<li>数据库管理系统</li>
<li>网络软件</li>
</ul>
</li>
<li>应用软件：按任务需要编制成的各种程序</li>
</ul>
</li>
</ul>
<p><strong>计算机系统的层次结构</strong></p>
<p>系统复杂性管理的方法-1：抽象</p>
<p>软件角度划分</p>
<ul>
<li>高级语言 — 虚拟机器M<del>3</del> — 用编译程序翻译成汇编语言程序</li>
<li>汇编语言 — 虚拟机器M<del>2</del> — 用汇编程序翻译成机器语言程序</li>
<li>操作系统 — 虚拟机器 — 用机器语言解释操作系统</li>
</ul>
<p>以上是软件实现，以下是软件实现</p>
<ul>
<li>机器语言 — 实际机器M<del>1</del> — 用微指令解释机器指令</li>
<li>微指令系统 — 微程序机器M<del>0</del> — 由硬件直接执行微指令</li>
</ul>
<p>计算机组成与计算机体系结构从研究内容上来说有什么区别呢？</p>
<p>计算机系统结构定义计算机系统的软硬件交界面，定义了哪些功能由软件来实现，哪些功能由硬件来实现，提供了上层软件进行编写的时候和硬件进行交互的接口</p>
<p>计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址己数、I/O机理）</p>
<blockquote>
<p>这里的程序员指的是机器语言程序员</p>
</blockquote>
<p>计算机组成：实现计算机体系结构所体现的属性（具体指令的实现）</p>
<p>如：计算机体系结构规定有无乘法指令。计算机组成如何实现乘法指令。</p>
<h3 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h3><p>冯·诺依曼计算机的特点：</p>
<ul>
<li>计算机由五大组成部分<ul>
<li>运算器</li>
<li>控制器</li>
<li>存储器</li>
<li>输入设备</li>
<li>输出设备</li>
</ul>
</li>
<li>指令和数据以同等地位存于存储器，可按地址寻访</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码（什么操作）和地址码（操作数）组成</li>
<li>存储程序</li>
<li>以运算器为中心<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.2-1.png" alt></li>
</ul>
<blockquote>
<p>问题：以运算器为核心，会比较繁忙，也容易成为性能瓶颈</p>
</blockquote>
<p>改进：以存储器为中心的计算器</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/images%5C1.2-2.png" alt></p>
<p><strong>现代计算机硬件结构</strong></p>
<ul>
<li><p>主机</p>
<ul>
<li><p>CPU</p>
<ul>
<li>ALU—运算器</li>
<li>CU—控制器</li>
</ul>
</li>
<li><p>主存、辅存—存储器</p>
</li>
</ul>
</li>
<li><p>I/O设备</p>
<ul>
<li>输入设备</li>
<li>输出设备</li>
</ul>
</li>
</ul>
<p>系统复杂性管理的方法-2：</p>
<ul>
<li>层次化：将被设计的系统划分为多个模块或子模块</li>
<li>模块化：有明确定义的功能和接口</li>
<li>规则性：模块更容易被重用</li>
</ul>
<p>是不是所有问题都可以用计算的方法来解决。可计算理论</p>
<p><strong>计算机的工作准备</strong></p>
<ol>
<li>上机前的装备<ul>
<li>建立数学模型</li>
<li>确定计算方法</li>
</ul>
</li>
<li>编制解题程序<ul>
<li>程序—运算的全部步骤</li>
<li>指令—每一个步骤</li>
</ul>
</li>
</ol>
<p>编程举例：同一算式，两种算法</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.2-3.png" alt></p>
<p>指令格式：操作码+地址码</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.2-4.png" alt></p>
<h6 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h6><ul>
<li>核心结构：存储体。要能保存指令和数据，并且能访问<ul>
<li>存储体由若干个存储单元构成，存储单元由多个存储元件构成</li>
<li>存储单元存放了一串二进制代码（指令和数据都是存放在存储单元中）<ul>
<li>存储字：存储单元中二进制代码的组合</li>
<li>存储字长：存储单元中二进制代码的位数</li>
<li>每个存储单元都可以赋予一个地址，每个存储单元存放一个存储字</li>
</ul>
</li>
</ul>
</li>
<li>MAR：存储器地址寄存器<ul>
<li>反映存储单元的个数</li>
<li>保存地址</li>
</ul>
</li>
<li>MDR：存储器数据寄存器<ul>
<li>反映存储字长</li>
</ul>
</li>
</ul>
<p>如：MAR=4位、MDR=8位。存储单元个数16个，存储字长8</p>
<h6 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h6><p>运算器的基本组成及操作过程</p>
<p>ALU通常是组合电路</p>
<p>组合电路特点：如果输入撤销，输出结果也会相应撤销</p>
<p>为了使ALU能够完成运算功能，能够对结果进行保存，必须在ALU的输入端加上寄存器，寄存器保存参与运算的数据，需要两个寄存器作为输入数据的保存设备，一个是ACC一个是X（数据寄存器）acc也用于保存结果，当运算结果长度过长，我们将增加出来的长度保存至MQ</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.2-5.png" alt></p>
<table>
<thead>
<tr>
<th></th>
<th>ACC</th>
<th>MQ(又叫乘商寄存器)</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>加法</td>
<td>被加数、和</td>
<td></td>
<td>加数</td>
</tr>
<tr>
<td>减法</td>
<td>被减数、差</td>
<td></td>
<td>减数</td>
</tr>
<tr>
<td>乘法</td>
<td>乘积高位</td>
<td>乘数、乘积地位</td>
<td>被乘数</td>
</tr>
<tr>
<td>除法</td>
<td>被除数、余数</td>
<td>商</td>
<td>除数</td>
</tr>
</tbody></table>
<p>乘法：利用加法和移位的方法。</p>
<p>除法：利用减法和移位的方法。</p>
<blockquote>
<p>类似十进制的乘除法</p>
</blockquote>
<p>加法操作：</p>
<ol>
<li>初态 ACC 被加数</li>
<li>指令： 加 M</li>
<li>[M]-&gt;X   从内存中读取到X</li>
<li>[ACC]+[X]-&gt;ACC</li>
</ol>
<p>减法类似加法</p>
<p>乘法操作：</p>
<ol>
<li>初态 ACC 被乘数</li>
<li>指令： 乘 M</li>
<li>[M]-&gt;X   </li>
<li>[ACC]-&gt;x</li>
<li>0-&gt;ACC</li>
<li>[X]*[MQ]-&gt;ACC//MQ</li>
</ol>
<p>除法操作：</p>
<ol>
<li>初态 ACC 被除数</li>
<li>指令 除 M</li>
<li>[M] -&gt;X</li>
<li>[ACC] ÷ [X] -&gt;MQ</li>
<li>余数在ACC中</li>
</ol>
<p>这些操作的先后顺序是由控制器来决定的</p>
<h6 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h6><p>功能：</p>
<ul>
<li>解释指令：不是执行<ul>
<li>从取址到分析，到取操作数，到执行指令，到保存结果都是由控制器来完成</li>
</ul>
</li>
<li>保证指令的按序执行</li>
</ul>
<p><strong>控制器的基本组成</strong></p>
<p>完成一条指令</p>
<ol>
<li>取指令<ul>
<li>程序计数器（PC）：存放当前欲执行指令的地址，具有计数功能（PC）+1—&gt;PC</li>
</ul>
</li>
<li>分析指令<ul>
<li>指令寄存器（IR）：存放当前欲执行的指令</li>
</ul>
</li>
<li>执行指令<ul>
<li>CU</li>
</ul>
</li>
</ol>
<blockquote>
<p>从PC中取址指令 放入IR 然后PC自动指向下一条指令</p>
</blockquote>
<p>完成一条取数指令的具体过程</p>
<ol>
<li><p>取指令</p>
<ul>
<li>PC将指令的地址送到MAR</li>
<li>MAR送到存储体</li>
<li>在控制器的控制下，存储体把指定存储单元中保存的那条取数指令取出，送到MDR中</li>
<li>取出的指令，送至IR</li>
</ul>
</li>
<li><p>分析指令</p>
<ul>
<li>IR将指令的操作码部分送至CU</li>
</ul>
</li>
<li><p>执行指令</p>
<ul>
<li>IR将地址取出，送到MAR，MAR送到存储体<ul>
<li>IR中不仅存放了指令地址，也存放了操作数的地址</li>
</ul>
</li>
<li>在控制器的控制下，将取数指令要取得数取出</li>
<li>存入MDR</li>
<li>然后送入ACC</li>
</ul>
</li>
</ol>
<p>存数指令</p>
<ol>
<li><p>取指令：与取数指令的取指令过程一致</p>
</li>
<li><p>分析指令</p>
<ul>
<li>将IR中保存的指令操作码部分送给CU，由CU进行分析</li>
</ul>
</li>
<li><p>执行指令</p>
</li>
</ol>
<ul>
<li>将IR中地址码部分送到MAR，由MAR送到存储体。告知有一个数据将要存入哪</li>
<li>将ACC的数据送到MDR</li>
</ul>
<p><strong>程序运行过程</strong></p>
<ul>
<li>将程序通过输入设备送至计算机</li>
<li>程序首地址—PC</li>
<li>启动程序运行</li>
<li>取指令 PC—&gt;MAR—&gt;MDR—&gt;IR，(PC)+1—&gt;PC</li>
<li>分析指令 OP(IR)—&gt;CU</li>
<li>执行指令 Ad(IR)—&gt;MAR—&gt;M—&gt;MDR—&gt;ACC</li>
</ul>
<p><strong>疑问</strong>：存储体，MDR MAR和M的区别</p>
<h3 id="1-3计算机硬件的主要技术指标"><a href="#1-3计算机硬件的主要技术指标" class="headerlink" title="1.3计算机硬件的主要技术指标"></a>1.3计算机硬件的主要技术指标</h3><p><strong>主要指标</strong></p>
<ol>
<li>机器字长：CPU一次能处理数据的位数，与CPU中的<strong>寄存器位数</strong>有关。<ul>
<li>如：我的CPU可以一次对两个8位数字作运算得到一个8位数字。得机器字长8位，而不是24位。</li>
</ul>
</li>
<li>运算速度<ul>
<li>主频</li>
<li>核数、每个核支持的线程数</li>
<li>吉普森法 <img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.3-1.png" alt><ul>
<li>指令的静态使用频率：在程序清单上直接计算某一条指令出现频率</li>
<li>指令的动态使用频率计算在程序的执行过程中每一条指令出现的频率</li>
</ul>
</li>
<li>CPI：执行一条指令所需要的时钟周期数。C：时钟周期、P：每一个、I：指令。<ul>
<li>CPI越少越好。</li>
<li>IPC：一个时钟周期能完成多少指令</li>
</ul>
</li>
<li>MIPS：每秒执行百万条指令</li>
<li>FLOPS：每秒浮点运算次数<ul>
<li>在F前加M表示百万</li>
<li>是从机器做多少操作角度衡量（更合理）</li>
</ul>
</li>
</ul>
</li>
<li>存储容量：存放二进制信息的总位数<ul>
<li>主存容量：<ul>
<li>存储单元个数×存储字长 <ul>
<li>如MAR：10位 MDR：8位 1K × 8位 （2^10^约等于1k ）</li>
</ul>
</li>
<li>字节数<ul>
<li>如2^13^b=1KB、1B=2^3^b、2^21^=256KB</li>
</ul>
</li>
</ul>
</li>
<li>辅存容量：字节数 如80GB</li>
</ul>
</li>
</ol>
<h2 id="二、计算机的发展和应用"><a href="#二、计算机的发展和应用" class="headerlink" title="二、计算机的发展和应用"></a>二、计算机的发展和应用</h2><p>非主要学习内容</p>
<h3 id="2-1计算机的发展史"><a href="#2-1计算机的发展史" class="headerlink" title="2.1计算机的发展史"></a>2.1计算机的发展史</h3><p>现代计算机产生的驱动力：需求</p>
<p>技术发展</p>
<ul>
<li>电子技术的发展</li>
<li>计算机体系结构的发展</li>
</ul>
<table>
<thead>
<tr>
<th>代</th>
<th>时间</th>
<th>硬件技术</th>
<th>速度次/秒</th>
</tr>
</thead>
<tbody><tr>
<td>一</td>
<td>1946—1957</td>
<td>电子管</td>
<td>40 000</td>
</tr>
<tr>
<td>二</td>
<td>1958—1964</td>
<td>晶体管</td>
<td>200 000</td>
</tr>
<tr>
<td>三</td>
<td>1965—1971</td>
<td>中小规模集成电路</td>
<td>1 000 000</td>
</tr>
<tr>
<td>四</td>
<td>1972—1977</td>
<td>大规模集成电路</td>
<td>10 000 000</td>
</tr>
<tr>
<td>五</td>
<td>1978—现在</td>
<td>超大规模集成电路</td>
<td>100 000 000</td>
</tr>
</tbody></table>
<p>IBM 360计算机</p>
<p>Moore定律：在价格不变的情况下，微芯片上集成的晶体管数目每三年翻两番</p>
<h3 id="2-2计算机的应用"><a href="#2-2计算机的应用" class="headerlink" title="2.2计算机的应用"></a>2.2计算机的应用</h3><p>科学计算和数据处理</p>
<p>工业控制和实时控制</p>
<p>网络技术</p>
<ul>
<li>电子商务</li>
<li>网络教育</li>
<li>敏捷制造</li>
</ul>
<p>虚拟现实</p>
<p>办公自动化和管理信息系统</p>
<p>CAD/CAM/CIMS</p>
<p>多媒体技术</p>
<p>人工智能</p>
<h3 id="2-3计算机的展望"><a href="#2-3计算机的展望" class="headerlink" title="2.3计算机的展望"></a>2.3计算机的展望</h3><p>芯片集成度的提高受限制</p>
<ul>
<li>芯片集成度受物理极限的制约</li>
<li>按几何级数递增的制作成本</li>
<li>芯片的功耗、散热、线延迟</li>
</ul>
<p>替代传统的硅芯片</p>
<ul>
<li>光计算机<ul>
<li>利用光子取代电子进行运算和存储，数据存储已经实现</li>
</ul>
</li>
<li>DNA生物计算机<ul>
<li>通过控制DNA分子间的生化反应</li>
</ul>
</li>
<li>量子计算机<ul>
<li>利用原子锁具有的量子特性</li>
</ul>
</li>
</ul>
<h2 id="三、系统总线"><a href="#三、系统总线" class="headerlink" title="三、系统总线"></a>三、系统总线</h2><h3 id="3-1总线的基本概念"><a href="#3-1总线的基本概念" class="headerlink" title="3.1总线的基本概念"></a>3.1总线的基本概念</h3><p>总线是链接各个部件的信息传输线，是各个部件共享的传输介质</p>
<p>总线上信息的传送：</p>
<ul>
<li>串行：将要传输的信息一位一位的放置在总线。</li>
<li>并行：要传输的数据多位同时放在总线。需要多条数据线。<ul>
<li>线和线之间会产生干扰，当线过长，接收方很难接收到正确的信息</li>
</ul>
</li>
</ul>
<p>单总线结构框图</p>
<ul>
<li><p>在任何时刻只能有一个部件使用，会发生总线的征用，严重影响性能</p>
</li>
<li><p>如果设备过多总线过长，会导致延迟较高</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.1-1.png" alt></p>
<p>面向CPU的双总线结构框图</p>
<ul>
<li>主存无法跟直接外部设备信息传输，如果传输会打断cpu的计算任务</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.1-2.png" alt></p>
<p>以存储器为中心的双总线结构框图</p>
<ul>
<li>目前这两条总线还是无法做到同时传输，我们一般是使用分时技术来做</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.1-3.png" alt></p>
<h3 id="3-2总线的分类"><a href="#3-2总线的分类" class="headerlink" title="3.2总线的分类"></a>3.2总线的分类</h3><p>根据总线的位置分类</p>
<ol>
<li>片内总线：芯片内部的总线</li>
<li>系统总线：计算机各个部分之间的信息传输线<ul>
<li>数据总线：双向 与机器字长、存储字长有关。<ul>
<li>通常情况，总线的宽度是小于等于机器字长或存储字长</li>
</ul>
</li>
<li>地址总线：单向 与存储地址、I/O地址有关</li>
<li>控制总线：有出 有入<ul>
<li>输出如存储器读、存储器写、总线允许、中断确认</li>
<li>输入如中断请求、总线请求</li>
</ul>
</li>
</ul>
</li>
<li>通信总线：用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信</li>
</ol>
<p>根据传输方式分类</p>
<ul>
<li><p>串行通信总线</p>
</li>
<li><p>并行通信总线</p>
</li>
</ul>
<h3 id="3-3总线特性及性能指标"><a href="#3-3总线特性及性能指标" class="headerlink" title="3.3总线特性及性能指标"></a>3.3总线特性及性能指标</h3><p>总线物理实现：其他部件 模块，可以通过接口连接到主板上</p>
<p><strong>总线特性</strong></p>
<ul>
<li>机械特性：尺寸、形状、管脚数 及 排列顺序</li>
<li>电气特性：传输方向 和有效的 电平 范围<ul>
<li>电平：什么样的高压范围，什么样的低压范围。</li>
</ul>
</li>
<li>功能特性：每根传输线的 功能（传输什么类型的信号）（地址、数据、控制） </li>
<li>时间特性：信号的 时序 关系</li>
</ul>
<p><strong>总线的性能指标</strong></p>
<ul>
<li>总线宽度：数据线的根数</li>
<li>标准传输率：每秒传输的最大字节数（MBps）</li>
<li>时钟同步/异步：同步、不同步（不同步和异步不一样，有其他多种情况）</li>
<li>总线复用：地址线、数据线复（共）用<ul>
<li>8086就是地址线  数据线复用</li>
</ul>
</li>
<li>信号线数：地址线、数据线和控制线的总和</li>
<li>总线控制方式：突发、自动、仲裁、逻辑、计数</li>
<li>其他指标：负载能力</li>
</ul>
<p><strong>总线标准</strong></p>
<p>模块划分</p>
<h3 id="3-4总线结构"><a href="#3-4总线结构" class="headerlink" title="3.4总线结构"></a>3.4总线结构</h3><p>单总线结构</p>
<p>多总线结构</p>
<ul>
<li><p>双总线结构</p>
<ul>
<li>通道：<ul>
<li>是一种特殊类型 结构简单的处理器 专门用于输入输出操作</li>
<li>实现主存、CPU与I/O总线的连接</li>
<li>通道的程序通常情况下是由操作系统来编写，不是人工编写<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-1.png" alt></li>
</ul>
</li>
</ul>
</li>
<li><p>三总线结构</p>
<ul>
<li>DMA：直接存储器访问（外部设备直接访问存储）<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-2.png" alt></li>
</ul>
</li>
<li><p>三总线结构的又一形式</p>
<ul>
<li>内存发展慢于cpu所以在cpu和内存见加了缓存<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-3.png" alt></li>
</ul>
</li>
<li><p>四总线结构</p>
<ul>
<li>将高速设备和低速设备分离<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-4.png" alt></li>
</ul>
</li>
</ul>
<p>总线结构举例</p>
<ul>
<li>传统微型机总线结构<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-5.png" alt></li>
<li>VL-BUS局部总线结构<ul>
<li>VL-BUS高速总线连接图形设备等<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-6.png" alt></li>
</ul>
</li>
<li>PCI 总线结构<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-7.png" alt></li>
<li>多层 PCI 总线结构<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.4-8.png" alt></li>
</ul>
<h3 id="3-5总线控制-重难点"><a href="#3-5总线控制-重难点" class="headerlink" title="3.5总线控制(重难点)"></a>3.5总线控制(重难点)</h3><h6 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h6><ol>
<li>基本概念<ul>
<li>主设备(模块) 对总线有控制权：可以控制总线的占用申请，并且可以控制与另一台设备之间的通信</li>
<li>从设备(模块) 响应从主设备发来的总线命令</li>
<li>总线判优控制<ul>
<li>集中式(方法)：总线的判优逻辑集中到一个部件，比如cpu<ul>
<li>链式查询</li>
<li>计数器定时查询</li>
<li>独立请求方式</li>
</ul>
</li>
<li>分布式(方法)：判优逻辑分布到各个设备</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>链式查询方式</strong>：</p>
<ul>
<li><p>数据线：信息交换过程中数据的传输</p>
</li>
<li><p>地址线：主设备占用总线之后要和从设备进行数据传输要通过地址线找到要通讯的从设备</p>
</li>
<li><p>BR—总线请求：所有设备都通过这条线发出总线占用的请求</p>
</li>
<li><p>BS—总线忙：如果某一个设备占用的总线控制权，就通过该线告诉总线控制部件或其他部件</p>
</li>
<li><p>BG—总线授权线：链式的特点。一个接着一个连下。BG会一个一个向下传输，直到找到发起总线控制请求的部件</p>
</li>
</ul>
<p>过程：部件通过BR向总线请求，总线控制通过BG一个一个向下传输，直到找到发起总线请求的部件，然后该部件通过BS发出总线忙信号</p>
<blockquote>
<p>优先级就是BG传递的顺序，由排列方式决定。如果一个部件排靠后有可能一直无法获取总线控制权。一般用在微机，简单的嵌入式</p>
<p>优点：结构简单，增删设备简单，进行可靠性设计的时候比较容易实现。</p>
<p>缺点：对电路故障特别敏感，特别是BG</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.5-1.png" alt></p>
<p><strong>计数器定时查询方式</strong></p>
<ul>
<li>设备地址：这上面传输的地址是由计数器给出的，通过这个地址来查找某一个设备是否发出了总线占用请求。</li>
</ul>
<p>过程：总线控制部件中有一个计数器，初值可以是0或其他，如果某一个主设备和从设备需要占用总线进行数据传输。通过BR向总线控制部件提出占用请求，总线控制器在接收到信号后，在能够响应的情况下可以让出总线使用权的情况下会启用计数器，这个计数器的值会通过设备地址这条线向外输出，设备地址给出信号后，如计数0 会向I/O接口0查询是否提出总线占用请求，如果没有计数+1.然后向I/O接口1查询，直到找到发出请求的接口。</p>
<blockquote>
<p>如果初值为固定值，那么它的优先级最高。如果为最后一次的计数则是循环优先级。也可以通过软件的方式对总线控制部件进行设置。使得优先级的顺序更加灵活</p>
<p>设备地址线的宽度和设备数有关</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.5-2.png" alt></p>
<p><strong>独立请求方式</strong></p>
<p>内部有一个排队器。非常灵活，可以通过配置排队器，设置优先级，也可以在内部使用计数器等等。用的多，速度快</p>
<p>所有请求的部件将信号发至总线控制部件，总线控制部件通过排队器对某个设备进行应答，那么该设备就占用总线的使用权。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.5-3.png" alt></p>
<h6 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h6><p>目的：解决通信双方协调配合问题</p>
<p><strong>总线传输周期</strong>：总设备和从设备之间完成一次完整的并且可靠的通信需要的时间</p>
<ul>
<li>申请分配阶段：主模块申请，总线仲裁决定</li>
<li>寻址阶段：主模块向从模块 给出地址和命令**</li>
<li>传数阶段：主模块和从模块 交换数据</li>
<li>结束阶段：主模块 撤消有关信息</li>
</ul>
<p><strong>总线通信的四种方式</strong></p>
<ul>
<li>同步通信：由统一时标(定宽定距)控制数据传送</li>
<li>异步通信：采用应答方式，没用公共时钟标准</li>
<li>半同步通信：同步、异步结合</li>
<li>分离式通信：充分挖掘系统总线每个瞬间的潜力</li>
</ul>
<p><strong>同步式数据输入</strong></p>
<p>这里的总线传输周期由四个时钟周期构成，四个时钟周期就是一个完整的数据通信</p>
<p>过程：T<del>1</del>时钟的上升点 必须要给出地址信号(主设备给出)，T<del>2</del>时钟上升点必须给出读命令信号，T<del>3</del>上升点必须要给出数据信号，T<del>4</del>上升点数据信号控制信号撤销，T<del>4</del>结束时地址信号撤销<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.5-4.png" alt></p>
<p><strong>同步式数据输出</strong></p>
<p>过程：在T<del>1</del>时钟周期的上升点要给出地址信号，在T<del>1</del>时钟周期的下降点要给出数据信号，在T<del>2</del>时钟的上升点要给出写命令，T<del>3</del>做写入操作，T<del>4</del>的上升点主设备撤销写命令，T<del>4</del>结束的时候撤销地址信号。完成写命令</p>
<blockquote>
<p>对多个速度不同的模块，必须选择速度最慢的模块，作统一的时标。</p>
<p>一般应用在总线长度比较短，并且各个模块存取时间比较一致的情况。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/images%5C3.5-5.png" alt></p>
<p><strong>异步通信</strong></p>
<p>主设备发起总线通信，从设备受主设备控制。与同步相比没有定宽定距的时钟，但是要加两条线：请求线（主设备发出请求信号）、应答线（从设备对主设备发出的请求进行应答）</p>
<p>不互锁过程：主设备发出通信请求，从设备接受到后发出应答，主设备撤销请求信号，从设备撤销应答信号。在这过程中，主设备不管是否接收到应答信号，经过一段后都会撤销请求信号。从设备也是。</p>
<blockquote>
<p>消息可靠性无法保证</p>
</blockquote>
<p>半互锁过程：主设备发出请求，从设备接收到后发出应答，主设备接收到请求信号后，会撤销，如果没有接收到，请求会保持。</p>
<blockquote>
<p>有可能会造成请求信号一直保持</p>
</blockquote>
<p>全互锁过程：主设备发出请求，从设备接收到后发出应答，主设备接收到请求信号后，会撤销，只有主设备撤销请求信号后，从设备才会撤销应答信号。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.5-6.png" alt></p>
<p><strong>半同步通信(同步、异步结合)</strong></p>
<p>同步：发送方 用系统 时钟前沿 发信号。接收方 用系统 时钟后沿 判断、识别 （有定宽定距的时钟管理整个通信过程）</p>
<p>异步：允许不同速度的模块和谐工作，增加一条”等待“响应信号（wait信号，由从设备给出）</p>
<p>以输入数据为例的半同步通信时序</p>
<ol>
<li>T<del>1</del>主模块发地址</li>
<li>T<del>2</del>主模块发命令</li>
<li>当wait信号低电平时，等待一个T</li>
<li>……</li>
<li>T<del>3</del>从模块提供数据</li>
<li>T<del>4</del>从模块撤销数据，主模块撤销命令</li>
</ol>
<blockquote>
<p>如果在T<del>3</del>到来之前，从模块无法提供数据。从模块就发出wait信号，主模块如果监测到wait信号，就插入T<del>w</del>等待数据到来。在下一个时钟周期到来之前，主模块还会检测，直到低电平变成高电平</p>
</blockquote>
<p>由等宽定距的时钟控制整个通信过程</p>
<p>过程： T<del>1</del>CPU要给出地址信号，T<del>2</del>CPU要给出读信号，T<del>3</del>从设备如果不能准备好数据，通过wait信号给出一个低电平让cpu等待，插入T<del>w</del>周期，wait变为高电平，可以接受数据信号。T<del>3</del>开始接收数据。T<del>4</del>开始时读命令和数据信号开始撤销。T<del>4</del>地址信号撤销。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.5-7.png" alt></p>
<p><strong>三种通信的共同点</strong></p>
<p>一个总线传输周期（以输入数据为例）</p>
<ul>
<li>主模块发地址、命令：占用总线</li>
<li>从模块准备数据：不占用总线（总线空闲）</li>
<li>从模块向主模块发数据：占用总线</li>
</ul>
<blockquote>
<p>在准备数据过程中，总线是被浪费的</p>
</blockquote>
<p><strong>分离式通信</strong></p>
<p>充分挖掘系统总线每个瞬间的潜力</p>
<ul>
<li>子周期1：主模块申请占用总线，使用完后。即放弃总线的使用权</li>
<li>子周期2：从模块申请占用总线，将各种信息送至总线上</li>
</ul>
<p>特点</p>
<ul>
<li>各模块有权申请占用总线</li>
<li>采用同步方式通信，不等对方回答</li>
<li>各模块准备数据时，不占用总线</li>
<li>总线被占用时，无空闲</li>
</ul>
<h2 id="四、存储器"><a href="#四、存储器" class="headerlink" title="四、存储器"></a>四、存储器</h2><h3 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h3><p>存储器可分哪些类型</p>
<p>现代存储器的层次结构，为什么要分层</p>
<h6 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h6><ul>
<li><p>按存储介质分类</p>
<ul>
<li>半导体存储器：易失<ul>
<li>TTL：晶体管。集成度低，功耗高速度快。</li>
<li>MOS(现在计算机主要)：晶体氧化物半导体。功耗低，集成度高。</li>
</ul>
</li>
<li>磁表面存储器：非易失<ul>
<li>磁头</li>
<li>载磁体</li>
</ul>
</li>
<li>磁芯存储器：磁芯里有导线，导线有电流，通过电流，将磁芯磁化。磁芯本身是<del>铁氧体</del>。在电流的作用下被磁化，磁化为N极和S极。根据磁场的方向就可以保存信息。磁芯只要流过电流就会被磁化，改变磁场方向。我们可以通过材料工艺获得改变磁场方向最小电流的阈值。然后每个磁芯里放两个相互垂直的导线，另一条导线斜着穿过。两条相互垂直的导线作为数据的写入和读出的驱动线。另外一条线用作数据读出。（了解）非易失<ul>
<li>硬磁材料、环状元件</li>
</ul>
</li>
<li>光盘存储器：非易失<ul>
<li>激光、磁光材料</li>
</ul>
</li>
</ul>
</li>
<li><p>按存取方式分类</p>
<ul>
<li>存取时间与物理地址无关（随机访问）：不管存在哪里访问时间一样<ul>
<li>随机存储器（RAM）：在程序的执行过程中可读可写（这么说其实是有问题的随机存储器被分为只读存储器、随机存储器）</li>
<li>只读存储器：在程序的执行过程中只读</li>
</ul>
</li>
<li>存取时间与物理地址有关（串行访问）<ul>
<li>顺序存取存储器（磁带）：必须转动磁带到指定位置下才能读写</li>
<li>直接存取存储器（磁盘）：首先要找到给定的磁道，通过磁头在表面jinxiang移动，然后停留在磁道上，直到指定的扇区转到磁头下，才能开始读出和写入</li>
</ul>
</li>
</ul>
</li>
<li><p>按在计算机中的作用分类</p>
<ul>
<li>主存储器<ul>
<li>RAM（可读写）：<ul>
<li>静态RAM</li>
<li>动态RAM</li>
</ul>
</li>
<li>ROM（只读）<ul>
<li>MROM（掩模ROM）</li>
<li>PROM（可编程ROM）</li>
<li>EPROM（电可编程ROM）</li>
<li>EEPROM（电可擦写可编程ROM）</li>
</ul>
</li>
</ul>
</li>
<li>Flash Memory：在主存储器和辅助存储器之间，常用U盘就是这个做的。半导体存储器，速度比磁盘块，比主存储器慢。也可以做计算机硬盘。SSD的核心存储材料。</li>
<li>高速缓冲存储器（Cache）：在主存储器和CPU之间。通常用静态ROM来做。比主存和FM快。</li>
<li>辅助存储器：磁盘、磁带、光盘</li>
</ul>
</li>
</ul>
<h6 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h6><p>存储器的三个主要特征的关系（速度、容量、价格）</p>
<p>寄存器不光在CPU中，I/O设备中也有，有些寄存器我们在指令中可以使用，从体系结构角度来说这些寄存器是不透明的是提供给机器语言程序员的，叫体系结构寄存器，CPU中还有一些寄存器不需要机器语言程序员了解，对机器语言程序员来说是透明的，被称为非体系结构寄存器，指令不能直接对这些寄存器操作。</p>
<p>缓存的一部分CPU中有。早期CPU是没有的</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.1-1.png" alt></p>
<p>为什么要分这么多层：用户的要求，单一的任何一种都无法满足用户的要求，用户需要高速度，大容量，低价格。采用层次结构形成存储体系。</p>
<p>存储体系：把两种或两种以上的存储介质构成的存储器，用软件、硬件或软硬件结合的方式连接成一个整体。使得从某一级程序员的角度看具有高速度、大容量、低价格。</p>
<blockquote>
<p>程序员在使用过程中不需要考虑层次结构，信息在层次结构间的调入调出都是由软件硬件，软硬件相结合的机构自动完成。</p>
</blockquote>
<p>计算机中有两个非常重要的层次：缓存—主存层次、主存—辅存层次</p>
<p>主存的容量是有限的，程序如果足够大或文件太大，主存放不下就需要用到辅存。但程序的运行是在主存，如果程序要运行，就要将程序调入到主存，主存和辅存也需要数据交换 就构成了一个存储层次。在这个存储层次上我们用软硬件相结合的方法把主存和辅存构成一个整体。从应用程序员的角度看这个存储有主存的速度，辅存的容量，辅存的价格。在程序执行过程中超过主存容量应用程序员也不用自己去考虑如何将程序分割。这些都由软硬件结合的来调配。</p>
<p>CPU和主存速度发展的差距称为剪刀差。为了弥补这个差距就在CPU与主存间加上了一层缓存（cache容量小功耗大速度快）。</p>
<blockquote>
<p>将常用程序放入缓存。这里用到了程序的局部性原理，包括时间局部性、空间局部性。</p>
</blockquote>
<p>缓存和主存采用<strong>硬件</strong>的方法连接为一个整体。主要为了解决速度问题，所以采用硬件方法。</p>
<p>主存和辅存是<strong>软硬件</strong>相结合的方法连接为一个整体。主要为了解决容量问题，所以采用软硬件方法。</p>
<p>主存和辅存构成的整体一般称为虚拟存储器。地址既不是主存地址也不是辅存地址，这里用的是虚拟地址（逻辑地址）。</p>
<p>缓存和主存之间的地址，我们使用的是主存的地址（实地址，物理地址），没有定义一个空间也没有使用缓存的地址。缓存是按照内容来查找，即使给出一个地址也是主存中的地址，然后转化为缓存块的编号。</p>
<h3 id="4-2主存储器-重点"><a href="#4-2主存储器-重点" class="headerlink" title="4.2主存储器(重点)"></a>4.2主存储器(重点)</h3><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p><strong>主存的基本组成</strong></p>
<p>MDR（主存数据寄存器）：保存了要读出或写入的数据。具体是读出还是写入要通过读写电路和控制电路来控制。</p>
<p>MAR：保存了我们要访问的存储单元的地址。必须结果译码器译码以后才能选定指定的存储单元。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-1.png" alt></p>
<p><strong>主存与CPU之间的联系</strong></p>
<p>数据总线直接连到MDR上是双向的，可能读出也可能写入</p>
<p>地址总线连接在MAR寄存器和主存的地址总线之间，给出了要访问内存单元的地址，单向，从CPU—&gt;主存。</p>
<p>控制信号两个，读和写都是单向</p>
<p>CPU与主存的连接，实际上是三种类型的信号</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-2.png" alt></p>
<p><strong>主存中存储单元地址的分配</strong></p>
<p>假设主存的结构存储字长32位，也就是说对这个存储器某个单元读或写一次最多读出或者写入32位的01。</p>
<p>主存的编址单位是字节，每一个字节都有一个地址。</p>
<blockquote>
<p>每个字节8位，所以编址单位是8位，编址单位可以理解为切割存储空间的粒度</p>
<p>存储字节32位，用8位的字节分割，一个存储单元被分为4个地址</p>
<p>字地址=存储字地址=存储单元地址</p>
<p>存储字长32位=4字节，所以包含4个字节地址</p>
</blockquote>
<p><code>12345678H</code>(16进制数)在主存储器如何存储</p>
<p>高位字节地址(这里1是最高位)</p>
<p>X86采用小尾方式。两种方式没有高下之分。两种类型的机器通信会产生问题，需要重新调整顺序。</p>
<p>所有的地址线组成的地址值对应一个字节，24根地址线就有2^24^种状态。就是2^24^字节</p>
<p>一个字节是8位，字长如果位16位就是2个字节，字长如果是32位就是4个字节</p>
<p>这里的MW，W指的是word，第一个w是16位，第二个w是32位。</p>
<p>这里的16MB、8MW和4MW大小其实是一样的，只是表示方式不同</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-3.png" alt></p>
<p><strong>主存的技术指标</strong></p>
<ul>
<li><p>存储容量 主存存放二进制数的总位数</p>
</li>
<li><p>存储速度</p>
<ul>
<li>存储时间：从存储器给出地址一直到得到稳定的数据输出或者输入<ul>
<li>存储器的访问时间读出时间、写入时间</li>
</ul>
</li>
<li>存储周期：<strong>连续</strong>两次<strong>独立</strong>的存储器操作（读或写）所需的<strong>最小间隔时间</strong><ul>
<li>第一次开始到第二次进行存取操作，称为存储时间</li>
<li>存储周期和存取时间不一样的。一般来说存取周期要比存取时间长。存取周期=存取时间+回复时间。</li>
<li>存储周期分为：读周期、写周期</li>
</ul>
</li>
<li>存储带宽 （位/秒）</li>
</ul>
</li>
</ul>
<h6 id="半导体存储芯片简介"><a href="#半导体存储芯片简介" class="headerlink" title="半导体存储芯片简介"></a>半导体存储芯片简介</h6><p><strong>半导体存储芯片的基本结构</strong></p>
<p>地址线是单向的输入的，CPU、外部设备给出地址。结果译码驱动选择指定存储单元完成读写操作。</p>
<p>数据线是双向的</p>
<p>片选线：芯片选择信号，指出了这次操作给出的地址是不是针对这个存储芯片的地址，被选择存储单元、字节是否在这个芯片中。</p>
<p>CS、CE上面一横表示低电平有效，不同芯片采用不同标识来表示</p>
<p>CS（chip selection）：如果是低电平的话，这次数据访问他的地址就是在这个存储序列中。</p>
<p>CE（chip enable）：芯片使能信号。也可以用这个来标识。</p>
<blockquote>
<p>内存条上有很多芯片，片选线来确定在哪个或哪几个芯片中</p>
</blockquote>
<p>读写控制信号可能一条可能两条，如果是一根线给出WE表示，当信号是低电平对这个芯片写操作。也可以用两根线表示，第一根是OE，O是输出，如果这根线低电平表示输出，从存储矩阵中把指定单元的数据写入数据线。WE也是低电平写操作。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-4.png" alt></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-5.png" alt></p>
<p><strong>片选线作用</strong>：用 16K × 1位 的存储芯片组成 64K × 8位 的存储器。用8个这种类型的芯片，同时进行读写，每个芯片给出或者写入一位二进制信息。8个芯片就构成一个8位，那么8个芯片就为一组，这一组就是16k×8位的芯片组。这样的芯片布置四组就满足了。然后每组用片选线连接。将CPU的地址中0—(16-1)k分配给第一组芯片，从16k—(32-1)k分到第二组以此类推。当地址为65535时，最后一组片选信号有效，其他的无效也就是高电平。 片选线可以让某一个或者某些芯片同时进行工作</p>
<p><strong>半导体存储芯片的译码驱动方式</strong>：给出了存储单元的地址后，如何去找到指定的存储单元</p>
<ul>
<li><p>线选法</p>
<ul>
<li>地址：A<del>0</del>—A<del>3</del>一共四位地址，说明有16(2^4^)个存储单元。数据线是D<del>0</del>—D<del>7</del>一共8位。说明存储器是16×8。</li>
<li>地址译码器实质就是一个译码器。给定一个输入，只有一根线会控制响应的存储单元中所有存储元件，进行数据输入或输出操作。</li>
<li>读写控制电路：如果是读就向外，如果是写就向内</li>
<li>如果输入0000，那么只要0这根线有效，如果是读信号，只有给定单元才能输出</li>
<li>问题：地址线只有4条，容量为16乘8。没有这么小的存储器，假设有1M×8的存储器，1M有20个地址线。1M条线做在芯片中会非常密集，就很难将内存芯片集成度做高。</li>
</ul>
<blockquote>
<p>比如输入01，那么输出的第一根线有效，其他三根无效。译码器就是从编码向数据翻译的过程</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-6.png" alt></p>
<ul>
<li>重合法：<ul>
<li>我们将地址分为两部分，X和Y。称为行地址和列地址。行列地址分别进行译码，都只有一条线有效</li>
<li>过程：假如X、Y都是00000，那么只有X<del>0</del>和Y<del>0</del>有效。(0,0)的数据就可以输出，(0,31)的数据也会输出由于Y<del>31</del>是无效的，尽管会但不会送到数据线上。中间的1到30都是一样的情况。</li>
<li>线选法如果是20条输入线，输出线就是1M条。重合法分为两部分假如每一部分都是10位，行列各1K条，总计2K条。比线选法要少很多，就可以提高芯片集成度</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-1.png" alt></p>
<h6 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h6><p><strong>静态RAM(SRAM)</strong></p>
<p>保存0和1的原理是什么</p>
<ul>
<li><p>核心利用了一个触发器(数电中)</p>
</li>
<li><p>这里的触发器利用了T<del>1</del>—T<del>4</del>四根管子。这个触发器是一个双稳态的触发器，在两端用来存储信息，一端是触发器的原端，另外一端是触发器的非端。如果一端是1另一端就是0，如果一端是0另一端是1。</p>
</li>
<li><p>T<del>5</del>和T<del>6</del>用于解决读写。T<del>5</del>和T<del>6</del>都是由行地址选择控制</p>
</li>
<li><p>静态RAM的基本单元电路就包括两部分，一部分是存放01的，另一部分就是控制对这个部分读写的两个晶体管，一共6个晶体管。</p>
</li>
<li><p>这个存储元件(虚线中)如果做在芯片中往往会构成一列，而不是一个。T<del>7</del>和T<del>8</del>是一列所有存储元件共有的开关。</p>
</li>
<li><p>如果某一个单元被选中，它所对应的T<del>5</del>和T<del>6</del>被打开，行地址选择继续向下延续，这一行上所有的存储单元都是由行地址选择线控制。存储的数据会送到相对应的位线上，但只有列地址选择线有效，行列交叉点才能进行读写。</p>
</li>
<li><p>写入的时候，由于是双稳态的触发器，我们分为两个方向，一个方向写入直接要写入的数据，另一个方向写入要写入数据的非。所以我们在电路里用到了三态门取反</p>
</li>
</ul>
<blockquote>
<p>类比前面的重合法</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-8.png" alt></p>
<p><strong>静态RAM的基本读操作</strong></p>
<p>过程：给出行选信号，打开T<del>5</del>、T<del>6</del>。再给出列选信号，打开T<del>7</del>、T<del>8</del>。如果读有效，读放的管子会打通。存放在A中的数据就会通过T<del>6</del>晶体管送到位线，同时T<del>8</del>也是打通的，信号会继续向前送。一直送到数据总线上。非端也会发出信号，也会送出，但是在写放大器部分时被劫持。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-9.png" alt></p>
<p><strong>静态RAM的基本写操作</strong></p>
<p>左侧的写放大器是取非以后输出的，保证A端和A‘端写入相反信号。</p>
<p>过程：如果基本电路被选中，行译码以后产生的行地址选择信号会打开T<del>5</del>和T<del>6</del>，同样列地址信号会打开T<del>7</del>和T<del>8</del>。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-10.png" alt></p>
<p>静态RAM芯片举例</p>
<ul>
<li>WE：读写控制信号，低电平表示写操作，高电平表示读操作。</li>
<li>CS：片选信号，只有CS是低电平的时候该芯片才会被选中。</li>
<li>A<del>0</del>—A<del>9</del>：地址线，所以得出2^10^个存储单元</li>
<li>I/O<del>1</del>—I/O<del>4</del>：数据线，每个存储单元被选中可以读出或写入4位信号。</li>
<li>所以存储容量是1K×4位。</li>
<li>这里可以64×64来布置存储单元，用译码驱动的方式来选择存储单元。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/images%5C4.2-11.png" alt></p>
<p>Intel 2114 RAM(64×64 )</p>
<ul>
<li><p>64列分为4组，每组16列</p>
</li>
<li><p>行地址，一共6位，译码后可以产生2^6^，列地址一共4位，2^4^.</p>
</li>
<li><p>要想每次从阵列中读取4位数据或写入4位数据，每一个列选信号要控制4列。所以64列分为4组每一组16列。每一个列选信号，控制了每一组中的一列。比如第0列选信号，分别控制1组2组3组4组的第0列。</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-12.png" alt></p>
<ul>
<li>读过程：经过行地址译码器，第0行被选中。经过列地址译码每一组中的第0列都会被选中，WE、CS信号有效。第0行每一组中的第0列都经过列控制管还有读写电路输出到响应的数据线上。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-13.png" alt></p>
<ul>
<li>列地址(0000) 行地址(000000)，行列地址译码后，第0行的行选择信号有效，第0列对应每一组的第0列有效。we低电平，cs低电平。数据通过I/O<del>1</del>—I/O<del>4</del>输入读写电路写到每一个基本单元电路的A端和A’端。</li>
</ul>
<p><strong>动态RAM(DRAM)</strong></p>
<p>利用电容保存0和1。如果电容中保存了电荷，信息为1，如果没电保存信息为0</p>
<p><strong>动态RAM基本单元电路</strong></p>
<ul>
<li>3管动态RAM</li>
</ul>
<ul>
<li><p>信息保存在电容C<del>g</del>。</p>
</li>
<li><p>T<del>1</del>、T<del>2</del>、T<del>3</del>是控制管，通过这三根控制管控制读出和写入</p>
</li>
<li><p>上面的线为读选择线，读选择线有效会打通T<del>2</del>，下面的线为写选择线，写选择线有效会打通T<del>3</del>。外部的数据可以通过T<del>3</del>这个管子对C<del>g</del>读或写。</p>
</li>
<li><p>读过程：先通过T<del>4</del>预充电信号，使T<del>4</del>晶体管打通，V<del>DD</del>通过T<del>4</del>晶体管给读数据线充电，读数据线高电平表示1。左侧：读选择信号有效，T<del>2</del>被打通。如果C<del>g</del>保存的是0，T<del>1</del>删极是低电平，T<del>1</del>不会导通，读数据线就会保持高电平。也就是说如果保持的信息是0在读书极限上读出的数据就是1。如果保存的信息是1，T<del>1</del>这个电容会充电T<del>1</del>的删极有电，T<del>1</del>就导通，因为预充电保存的是1，那么高电平就会通过T<del>2</del>和T<del>1</del>的管子放电，变成低电平。</p>
</li>
<li><p>写过程：写选择线有效，T<del>3</del>导通，写数据线会通过T<del>3</del>管子向C<del>g</del>进行充电或放电，如果写入的是低电平，C<del>g</del>会通过T<del>3</del>放电，C<del>g</del>就是0.</p>
</li>
<li><blockquote>
<p>读出与原存信息相反，如果想读出正确信号。就需要在读数据的输出端加一个非电容。</p>
<p>写入与输入信息相同</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-15.png" alt></p>
<ul>
<li>单管动态RAM：存储信息的原理和3管动态RAM一样。C<del>S</del>保存信息<ul>
<li>读过程：字线是控制线。如果响应的行被选中，字线控制的T被打开，电容可以通过管子T<del>1</del>，进行充电或者放电。如果C<del>S</del>保存是0数据线上就不会有电流，如果数据线上保存的是1，那么数据线上就会有电流。通过有无电流就可以确定保存的信息。读出时有点为“1”，无电“0”</li>
<li>写入如果是“1”就是充电，写入如果是“0”就是放电。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-16.png" alt></p>
<p><strong>动态RAM芯片举例</strong></p>
<p>三管动态RAM芯片(Intel 1103)</p>
<ul>
<li>A<del>0</del>到A<del>9</del>十位地址线，说明容量为1K。每次读出或写入只有一位数据。芯片容量：1K×1.</li>
<li>行地址经过译码以后产生的信号，每一个都对应两个控制信号一个读选择线一个写选择线，读写用不同的信号进行控制。也就是说在行地址译码器参加译码的不仅仅是地址同时还有读写控制信号。</li>
<li>三角形：刷新放大器，因为我们采用电容存储电荷来保存信息。电容会漏电，经过一段时间电容上信号会消失，所以用刷新放大器对电容中保存信息进行重现。每经过一段时间都要刷新</li>
<li>读过程：行地址译码器给出第0行读操作，列地址译码器给出第0行。通过读数据线把数据送到读写控制电路上，同时可以向外输出。</li>
<li>写过程：给出响应地址信号，假如行地址11111，就是31行，列地址00001，就是第一列。第31行第1列被选中，数据通过D端进行输出，经过读写控制电路写入第31行第1列</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-17.png" alt></p>
<p>单管动态RAM 4116(16K×1位)外特性</p>
<ul>
<li>16K需要14根地址线，但4116只有7根地址线。实际需要14位地址，这14位地址是分两次传送的，第一次接受到的7位是行地址，被放到行地址缓存器中。再接受7位列地址，译码后选中给定的存储单元进行输入和输出。</li>
<li>I/O缓存器，完成数据的输入输出缓冲，两端连接了数据输入寄存器和数据输出驱动，来完成数据的输入和输出。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-18.png" alt></p>
<p>4116 读写</p>
<ul>
<li><p>16k的基本单元电路被放在128行，128列上。(这张图竖的是行横着是列) </p>
</li>
<li><p>在63行64行之间每一列都有一个放大器，这个放大器是跷跷板电路（如果在一端强制为1，另一端则为0）</p>
</li>
<li><p>读原理：行地址：0111111，那么63行被选中，63行对应的行选线有效，对应的所有晶体管被打开，电容中的信息被送出到读放大器左侧。读放大器取反送出。也就是说读放大器左侧，电容有电表示0电容无电表示1。右侧相反。第0列打开，其他管子截止。</p>
</li>
<li><p>写操作：行地址：0111111，63行所有晶体管打开。数据通过I/O缓冲送到读写线。第0列打开，其他管子截止。数据只能送到第0列读放大器右端(取反)，通过读放大器左端。把它写入指定的单元。</p>
</li>
</ul>
<blockquote>
<p>读出和写入都反向了，所以读出和写入信息一致。</p>
</blockquote>
<p><strong>动态RAM刷新</strong></p>
<p>动态RAM是利用电容存储电荷的方式来保存信息。电容做的非常小很容易漏电，在一段时间如果不对电容中的信息再生的话，电容信息就会丢失。</p>
<p>对动态RAM刷新，之和行地址有关，和列地址无关。每一次刷新操作刷新的是动态RAM中一行所有的基本单元电路。</p>
<p>刷新过程：(参考三管动态RAM1103)给出行地址后，该行上所有的基本单元电路信息都会被送到读数据线上，如果在读数据线和写数据线之间，加上一个刷新放大器的话，就可以完成对某一行的全部信息的刷新</p>
<p>刷新方式：</p>
<ul>
<li><p>集中刷新（存取周期为0.5 <img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-19.png" style="zoom:50%;">s ):把刷新的时间集中在一个时间段来操作.</p>
<ul>
<li>假设存取周期是0.5微秒,动态RAM中的电容刷新周期假设为2毫秒也就是说动态RAM中所有的电容在2毫秒内都完成信息的刷新。2毫秒一共是4k个存储周期(2毫秒/0.5微秒)。这4000个存储周期中前面的3872个周期可以供CPU、I/O对动态RAM读出或写入操作,后面128个周期专用于芯片的刷新操作。</li>
<li>在死区时,CPU和IO想进行读写,只能进行等待。</li>
</ul>
<blockquote>
<p>在这128个周期中,无论是CPU还是IO都无法对动态RAM进行信息交换。又叫死区</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-20.png" alt></p>
</li>
<li><p>分散刷新(存取周期为1 <img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-19.png" style="zoom:50%;">s)</p>
<ul>
<li>t<del>C</del>：t<del>C</del>=t<del>M</del>+t<del>R</del>整个存储周期。</li>
<li>t<del>M</del>(0.5微秒)：原来的读写周期，也就是CPU、IO和内存进行信息交换的读写或者存储周期。</li>
<li>t<del>R</del>(0.5微秒)：专门用于某一行的动态RAM刷新</li>
</ul>
<blockquote>
<p>这样实际将动态RAM芯片读写周期变为原来的两倍</p>
<p>无死区</p>
</blockquote>
<blockquote>
<p>每1微秒就刷新一行，128微秒就全部刷新完了，2毫秒就是每一行刷新15.6次。这实际上是过度刷新。动态RAM不需要这么频繁。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-21.png" alt></p>
</li>
<li><p>分散刷新与集中刷新相结合（异步刷新）</p>
<ul>
<li>2毫秒需要刷新128行，每经过15.6微秒刷新一行即可。就将2毫秒分为128份，每份15.6微秒。在每一份时间里对某一行进行刷新，可以放到该份的最后，也可以放在中间或者前面。相对于每一份来说是集中刷新，相对于整个来说是分散刷新。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-22.png" alt></p>
</li>
</ul>
<p><strong>动态RAM和静态RAM的比较</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>DRAM(主存、内存条)</th>
<th>SRAM(缓存、cache)</th>
</tr>
</thead>
<tbody><tr>
<td>存储原理</td>
<td>电容</td>
<td>触发器</td>
</tr>
<tr>
<td>集成度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>芯片引脚</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>功耗</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>价格</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>刷新</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<ul>
<li>动态RAM每一个单元电路都非常简单包含一个晶体管一个电容，静态RAM比较复杂包含6个晶体管</li>
<li>动态RAM行地址和列地址可以分别进行传送，地址线条数可以减少到原来的一半，芯片的引脚就可以减少，芯片的封装体积也就小了。</li>
<li>静态RAM价格贵速度快，一般使用时不会分别传送行列地址，在内部再译码。主要是需要静态RAM的速度优势。</li>
<li>动态RAM刷新耗电，由T<del>1</del>到T<del>4</del>构成的双稳态触发器，工作后有三个管子一直保持导通状态，一直漏电。</li>
<li>触发器要比电容充放电快</li>
</ul>
<h6 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h6><p>一般用于保存系统程序或系统的配置信息。</p>
<p>发展历程：厂家写好内容—&gt;用户可以自己写(一次性)—&gt;多次写(对信息擦除)—&gt;电可擦写(特定设备)—&gt;电可擦写(计算机)</p>
<p><strong>掩模ROM(MROM)</strong></p>
<p>用户不能修改，只能读不能擦除。</p>
<p>(教材P88 图4.27)是1k×1的掩模ROM内部结构，上面一排晶体管是预充电管，经过预充电管充电后。所有的位线都是高电平。在行和列的交叉点上有的有晶体管有的无晶体管。假设交叉点被选中并且有晶体管，晶体管被选中就是导通的，预充电位线上的高电平变为低电平。输出端有一个读出放大器并且对输出的数据进行反向。</p>
<ul>
<li><p>行列交叉处有MOS管为”1“</p>
</li>
<li><p>行列交叉处无MOS管为”0“</p>
</li>
</ul>
<p><strong>PROM(一次性编程)</strong></p>
<ul>
<li><p>熔丝断为”0“</p>
</li>
<li><p>熔丝未断为”1“</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-23.png" alt></p>
<p><strong>EPROM(多次性编程)</strong></p>
<p>N型沟道浮动栅MOS电路</p>
<ul>
<li>G端栅极：栅极如果有电，源和漏就是通的。</li>
<li>如果在漏端加正点压，就会在源和漏之间形成浮动栅。使S和D不导通。保存信息认为是“0”</li>
<li>如果要修改，用紫外线照射驱散浮动栅</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-24.png" alt></p>
<p><strong>EEPROM(多次性编程)</strong></p>
<ul>
<li>电可擦写</li>
<li>局部擦写</li>
<li>全部擦写</li>
</ul>
<p><strong>Flash Memory(闪速型存储器)</strong></p>
<ul>
<li>EPROM 价格便宜、集成度高</li>
<li>EEPROM 电可擦写</li>
</ul>
<p>FM比EEPROM快，且具备RAM功能</p>
<h6 id="存储器与CPU的连接-重难点"><a href="#存储器与CPU的连接-重难点" class="headerlink" title="存储器与CPU的连接(重难点)"></a>存储器与CPU的连接(重难点)</h6><p>CPU执行的指令、需要的数据、运行结果都要保存在主存储器中。</p>
<p><strong>存储器容量的扩展</strong></p>
<ul>
<li><p>位扩展(增加存储字长)</p>
<ul>
<li>用2片1K×4位存储芯片组成1K×8位的存储器。1K容量需要10根地址线，地址线输入到每个芯片上。每个芯片数据线分别和CPU数据线上的四条形成连接。片选和读写一定要连接在一起，使同时工作。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-25.png" alt></p>
<ul>
<li>问：2114的地址线是否需要按序的和系统地址线连接？2114的数据线是否需要按序的和系统数据线连接？</li>
</ul>
</li>
<li><p>字扩展(增加存储字的数量)</p>
<ul>
<li>用2片1K×8位存储芯片组成2K×8位的存储器。A<del>0</del>到A<del>10</del>将A<del>10</del>做片选线，A<del>10</del>为0选择第一个芯片，A<del>10</del>为1选择第二个芯片。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-26.png" alt></p>
</li>
<li><p>字、位扩展</p>
<ul>
<li>用8片1K×4位存储芯片组成4K×8位的存储器</li>
<li>A<del>0</del>到A<del>9</del>做地址线，剩余两根做片选信号。两个芯片一组，分别和系统数据线8位相连。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-27.png" alt></p>
</li>
</ul>
<p><strong>存储器与CPU的连接</strong></p>
<ul>
<li><p>基本方法</p>
<ul>
<li>地址线的连接：一般来说地址连接，都将地址的地位作为地址送到存储器的地址线中，高位作为芯片选择信号</li>
<li>数据线的连接： CPU的数据线条数可能比存储器数据线条数多。这种情况下就要使用位扩展，使存储器输出、输入的能满足CPU的要求。</li>
<li>读/写命令线的连接：CPU给出读写命令，把读写线连接到每一个芯片上，连接到读写控制端上。(ROM除外，只读存储器，只能读不能写)</li>
<li>片选线的连接：这次访问的地址空间，在哪个或哪几个芯片上。进行片选线连接时，要确认①CPU的访问操作，访问的是存储器而不是IO，存储器的访问信号一定要在片选线中体现②每一个内存芯片都有自己的地址范围，这个地址范围必须满足CPU的要求，每根地址线，都要用到。有一些地址作为存储芯片的内部地址输入到每一个存储芯片中，有一些地址要用作片选信号来保证对某一个芯片的访问一定是在给定的地址范围之内。</li>
<li>合理选择存储芯片：<ul>
<li>ROM和RAM的选择。一般来说，保存系统程序的和保存配置信息的地方，存储空间选择ROM。用户程序区，系统程序运行区，采用RAM。</li>
<li>同样的ROM或RAM，技术参数或性能参数是不一样的。芯片数量尽可能少，片选逻辑尽可能简单。</li>
</ul>
</li>
<li>其他：<ul>
<li>时序：CPU时序和存储器时序相互配合</li>
<li>负载：CPU能带多少个存储芯片</li>
</ul>
</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li><p>CPU 16根地址线 8根数据线。MREQ(低电平有效)作为访存控制信号。也就是低电平访问存储器，高电平访问IO</p>
</li>
<li><p>RAM：1K×4位、4K×8位、8K×8位。ROM：2K×8位、4K×8位 、8K×8位。</p>
</li>
<li><p>利用以上，要构成一个存储器，要求从6000H到67FFFH是系统程序区。从6800H到6BFFH是用户程序区。</p>
<ol>
<li><p>写出对应的二进制地址码(把16进制数转化为2进制)CPU有16位地址线，那么写的地址也要有16位A<del>0</del>到A<del>15</del>。</p>
<ul>
<li>起始地址(A<del>15</del>到A<del>0</del>)6000H：0 110 000 000 000 000</li>
<li>结束地址(A<del>15</del>到A<del>0</del>)67FFH：0 110 011 111 111 111</li>
</ul>
<blockquote>
<p>一共2K×8位，存放系统程序</p>
</blockquote>
<ul>
<li>起始地址(A<del>15</del>到A<del>0</del>)6800H：0 110 100 000 000 000</li>
<li>结束地址(A<del>15</del>到A<del>0</del>)6BFFH：0 110 101 111 111 111</li>
</ul>
<blockquote>
<p>1K×8位</p>
</blockquote>
</li>
<li><p>确定芯片的数量及类型</p>
<ul>
<li>系统程序区，应该选择ROM。选择1片 2K×8位的ROM</li>
<li>用户程序区，需要可读写，用RAM。选择2片1K×4位的RAM。通过片选信号，连接到一起。</li>
</ul>
</li>
<li><p>分配地址线</p>
<ul>
<li>A<del>10</del>A<del>0</del>接到2K×8位ROM的地址线(2K需要11根地址线)，剩余的作芯片选择信号。</li>
<li>A<del>9</del>A<del>0</del>分别接到两个1K×4位RAM的地址线(1K需要10根地址线)，剩余的作芯片选择信号。</li>
<li>教材要求使用138译码器。138译码器有三个输入C、B、A。八个输出端有一个低电平，其他都是高电平。138译码器要工作，三个控制端G<del>1</del>、G<del>2A</del>、G<del>2B</del>要有响应的信号输入才能工作。确定片选信号，CBA用哪些信号连接。</li>
<li>这里用A<del>13</del>连接C，A<del>12</del>连接B，A<del>11</del>连接A。这样如果138译码器进行工作，他的Y<del>4</del>如果是低电平的话选择就是第一个ROM，如果Y<del>5</del>有效选择的就是2片RAM(这里还要求A<del>10</del>有效才能，所以也加入片选)</li>
</ul>
<blockquote>
<p>138译码器是将二进制编码译成十进制输出，如CBA=111，那么输出端(Y<del>7</del>非)</p>
<p>这里的Y<del>4</del>就是100，Y<del>5</del>就是101</p>
</blockquote>
<ul>
<li><p>A<del>14</del>连接到G<del>1</del>(要求高电平有效)上。A<del>15</del>(低电平)连接到G<del>2A</del>上，或同时连G<del>2A</del>和G<del>2B</del>(都是低电平有效)。</p>
<blockquote>
<p>这里MREQ一定要使用，所以G<del>2A</del>和G<del>2B</del>不同时连接A<del>15</del></p>
</blockquote>
</li>
</ul>
</li>
<li><p>确定片选信号</p>
<ul>
<li>CPU还有一个MREQ信号连到片选信号上。CPU给出的地址不一定是主存中的地址，也可能是IO端口中端口的地址。</li>
<li>G<del>2B</del>连接MREQ</li>
</ul>
</li>
</ol>
<blockquote>
<p>因为ROM只读不能写，所以编程端(PD/Progr)接地</p>
<p>弹幕看到的(我自己搞不懂)：当输入101时，Y<del>5</del>高电，经Y<del>5</del>非门转化为低电。在Y<del>5</del>与非门连线上表现为低电，若A<del>10</del>输入低电，两个低电在与门输入前呗非门转化为高向与门输入，此时与门输出高电，被非门转化为低电，低电表示片选激活</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-28.jpg" alt></p>
</li>
<li><p>假设同前，要求最小4K为系统程序区，相邻8K为用户程序区</p>
<ol>
<li>写出对应的二进制地址码<ul>
<li>最小的4K，所以从全0开始。相邻8K，所以在系统程序区结束地址+1</li>
<li>起始地址(A<del>15</del>到A<del>0</del>)ROM：0 000 000 000 000 000</li>
<li>结束地址(A<del>15</del>到A<del>0</del>)ROM：0 000 111 111 111 111</li>
<li>起始地址(A<del>15</del>到A<del>0</del>)RAM<del>0</del>：0 001 000 000 000 000</li>
<li>结束地址(A<del>15</del>到A<del>0</del>)RAM<del>0</del>：0 001 111 111 111 111</li>
<li>起始地址(A<del>15</del>到A<del>0</del>)RAM<del>1</del>：0 010 000 000 000 000</li>
<li>结束地址(A<del>15</del>到A<del>0</del>)RAM<del>1</del>：0 010 111 111 111 111</li>
</ul>
</li>
<li>确定芯片的数量及类型<ul>
<li>一片4K×8位ROM</li>
<li>两片4K×8位RAM(这两片不是一组，各自有片选信号)</li>
</ul>
</li>
<li>分配地址线<ul>
<li>A<del>15</del>到A<del>12</del>做片选信号，A<del>11</del>到A<del>0</del>做地址线。CBA需要3个输入，那么选择A<del>14</del>到A<del>12</del>作为CBA输入到138译码器。</li>
<li>如果138译码器有效，3个控制端也要有效。G<del>1</del>高电平可以直接连接电源(VCC)或者把A<del>15</del>取反以后接到G<del>1</del>，G<del>2A</del>G<del>2B</del>要求低电平，可以把A<del>15</del>接到G<del>2A</del>或G<del>2B</del>上。只有MREQ信号有效访问的才是内存，MREQ低电平有效接到G<del>2A</del>或G<del>2B</del>上，</li>
</ul>
</li>
<li>确定片选信号(访存信号要包含其中，地址信号也要包含其中)</li>
<li>确定片选逻辑</li>
</ol>
<blockquote>
<p>片选信号中的地址信号+芯片输入的地址信号，才是全部的地址信号</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-29.png" alt></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>多做练习，不要拘泥于教材，片选信号非常灵活，只要题目上没有要求，完全可以用学过的数字逻辑知识(我没学过数电)画出片选逻辑。</p>
<p>但是对任何一个芯片来说，CPU的地址线要么输入到芯片中，要么出现在片选输入端。MREQ</p>
</blockquote>
<h6 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h6><p>信息保存在电容(或四管触发器)中，如果内存的电磁环境复杂，或者空间环境下受带电粒子的打击。可能会造成电容的充电放电或触发器的反转。存放的信息就可能出错。因此需要校验。</p>
<ul>
<li><p>合法代码集合(判断哪些代码出现就是错误)</p>
<ul>
<li>{000、001、010、011、100、101、110、111}检0位错、纠0位错。</li>
</ul>
<blockquote>
<p>000最后一位出错变成001，出错后的代码依然是集合的合法代码。计算机很难检查出错误</p>
</blockquote>
<ul>
<li>{000、011、101、110} 编码特点：1的个数是偶数个。检1位错、纠0位错。</li>
</ul>
<blockquote>
<p>可以检测出错误，但是无法知道哪位错</p>
</blockquote>
<ul>
<li>{000、111} 三倍冗余的方式存储，000表示0，111表示1。检1位错、纠1位错。</li>
</ul>
<blockquote>
<p>在计算机中，一位错误的情况超过百分之90所以很容易就能纠错</p>
</blockquote>
<ul>
<li>{0000、1111}四倍冗余的方式存储，0000表示0，1111表示1。检2位错、纠1位错。</li>
</ul>
<blockquote>
<p>无法判断1100，是11错还是00错。</p>
</blockquote>
<ul>
<li>{00000、11111}五倍冗余的方式存储，00000表示0，11111表示1。检2位错、纠2位错。</li>
</ul>
<p>编码的检测能力和纠错能力与<strong>任意两组合法代码之间 二进制位的最少差异数</strong>有关</p>
<blockquote>
<p>第一种情况差1位，第二种差2位……第五种差5位</p>
</blockquote>
</li>
</ul>
<p><strong>编码的最小距离</strong>：任意两组合法代码之间二进制位数的最少差异</p>
<p>编码的纠错、检错能力与编码的最小距离有关。<code>L-1=D+C(D≥C)</code>：L编码的最小距离，D检测错误的位数，C纠正错误的位数</p>
<blockquote>
<p>汉明码是具有一位纠错能力的编码</p>
</blockquote>
<blockquote>
<p>奇偶校验，计算机网络会学</p>
</blockquote>
<p><strong>汉明码</strong></p>
<ul>
<li><p>汉明码采用奇偶检验</p>
</li>
<li><p>汉明码采用分组校验</p>
</li>
<li><p>汉明码的分组是一个非划分方式</p>
<ul>
<li>划分方式：组与组之间没有重叠</li>
<li>非划分：组合组之间有交叉(有些位是多个组，有些位是一个组)</li>
<li>例：1234567划分为3组，每组一位校验位，共包括4位数据位。{1357、2367、4567} 1为偶数个校验结果应该为3个0<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-30.png" style="zoom:30%;"><ul>
<li>若校验结果P<del>3</del>P<del>2</del>P<del>1</del>：000。无差错</li>
<li>若校验结果P<del>3</del>P<del>2</del>P<del>1</del>：001。1差错</li>
<li>若校验结果P<del>3</del>P<del>2</del>P<del>1</del>：101。5差错</li>
<li>若校验结果P<del>3</del>P<del>2</del>P<del>1</del>：110。6差错</li>
<li>若校验结果P<del>3</del>P<del>2</del>P<del>1</del>：111。7差错</li>
</ul>
</li>
<li>校验位放在1，2，4前。2^i^位</li>
</ul>
</li>
<li><p>分组规则</p>
<ul>
<li>第一组：XXXX1</li>
<li>第二组：XXX1X</li>
<li>第三组：XX1XXi</li>
<li>第四组：X1XXX</li>
<li>第五组：1XXXX</li>
</ul>
<blockquote>
<p>如果第1个值和第3个值是1就是第五和第三组共有的</p>
</blockquote>
</li>
<li><p>汉明码的组成</p>
<ul>
<li><p>添加？位检测位。2^k^≥n+k+1i</p>
<blockquote>
<p>添加多少位检测位实际就是分成多少组。对每一组检测。检测位编码要指出哪一位错，或没有错。要传输的代码信息位n位，校验位k位。还有一种情况是没有错，所以总的是n+k+1</p>
</blockquote>
</li>
<li><p>检测位的位置。2^i^位</p>
</li>
<li><p>检测位取值。取值与该位所在检测”小组“种奇偶有关，我们一般采用偶校验</p>
</li>
</ul>
</li>
<li><p>各检测位C<del>i</del>承担的检测小组(汉明码分组规则)</p>
<ul>
<li>C<del>1</del>检测的g<del>1</del>小组包含第1，3，5，7，9，11位置的二进制编码位XX..X1</li>
<li>C<del>2</del>检测的g<del>2</del>小组包含第2，3，6，7，10，11位置的二进制编码位XX..1X</li>
<li>C<del>4</del>检测的g<del>3</del>小组包含第4，5，6，7，12，13位置的二进制编码位X..X1XX</li>
<li>C<del>8</del>检测的g<del>4</del>小组包含第8，9，10，11，12，13位置的二进制编码位X..X1XXX</li>
<li>……</li>
</ul>
</li>
</ul>
<blockquote>
<p>C<del>i</del>表示校验位</p>
</blockquote>
<ul>
<li>规律：<ul>
<li>g<del>i</del> 小组独占第 2^i－1^ 位 位置的二进制编码为0…10…0 </li>
<li>g<del>i</del> 和 g<del>j</del> 小组共同占第 2^i－1^ + 2^j－1^ 位 位置的二进制编码为0…010…010…0 </li>
<li>g<del>i</del>、g<del>j</del> 和 g<del>l</del> 小组共同占第 2^i－1^ + 2^j－1^ + 2^l－1^ 位 位置的二进制编码为0…010…010…010…0</li>
</ul>
</li>
</ul>
<ul>
<li><p>例：求0101按”偶校验“配置的汉明码</p>
<ul>
<li>解：n=4 根据2^k^≥n+k+1 得k=3</li>
<li>1，2，4位置放校验位。</li>
<li>C<del>1</del>包括1，3，5，7有两个1，所以C<del>1</del>取0。C<del>2</del>包括2，3，6，7有1个1，所以C<del>2</del>取1。C<del>4</del>包括4，5，6，7有两个1所以取0.</li>
<li>0101的汉明码：0100101</li>
</ul>
</li>
<li><p>汉明码的纠错过程</p>
<ul>
<li>首先在接收方收到数据后，发送方和接收方要有协议。要说明由汉明码编码采用偶校验，根据接收到的数据的位数来判断，编码被编为多少组，对每一组都要进行校验。</li>
<li>每组都会形成新的检测位P<del>i</del>，其位数与增添的检测位有关</li>
<li>以K=3为例。<ul>
<li>P<del>1</del>为1、3、5、7，半加操作或异或操作得到P<del>1</del>.第一组中1的个数应该为偶数个，P<del>1</del>应该等于0</li>
<li>P<del>2</del>为2，3，6，7，也一样</li>
<li>P<del>4</del>为4，5，6，7，也一样</li>
</ul>
</li>
<li>例：已知接收的汉明码为0100111(按配偶原则配置)<ul>
<li>P<del>1</del>为1，3，5，7=0。无错</li>
<li>P<del>2</del>为2，3，6，7=1，有错</li>
<li>P<del>4</del>为4，5，6，7=1，有错</li>
<li>P<del>2</del>、P<del>4</del>都含有6所以6出错，7虽然也含有但是P<del>1</del>有7所以无错</li>
</ul>
</li>
<li>例：写出按偶校验配置的汉明码0101101纠错过程<ul>
<li>P<del>4</del>为4，5，6，7=1</li>
<li>P<del>2</del>为2，3，6，7=0</li>
<li>P<del>1</del>为1，3，5，7=0</li>
<li>P<del>4</del>P<del>2</del>P<del>1</del>=100 第4位错，校验码错误可以不纠</li>
</ul>
</li>
<li>练习 按奇配置0011的汉明码<ul>
<li>答案：0101011</li>
<li>思路：分组方式是相同的，只不过增加了一位校验位，增加了以后使得这一组中1的个数是奇数。</li>
</ul>
</li>
<li>思考：汉明码的最小距离是多少。至少是3。 奇偶配置纠错过程有什么区别</li>
</ul>
</li>
</ul>
<blockquote>
<p>奇偶校验举例：00100011，在最前面加上一位校验位1，变为100100011。1的个数变为偶数个，如果1的个数为奇数个，那么代码错误。X</p>
<p>汉明码就是分组进行奇偶校验，更加精细。</p>
<p>如：将00100011分为两组，前四位前加1后四位前加0。变为10010 00011。</p>
</blockquote>
<h6 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h6><p>存储墙：存储器太慢，CPU得不到所需要的指令、数据就只能进行空等。</p>
<ul>
<li>采用高速器件</li>
<li>采用层次结构 Cache—主存</li>
<li><strong>调整主存结构</strong></li>
</ul>
<p><strong>调整主存结构</strong></p>
<ul>
<li><p>单体多字系统：把存储器的存储字长加长</p>
<ul>
<li>比如CPU的字长16位，存储器的存储字长可以设成64位。CPU每一次访问都访问出4个机器字，每一个机器字都可以是指令或长度为16的数据。CPU一次取出放到数据寄存器中，再用的时候可以直接从数据寄存器中读取</li>
<li>缺点<ul>
<li>因为数据寄存器有48位，数据要从单字长寄存器先写入数据寄存器再写入存储器，写入16位时修改到存储器时会造成48位被修改，导致数据错误。如果要让存储器完成16位的单字长的写入，那在存储器内部还要用硬件实现这个功能，会导致存储器复杂化。</li>
<li>如果要取的数据或指令不是连续存放在相邻的地址中，或不是连续存放在一个存储器中。比如第一条就是跳转指令，而且跳转幅度大。那么其他三条就无效。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-31.png" alt></p>
</li>
<li><p>多体并行系统</p>
<ul>
<li><p>高位交叉(顺序编址)</p>
<ul>
<li>前几位选定存储体，后面是存储体内的地址。四个存储体并行工作。</li>
<li>问题<ul>
<li>如果程序的指令是连续的存放在一个存储体，该存储体不断被访问，其他存储体空闲。</li>
</ul>
</li>
<li>这种方式实际就是前面讲过的存储器容量的扩展。这种方式更适合存储器容量的扩展并不适合提高带宽</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-32.png" alt></p>
</li>
<li><p>低位交叉(各个体轮流编址)</p>
<ul>
<li>横向编码。地址的后几位对同一个存储器来说是一样的。</li>
<li>在讲总线的时候讲过类似的，叫分离式通信</li>
<li>特点：不改变存取周期的前提下，增加存储器的带宽</li>
<li>以流水线方式存取，一个存储器启动就启动下一个依次。</li>
</ul>
<blockquote>
<p>设四体低位交叉存储器，存取周期为<em>T</em>，总线传输周期为<em>τ</em>，为实现流水线方式存取，应满足 <em>T</em> ＝ 4<em>τ</em>。连续读取 4 个字所需的时间为 <em>T</em>＋(4 －1)τ</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-33.png" alt>)<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-34.png" alt>)<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.2-35.png" alt></p>
</li>
<li><p>高性能存储芯片</p>
<ul>
<li><p>SDRAM(同步DRAM)：之前讲过的动态RAM都是异步。</p>
<ul>
<li>在系统时钟的控制下进行读出和写入 CPU 无须等待</li>
<li>CPU和存储器之间在给定的时间点上必须开始或完成给定的操作，这样存储器的速度和CPU的速度就可以保持一致</li>
</ul>
</li>
<li><p>RDRAM</p>
<ul>
<li>由 Rambus 开发，主要解决 存储器带宽 问题</li>
</ul>
<blockquote>
<p>有兴趣了解查资料，书上不是很透彻</p>
</blockquote>
</li>
<li><p>带 Cache 的 DRAM</p>
<ul>
<li>在 DRAM 的芯片内 集成 了一个由 SRAM 组成的Cache ，有利于 猝发式读取</li>
</ul>
<blockquote>
<p>书上有个图给出了带Cache的DRAM结构，核心是存储阵列。存储阵列上标识的2048×512×4。实际是2048行×2048列，列被分为4组。行选信号11条用于寻找2048行，列选信号9条，每个列选信号会选中四列，在不同组中。所以是512个存储单元，每个单元长度为4</p>
</blockquote>
<blockquote>
<p>工作过程：CPU给出一个地址访问存储器，到了存储器后，存储器先将该地址和上一次访问的行地址进行比较，如果相等说明上一次访问也是这行，那么这行已经被写到相应的cache当中，可以用列选信号，直接在cache中选中指定的存储单元。如果不一样，那么新的行要写入cache以便于下次使用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="4-3高速缓冲存储器"><a href="#4-3高速缓冲存储器" class="headerlink" title="4.3高速缓冲存储器"></a>4.3高速缓冲存储器</h3><h6 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6><p>Cache为了避免CPU”空等”现象。在CPU和主存间加入缓存。要想充分发挥Cache的能力必须要保障CPU访问的数据或指令大多数情况下都能在Cache中取得。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-1.png" alt></p>
<p>程序的局部性原理：①时间的局部性(当前正在使用的指令和数据在不久将来还会使用到) ②空间的局部性(当前正在使用的指令和数据在不久将来相邻的指令和数据就可能使用到)</p>
<blockquote>
<p>把正在使用的指令和数据放入Cache，同时还需要把相邻的指令和数据放入Cache</p>
</blockquote>
<p><strong>Cache的工作原理</strong></p>
<p><strong>①主存和缓存的编址</strong></p>
<ul>
<li><p>Cache和主存之间的信息交换单位叫做块。</p>
</li>
<li><p>M&gt;&gt;C</p>
</li>
<li><p>如果主存或Cache分为若干块的话，CPU给出内存地址可以分为两部分一部分是块内偏移地址位数决定块大小(比如一个块包含16字节并且内存的编制单位是字节，那么块内地址部分就是4位)，剩余的部分就是主存的块的编号。Cache地址也分成了块内地址和缓存块号，在实际应用中Cache地址意义并不大，也不需要真正地形成Cache地址。</p>
</li>
<li><p>内存块和Cache块大小是相同的。一个块在内存和Cache之间传送是整体进行传送的，字节顺序不会发生任何变化。所以内存块内地址和Cache块内地址值是完全相同的。</p>
</li>
<li><p>Cache上有标记，是用来标记主存块和Cache块的对应关系。</p>
<ul>
<li>若CPU给出内存地址，希望在Cache访问到该数据，首先要确定数据是否送到Cache中，拿给出地址的主存块号，和Cache中的标记比较，如果相等并且Cache快有效，就可以字节获取。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-2.png" alt></p>
<p><strong>②命中与未命中</strong></p>
<p>命中：主存块调入缓存(CPU能在缓存中获取相应的数据或指令)</p>
<p>未命中：主存块未调入缓存(CPU不能在缓存中获取相应的数据或指令，必须要主存中去获取)</p>
<p>用 <strong>标记记录</strong>与某缓存块建立了对应关系的<strong>主存块号</strong></p>
<p><strong>③Cache的命中率</strong></p>
<p>概念：CPU 欲访问的信息在 Cache 中的 比率</p>
<p>命中率与Cache的容量与块长(一般4到8个字)有关(还有一些不是课程重点)</p>
<p>块长取一个存取周期内从主存调出的信息长度</p>
<blockquote>
<p>块太大会导致块数少，而每块中可能有一部分数据是无用的，从而导致浪费。</p>
<p>块的大小与4.2节中提高访存速度的措施中多体交叉有直接关系。</p>
</blockquote>
<p>例(一个存储字64位)</p>
<ul>
<li>CRAY_1 16体交叉 块长取16个存储字</li>
<li>IBM 370/168 4体交叉 块长取4个存储字</li>
</ul>
<p><strong>④主存系统的效率</strong></p>
<p>效率 <em>e</em> 与 命中率 有关。命中率是最关键的。</p>
<p>e= (访问Cache的时间)/(平均访问时间)× 100%</p>
<blockquote>
<p>平均访问时间内包含访问Cache和内存的时间</p>
</blockquote>
<p>设Cache 命中率 为 h，访问Cache的时间为t<del>c</del>，访问主存的时间为t<del>m</del></p>
<p>则 e = (t<del>c</del>)/(h×t<del>c</del>+(1-h)×t<del>m</del>) × 100%</p>
<blockquote>
<p>从时间上看访问Cache和访问内存是并行进行的。如果是在Cache中访问后没找到再去访问内存，那么公式就会变化。</p>
</blockquote>
<p><strong>Cache的基本结构</strong></p>
<p>工作过程：CPU要访问内存，给出的地址包括了块号和块内地址。由于Cache是以块为单位进行数据传送的，所以块内地址可以直接送到Cache的地址。然后利用块号在“主存Cache地址映射变换机构”中确认是否命中，如果命中给出当前内存块保存在哪个Cache块中。如果未命中需要查询Cache是否还有空间能够装入这个主存块，如果有的话访问主存把主存块装入Cache。如果没有主存块能装入的Cache的位置都是满的就要启用”Cache替换机构“，由它根据替换算法决定Cache中哪一个块从Cache中踢出，写回到主存或者直接作废。把主存中要用的块写入Cache。</p>
<p>映射规则：主存中的一个块如果要放入Cache中，它可以放入Cache哪个块或哪些块中</p>
<p>变换：将主存的块号或地址转化成响应的Cache的块号或地址</p>
<p>主存和Cache之间的直接通路，用来完成信息交换。</p>
<blockquote>
<p>有些电脑为了速度，发生未命中的情况，主存会通过数据总线先把CPU需要的数据送到CPU中同时这个块在Cache和主存间传送。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-3.png" alt></p>
<p><strong>Cache的读写操作</strong></p>
<p>读操作：访问主存取出信息送CPU和看Cache是否满 是<strong>同时</strong>执行的</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-4.png" alt></p>
<p>写操作：</p>
<ul>
<li>写操作会造成Cache和主存不一致(比如值写了Cache没写主存)。因此一定要解决Cache和主存的<strong>一致性</strong>问题<ul>
<li>写直达法(写通过法 Write – through)<ul>
<li>写操作时数据既写入Cache又写入主存</li>
<li>写操作时间就是访问主存的时间，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现</li>
<li>优点：使内存和Cache一直保持一致</li>
<li>缺点：可能会造成CPU对同一个内存单元反复地写(比如累加，每次加都要访问)</li>
</ul>
</li>
<li>写回法（Write – back） <ul>
<li>写操作时只把数据写入 Cache 而不写入主存当 Cache 数据被替换出去时才写回主存</li>
<li>写操作时间就是访问 Cache 的时间，Cache块退出时，被替换的块需写回主存，增加了Cache的复杂性</li>
<li>缺点：无法保证实时一致性，也可能造成多处理器的情况下，每个处理器都有自己的Cache，在其中都有副本，这就会导致各个副本之间一致性问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Cache的改进</strong></p>
<ul>
<li><p>增加Cache的级数</p>
<ul>
<li>片载(片内)Cache</li>
<li>片外Cache</li>
</ul>
<blockquote>
<p>现代处理器都是多核的，每个核都有自己的Cache。多核也有共用的Cache</p>
</blockquote>
</li>
<li><p>统一缓存和分立缓存</p>
<ul>
<li>把指令和数据分开。指令Cache和数据Cache，与指令执行的控制方式有关。可以避免在在流水的过程中造成资源冲突。<ul>
<li>Pentium 8K 指令 Cache 8K 数据 Cache</li>
<li>PowerPC620 32K 指令 Cache 32K 数据 Cache</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="Cache—主存的地址映射"><a href="#Cache—主存的地址映射" class="headerlink" title="Cache—主存的地址映射"></a>Cache—主存的地址映射</h6><p>如果主存中任意一个块，可以加载到cache中哪个块</p>
<p><strong>直接映射</strong></p>
<p>概念：主存中任意一个给定的块，只能映射到或只能装载到某一个指定的Cache块中</p>
<p>具体做法：拿Cache存储体作为一个尺子，去度量主存储体，根据主存储体和Cache存储体大小，把主存储体划分成若干个以Cache存储体相等的区，每个区的大小和Cache存储体的大小是相同的，每个区中包含的字块数和Cache存储体当中包含的字块数是相等的，这样的话每个区里的字块进行编号的时候都可以从0号开始编写，一直编导2^c-1^，在进行映射的时候任何一个区的第零块只能放入Cache存储体字块0中，任何一个区的第一块只能放到Cache存储体的第一块中。</p>
<blockquote>
<p>存储体字块取模运算</p>
<p>如：主存的任何区的第0块，只能放在cache的第0块</p>
</blockquote>
<p>这种方法如果CPU给出一个地址(区号：主存字块标记、块号：Cache字块地址、块内偏移地址：字块内地址)。由于Cache中字块0可能为主存储体任意区的字块0，所以要将区号写入标记中(t位)，t位表示对应主存哪个区</p>
<ul>
<li>优点：结构简单速度快</li>
<li>缺点：Cache利用率低(如果其它Cache空闲，但由于字块号必须对应就可能导致利用率低)</li>
</ul>
<blockquote>
<p>每个缓存块 i 可以和 若干 个 主存块 对应</p>
<p>每个主存块 j 只能和 一 个 缓存块 对应</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-5.png" alt></p>
<p><strong>全相联映射</strong></p>
<p>全相联：主存中任何一个块可以被放入Cache任意一个块中。任何一个块要从主存调入Cache，只要Cache有空余部分就可以调入。</p>
<p>如果给出一个主存地址，主存字块中的标记需要和Cache块中所有标记进行比较，如果有相等就命中，如果没有就可能发生替换。</p>
<ul>
<li>缺点：<ul>
<li>这个比较是需要同时进行，电路比较复杂，速度比较慢。</li>
<li>需要比较的位数比较长，比较器的长度也会比较长。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-6.png" alt></p>
<p><strong>组相联映射</strong></p>
<p>先将Cache分成块，再将块分为组(每组可以2块、4块或8块)。主存的字块也进行分区，每个区分块数和Cache的组数相同。每个区的第0块可以放入Cache中第0组的任意一位置。也就是说主存中每个区内的编号，在区内编号直接决定了可以放入Cache的哪个组。</p>
<p>如果只分每组只分两块，可以有两个比较器，比较标记，可以并行进行。</p>
<ul>
<li>优点：<ul>
<li>和直接相连相比一个块有多个位置，即使一个被占用，另一个如果是空的依然可以使用。</li>
<li>和全相连相比，如果去找某个内存卡是不是被调入Cache中，只需要确定在某个区的标号，然后找到给定的组，再去比较组内块的标记。</li>
</ul>
</li>
</ul>
<blockquote>
<p>复杂度可以接受，速度够快，Cache利用率高。是现代计算机常用方法。</p>
<p>如果只有一组，组相联就变为全相联。如果组相联每组只有一块，就变为直接相连。</p>
<p>这三种相连方式在多层次的Cache结构中，用途不一样。靠近CPU的层次要求高速可以采用直接相连或者路数(每组块数)比较少的组相连。中间层次采用组相连。里CPU远可以采用全相联的方式。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-7.png" alt></p>
<h6 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h6><p>当发现cache中可以放内存块的地方都被占用，就使用替换算法</p>
<ul>
<li>先进先出(FIFO)算法<ul>
<li>先进的块，先被替换</li>
</ul>
</li>
<li>近期最少使用(LRU)算法</li>
</ul>
<h3 id="4-4辅助存储器-非重点"><a href="#4-4辅助存储器-非重点" class="headerlink" title="4.4辅助存储器(非重点)"></a>4.4辅助存储器(非重点)</h3><p>主要作用：用来保存程序、数据、文档、音像资料。</p>
<p>特点：不直接与CPU交换信息。</p>
<blockquote>
<p>程序要运行必须调到主存当中，CPU才能读写</p>
</blockquote>
<p><strong>磁表面存储器(最常见)的技术指标</strong></p>
<ul>
<li><p>记录密度</p>
<ul>
<li>道密度D<del>t</del>：硬盘在径向方向上单位长度有多少个此道</li>
<li>位密度D<del>b</del>：单位长度的磁道保存了多少位二进制信息</li>
</ul>
<blockquote>
<p>磁盘每个磁道都是同心圆，越往外位密度越低</p>
</blockquote>
</li>
<li><p>存储容量：C = n × k × s</p>
</li>
<li><p>平均寻址时间：寻道时间+</p>
<ul>
<li>寻道时间：读写头在硬盘表面找到指定的磁道</li>
<li>等待时间：找到后读写头停止运动，磁盘旋转，等待给定的扇区旋转到磁头下。</li>
<li>辅存的速度<ul>
<li>寻址时间</li>
<li>磁头读写时间</li>
</ul>
</li>
<li>数据传输率：D<del>r</del> = D<del>b</del> × V(旋转速度)</li>
</ul>
</li>
<li><p>误码率：出错信息位数与读出信息的总位数之比</p>
</li>
</ul>
<p><strong>磁记录原理和记录方式</strong></p>
<p>磁写原理：线圈上通上不同方向的电流，在铁线内部就会产生不同方向的磁通，磁会对载磁体表面的磁层进行磁化，磁化方向的不同区分0和1。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-8.png" alt></p>
<p>磁读原理：磁场经过读写头切割磁极线，在读线圈上产生电流。磁通发生变化，电势也会发生变化，根据电势变化确认磁载体中保存的0和1.</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-9.png" alt></p>
<p><strong>硬磁盘存储器</strong></p>
<ul>
<li><p>硬磁盘存储器的类型</p>
<ul>
<li>按磁头是否固定划分：<ul>
<li>固定磁头：盘片只会旋转不会平移，每个磁道都有一个磁头。速度快，不需要磁头径向移动，只要等待指定扇区移动</li>
<li>移动磁头：常用的磁盘</li>
</ul>
</li>
<li>按硬盘的盘片是否可更换<ul>
<li>可换盘：可以更换盘片</li>
<li>固定盘：常用，不能取出一旦取出沾上灰尘后，盘片就报废了</li>
</ul>
</li>
</ul>
</li>
<li><p>硬磁盘存储器结构</p>
<ul>
<li>磁盘控制器：相当于主机与磁盘驱动器之间的接口，连接磁盘驱动器，由磁盘驱动器驱动盘片的旋转磁头的移动以及数据的读写。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-10.png" alt></p>
<ul>
<li><p>磁盘驱动器结构：</p>
<ul>
<li>磁盘组(核心)，信息保存在磁盘组盘面上，固定在主轴上，下面是传动机构。传动机构带动主轴带动各个盘片旋转。磁盘表面为磁头，一旦磁盘高速旋转，磁头就会悬浮在磁盘表面。磁头可以沿着磁盘的径向进行移动。移动是由小车(图上的长方形 上下4个⚪)来控制的，小车的移动推动磁头在磁盘表面，小车由电机控制。</li>
<li>工作流程：磁盘控制器会送来目标磁道的信息，到底磁头要移动到哪个磁道。根据目标此道的信息由音圈电机控制小车，小车左右移动来移动读写头。</li>
</ul>
<blockquote>
<p>这个控制是非常精确的，音圈电机会测量小车的移动速度会送控制端，同时对读写头也是有位置控制。</p>
</blockquote>
<blockquote>
<p>数据控制在图上没有体现，主要是为了完成数据的转化和读写控制。</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-11.png" alt></p>
<ul>
<li>磁盘控制器：<ul>
<li>接收主机发来的命令，转换成磁盘驱动器的控制命令</li>
<li>实现主机和驱动器之间的数据格式转换</li>
<li>控制磁盘驱动器读写</li>
<li>实质上磁盘控制器 是 主机与磁盘驱动器之间的 接口。这个接口对主机通过总线进行连接、同时直接对硬盘进行控制</li>
</ul>
</li>
<li>盘片：由硬质铝合金材料制成</li>
</ul>
</li>
</ul>
<p><strong>软磁盘存储器</strong></p>
<p>实际上，软盘已经退出市场</p>
<table>
<thead>
<tr>
<th></th>
<th>硬盘</th>
<th>软盘</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>磁头</td>
<td>固定、活动、浮动(在磁盘表面和读头之间有高速的空气流进行隔开)</td>
<td>活动、直接接触盘片</td>
</tr>
<tr>
<td>盘片</td>
<td>固定盘、盘组大部分不可换</td>
<td>可换盘片(塑料的，外壳也是塑料的，需要的情况下可以打开外壳更换盘片)</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>环境</td>
<td>苛刻(盘的表面落一粒灰尘都会对读写头造成损失)</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>软盘的磁头都是可以活动的，磁头可以通过读写口在软磁盘表面进行移动，找到指定的磁道和扇区进行读写。</p>
</blockquote>
<blockquote>
<p>软磁盘比较容易损坏。</p>
</blockquote>
<p>中间是主轴孔，盘片想转起来，驱动器的主轴会压在这个空，然后驱动器旋转，盘片跟着旋转。</p>
<p>写保护口上有一个小的塑料块，可以上下推。如果写保护了，就只能读不能写。</p>
<p>读写磁头访问槽：中间直，两边圆。这个孔一般由金属片保护起来，只有读写的时候金属片打开，磁头通过读写口和盘片本身进行接触，来读写内容。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.3-12.png" alt></p>
<p><strong>光盘存储器</strong></p>
<p>采用光存储技术 利用激光读写</p>
<ul>
<li>第一代光存储技术：采用非磁性介质 不可擦写</li>
<li>第二代光存储技术：cai用磁性介质 可擦写</li>
</ul>
<p>原理：</p>
<ul>
<li>只读型、只写一次型：热作用（物理或化学变化）</li>
<li>可擦写光盘：热磁效应</li>
</ul>
<h2 id="五、输入输出系统"><a href="#五、输入输出系统" class="headerlink" title="五、输入输出系统"></a>五、输入输出系统</h2><h3 id="5-1概述"><a href="#5-1概述" class="headerlink" title="5.1概述"></a>5.1概述</h3><p><strong>输入输出系统的发展概述</strong></p>
<ul>
<li><p>早期：计算机数量少，应用少，外部设备少</p>
<ul>
<li>采用分散连接的方式，每个设备都有专门的控制电路。这些控制电路甚至和CPU的控制电路设计在一起。</li>
<li>CPU和I/O <strong>串行</strong>工作 程序查询方式：IO在数据输入输出时，CPU必须允许响应程序或者等待</li>
<li>增加和减少外部设备很困难</li>
</ul>
</li>
<li><p>接口模式和DMA阶段</p>
<ul>
<li>采用总线连接的方式，IO设备通过接口连接在总线上，一个总线可以连接多个设备，总线另外一端与主机相连</li>
<li>CPU和I/O设备 <strong>并行</strong>工作 出现了两种信息交换的传输控制方式：<ul>
<li>中断方式</li>
<li>DMA方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>在信息传输过程中，或者完成之后，CPU仍要参与部分信息传输的处理工作，为了使CPU和IO的工作能并行，或者是输入输出系统的数据输入输出的管理控制，尽可能的从主机中独立出来，就出现了具有通道结构的阶段</p>
</blockquote>
</li>
<li><p>具有通道结构的阶段</p>
<ul>
<li>通道可以看作是一种简单的处理器或是小型的功能更强的DMA控制器，能执行通道程序，通道有自己的指令系统，通道通过执行通道程序可以控制连接在连接上的IO设备和主机之间直接进行信息传输</li>
</ul>
</li>
<li><p>具有I/O处理机的阶段</p>
<ul>
<li>I/O处理机独立性更强，I/O处理机可以是专用的处理器，在大型计算机中，可以用现代微处理器直接作为I/O处理机控制I/O设备的工作。或是在一些大型计算机中直接采用和主机当中处理器完全相同的处理器来作为I/O处理机。甚至在没有I/O设备工作的时候I/O处理机可以作为主机的处理器完成相应的计算任务。</li>
</ul>
</li>
</ul>
<p><strong>输入输出系统的组成</strong></p>
<p>I/O软件：</p>
<ul>
<li>I/O指令：CPU指令的一部分<ul>
<li>组成：操作码+命令码+设备码<ul>
<li>I/O指令的操作码相当于I/O指令的标志，它表示第二个指令是I/O指令</li>
<li>命令码：相当于CPU指令集中普通指令的操作码，指出了对I/O设备怎样的操作，比如查询，输入，输出等</li>
<li>设备码：I/O设备的编码，也就是I/O设备的地址或I/O设备中某一个寄存器的地址。这些寄存器我们称之为I/O的端口</li>
</ul>
</li>
<li>程序将它编写到应用程序中，CPU执行这些I/O指令，控制外部设备，使得外部设备和CPU和主机之间能协调的进行工作</li>
</ul>
</li>
<li>通道指令：通道自身的指令<ul>
<li>通道是一种小型的DMA处理机，能够实现I/O设备和主机之间直接进行信息传送。通道有自己的控制器，有的通道还有自己的存储器。</li>
<li>工作流程：通道能执行由通道指令组成的通道程序。通常情况下，编程人员在应用程序中，为了调用外部设备，使其工作，应用程序中需要增加广义I/O指令。广义I/O指令要指出参加数据传输的IO设备，数据传输主存的首地址，传输数据的长度，传输的方向(是向I/O设备传输还是向主存传输)。操作系统根据广义I/O指令给出的参数以及要求的操作会编写由通道指令组成的通道程序，并且把通道程序放入内存或是通道自己内存的指定位置，之后启动通道进行工作。通道拿到通道程序的首地址后就可以执行通道程序，控制I/O设备进行相应的输入和输出工作。</li>
<li>通道指令指出数组的首地址、传送字数、操作命令</li>
<li>这些指令一般比较长：如 IBM/370 通道指令为 64 位</li>
<li>通道下可以带若干个子通道，子通道可以并行工作，每个子通道可以连接多个设备控制器。每个设备控制器可以连接多个设备</li>
</ul>
</li>
<li>I/O硬件<ul>
<li>设备、I/O接口</li>
<li>通道方式：设备、设备控制器、通道</li>
</ul>
</li>
</ul>
<p><strong>I/O设备与主机的联系方式</strong></p>
<p>I/O设备编制方式</p>
<ul>
<li><p>统一编制 用取数、存数指令直接对I/O设备进行访问，不需要单独的指令</p>
<ul>
<li>就是把I/O设备的地址看成内存地址的一部分。</li>
<li>比如内存地址为1M，那么1M地址中低地址或高地址64k拿出作为I/O设备的地址或端口地址，如果输入输出指令或访存指令他的地址码部分的地址，落入I/O地址部分，这次输入或输出操作实际是对I/O设备进行的。</li>
</ul>
<blockquote>
<p>指令集相对简单，如果内存系统的编址空间大的话就可以采用统一编址方式</p>
</blockquote>
</li>
<li><p>不统一编址(单独编址) 有专门的I/O指令</p>
<ul>
<li>在内存地址空间外，专门设置一个地址空间。</li>
<li>如：内存的地址空间20位寻址空间1M，对外部设备编址时他的地址空间是从16个0到16个1，就是64K为了区分一条指令是对内存操作还是对I/O设备操作，在单独编制的计算机当中，输入输出指令不能再采用计算机系统原有的取数或存数指令，用专用的I/O指令进行控制。</li>
</ul>
</li>
</ul>
<p>设备选址：用设备选择电路识别是否被选中</p>
<blockquote>
<p>只要把CPU给出的地址和设备中保存的地址进行比较，如果两者相同，就选中。</p>
</blockquote>
<p>传送方式(第三章有介绍)</p>
<ul>
<li>串行：一位一位传输，传输速度慢，但适合远程传输</li>
<li>并行：同时多位在多条数据线上传输，数量通常是8的倍数</li>
</ul>
<p>联络方式</p>
<ul>
<li><p>立即响应：对一些结构简单，状态数量少，接收到数据直接进行显示。</p>
</li>
<li><p>异步工作采用应答信号(指I/O接口与I/O设备之间)</p>
<ul>
<li>并行<ul>
<li>CPU和接口之间一般都是异步</li>
<li>I/O接口与I/O设备之间要有多条的类似总线结构的数据线，来完成数据并行的输入和输出。双方之间要采用应答信号。<ul>
<li>输入输出工作流程：I/O设备要接收数据，I/O端口把数据准备好以后通过“Ready”信号告诉I/O设备，端口中的数据准备好了，I/O设备对端口中的数据进行读取并且给出应答”Strobe”信号。如果是输入I/O设备把数据通过I/O接口输入到主机中。I/O接口中数据块缓冲器一旦空了，就会向I/O设备发送“Ready”信号告诉I/O设备可以向I/O接口中发送数据，I/O设备向I/O接口发送数据并且给出应答信号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.1-1.png" alt></p>
<ul>
<li>串行<ul>
<li>起始位9.09ms低电平结束之后是若干位的数据位，数据位结束后给出2位高电平终止位</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.1-2.png" alt></p>
<ul>
<li>同步工作采用同步时标：必须有定宽定距的时标</li>
</ul>
</li>
</ul>
<p>I/O设备与主机的连接方式(在发展概述早期有介绍)</p>
<ul>
<li><p>辐射式连接(分散连接)：增加一个I/O设备就需要在主机中增加一套控制电路</p>
<ul>
<li>增加和删除设备麻烦</li>
<li>可移植性差</li>
</ul>
</li>
<li><p>总线连接： </p>
<ul>
<li>外部设备通过接口和主机连接，接口能够向外部设备传送主机的控制命令，可以向主机传送外部设备的状态信息，同样接口也可以完成设备传输，外部设备的输入数据可以先缓存接口中，完成数据的格式转化等操作然后输入到主存。或者主机的数据在接口换算，经过格式的变化等处理传输给外部设备。</li>
<li>便于增删设备</li>
</ul>
</li>
</ul>
<p><strong>I/O设备与主机信息传送的控制方式</strong></p>
<ul>
<li><p>程序查询方式：最早的，CPU和外设采用串行的方式进行工作</p>
<ul>
<li>工作流程：CPU在程序中执行读操作指令，向I/O设备发出读命令，CPU开始读取I/O的状态(实际是I/O接口中状态触发器或状态标志的一个值)，看数据是否准备好，如果没有跳转指令CPU会不断地反复的去读状态标志如果出错进入出错处理，如果准备就绪，这时CPU可以从接口中读出一个数据(该数据可以是一个字节也可以是一个字)，读出后放入CPU的某个寄存器，然后再把寄存器中的数据写入内存指定位置，再判断传输是否结束，如果没有结束还会通过程序发出读指令。</li>
<li>内存和I/O要想数据交换必须通过CPU</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.1-3.png" alt></p>
</li>
<li><p>程序中断方式：CPU与I/O设备之间部分并行工作，也就是I/O设备，CPU还可以执行自己的程序</p>
<ul>
<li><p>I/O工作两个阶段：自身准备阶段、与主机交换信息。</p>
</li>
<li><p>在自身准备阶段CPU不查询，只有当外部设备和主机间开始进行信息交换，CPU会暂停现行程序</p>
</li>
<li><p>工作流程：在执行程序过程中碰到I/O指令，执行过程中，启动I/O设备进行数据准备。然后继续执行原来的程序。外部设备接收到命令开始进行数据准备，准备好接受或者输入数据后，会向CPU提出中断请求，让CPU停止对当前程序的执行，转而和I/O设备进行数据交换。</p>
</li>
<li><p>中断流程：CPU发出读指令，I/O和CPU的工作并行进行。CPU继续原来的程序，I/O开始设备的准备工作一直到准备就绪，I/O设备向CPU发出中断请求，CPU读取I/O状态，确定哪个设备，检查状态是否出错，如果出错就出错处理，如果没有就在I/O接口中读一个字送到CPU，然后写入内存再判断输入输出工作是否完成，如果没完成CPU向I/O发出下一个字的读指令。如果完成就结束</p>
</li>
</ul>
<blockquote>
<p>收到中断请求信号，执行完当前指令后，将程序断点等进行保存，跳转到中断服务程序，通过终端服务程序来完成输入和输出操作。再转回到原来程序</p>
</blockquote>
<blockquote>
<p>恢复和中断都需要指令来完成，需要时间。</p>
</blockquote>
</li>
<li><p>DMA 方式：使外部设备和内存之间可以建立直接的连接，由DMA控制器或DMA接口直接控制外部设备和内存之间进行内部交换。</p>
<ul>
<li>主存和I/O之间有一条直接数据通道，不需要中断现行程序。采用周期挪用(周期窃取)的方式</li>
<li>DMA控制器控制主存和外设之间信息交换，一定会用到总线包括地址线‘、控制线、数据线。如果DMA利用的时候，CPU就要让出来，让出一个存取周期的时间。</li>
<li>工作流程：CPU在执行主程序中碰到了I/O指令，CPU发出启动I/O指令，CPU继续自己的操作，I/O设备在DMA控制器的控制下完成数据准备，准备好后要进行数据传输，由DMA控制器发出DMA请求，占用总线的使用权，占用一个存取周期，进行外部设备和内存之间的数据交换。结束后归还总线使用权，CPU可以对内存进行数据交换。</li>
</ul>
<blockquote>
<p>CPU虽然不能使用系统总线，不能使用内存，但可以执行。比如现代处理器不需要CPU每执行一条指令就从内存取指令，在指令执行之前若干条指令被预取到缓存当中了。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.1-5.png" alt></p>
</li>
</ul>
<p>通道方式、I/O处理机方式可以看计算机系统结构的教材，往往有介绍。</p>
<p><strong>三种工作效率的比较</strong></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.1-6.png" alt></p>
<p>还有通道方式、IO处理机方式放到后面讲</p>
<h3 id="5-2外部设备-简要介绍"><a href="#5-2外部设备-简要介绍" class="headerlink" title="5.2外部设备(简要介绍)"></a>5.2外部设备(简要介绍)</h3><p><strong>概述</strong></p>
<p>外部设备通过接口电路和主机进行连接。</p>
<p>外部设备包括：设备控制器，机、电、磁、光部分。 </p>
<p>外部设备通过I/O接口进行数据交换，主机通过I/O接口向设备控制器传输控制命令，主机还通过I/O接口读取外部状态。</p>
<p>外部设备分类(3大类)</p>
<ul>
<li>人机交互设备：将人能识别的信息转化为计算机能识别的信息输入，或是二进制信息转化为人能识别的文字、图像等<ul>
<li>键盘、鼠标、打印机等</li>
</ul>
</li>
<li>计算机信息存储设备<ul>
<li>磁盘、光盘、磁带</li>
</ul>
</li>
<li>机—机通信设备<ul>
<li>调职解调器、网卡等</li>
</ul>
</li>
</ul>
<p><strong>输入设备</strong></p>
<p>键盘：按键 —&gt; 判断哪个键按下 —&gt; 将此键翻译为ASCII码(编码键盘法)</p>
<blockquote>
<p>流程：把若干个键排列成矩阵，用计数器，经过行译码、列译码以后对键盘进行扫描，确定哪个键摁下，一旦扫描到计数器的计数就停止，同时把计数器输出作为ROM输入地址，ROM保存了键盘上对应的ASCII码，通过中断方式读入，CPU读入操作经过一段时间延迟后可以输入到中断控制装置来清除中断标记，可以用于再一次启动计数器，使计数器再对键盘访问，为下一次做准备。</p>
</blockquote>
<p>鼠标、触摸屏</p>
<p><strong>输出设备</strong></p>
<p>显示器</p>
<ul>
<li>字符显示：字符发生器</li>
<li>图形显示：主观图像(人工的方式在计算机上画，或通过程序在计算机上画点线面构成的图像)</li>
<li>图像显示：客观图像</li>
</ul>
<p>打印机：</p>
<ul>
<li>打击式(点阵式)：逐字、逐行</li>
<li>非打击式：激光（逐页）喷墨（逐字）</li>
</ul>
<blockquote>
<p>也可以通过宽度分为窄行打印机和宽行打印机</p>
</blockquote>
<p><strong>其他</strong></p>
<p>A/D、D/A：模拟/数字（数字/模拟）转换器(A指模拟信号，D指数字信号)</p>
<blockquote>
<p>计算机内部使用的使数字信号，如果要进行外部控制或者远程传输需要使用D/A设备将数字信号转化成模拟信号</p>
</blockquote>
<p>终端：由键盘和显示器组成(不仅仅使这两样，还有控制系统、缓存等。类似瘦客户机)。</p>
<p>完成显示控制与存储、键盘管理及通信控制</p>
<p>汉字处理：汉字输入、汉字存储、汉字输出</p>
<p><strong>多媒体技术</strong></p>
<p>概念：多种媒体技术和手段相结合进行综合应用给人以更多的视听或动作上的感受</p>
<p>触摸屏</p>
<h3 id="5-3I-O接口"><a href="#5-3I-O接口" class="headerlink" title="5.3I/O接口"></a>5.3I/O接口</h3><h6 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h6><ul>
<li>实现设备的选择：确认哪个设备参与输入输出操作</li>
<li>实现数据缓冲达到速度匹配：一些设备数据量大，一些设备数据量小</li>
<li>实现数据串—并格式转换</li>
<li>实现电平转化：I/O设备和主机电平不一致，通过接口转换</li>
<li>传送控制命令：CPU将控制命令传送到接口，由这些命令来控制工作</li>
<li>反映设备的状态（“忙<strong>”、“</strong>就绪<strong>”、</strong>“中断请求”）</li>
</ul>
<h6 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h6><p>这些接口决定了硬件电路的接口</p>
<p><strong>总线方式的I/O接口电路</strong></p>
<ul>
<li><p>设备选择线：参与本次信息传输的设备的设备码或者是端口号(设备地址或端口地址)传输给I/O接口进行匹配，看是否是该接口连接的一个设备。</p>
</li>
<li><p>数据线：完成数据的输入输出，条数和接口的类型有关</p>
</li>
<li><p>命令线：主机的命令通过命令线输入I/O接口中，经过缓冲译码后控制设备做相应操作</p>
</li>
<li><p>状态线：单向，I/O接口送到总线再送到主机</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.3-1.png" alt></p>
<p><strong>接口的功能和组成</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>组成</th>
</tr>
</thead>
<tbody><tr>
<td>选址功能</td>
<td>设备选择电路(逻辑实现上说就是一个比较器)</td>
</tr>
<tr>
<td>传送命令的功能</td>
<td>命令寄存器、命令译码器</td>
</tr>
<tr>
<td>传送数据的功能(核心功能)</td>
<td>数据缓冲寄存器 DBR</td>
</tr>
<tr>
<td>反映设备状态的功能</td>
<td>设备状态标记</td>
</tr>
</tbody></table>
<p>设备状态标记</p>
<ul>
<li>完成触发器 D：D=1表示准备工作已经完成，D=0表示准备工作尚未完成</li>
<li>工作触发器 B：用来标识外部设备工作状态是否忙，B=1表示忙，B=0表示完成工作</li>
<li>中断请求触发器 INTR</li>
<li>屏蔽触发器 MASK：如果等于1表示尽管设备已经完成工作依然不能向主机发送中断请求。表示主机现在工作重要性比现在输入输出的重要性要大。</li>
</ul>
<blockquote>
<p>并串转换、电平转换应该在接口的功能当中，为了使电路简单明了，没有放到教材上，实际是有的。</p>
</blockquote>
<p>CPU和接口之间</p>
<ul>
<li><p>数据线：双向，并行传输</p>
</li>
<li><p>地址线：给出外部设备地址，供设备选择电路使用</p>
</li>
<li><p>命令线：给出操作命令，放在命令寄存器当中进行存储，进而进行译码。并且在持续电路的控制下给出各个操作以及各个操作的时间关系。</p>
</li>
<li><p>状态线：把I/O接口的状态，外部设备的状态传输给CPU</p>
</li>
</ul>
<p>外部设备和I/O接口之间</p>
<ul>
<li>数据线：传输接口和设备之间需要传输的数据</li>
<li>命令：命令来自于命令译码器和时序逻辑，控制外部设备做相应的工作</li>
<li>状态：外部设备的状态，把它进行输入，对状态标记进行置位或者复位</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.3-2.png" alt></p>
<h6 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h6><ul>
<li><p>按数据传送方式分类：</p>
<ul>
<li>串行接口 Intel 8255</li>
<li>并行接口 Intel 8251</li>
</ul>
</li>
<li><p>按功能选择的灵活性分类：</p>
<ul>
<li>可编程接口：功能和工作方式可以通过编程的方式进行设置 Intel8255、Intel 8251</li>
<li>不可编程接口：不能通过软件的方式来设置接口的功能和工作方式，但可以通过硬连线方式来进行改变 Intel 8212</li>
</ul>
</li>
<li><p>按通用性分类</p>
<ul>
<li>通用接口：把多种类型接口中通用的电路做到一个芯片中，就形成一个通用接口 Intel 8255、Intel 8251</li>
<li>专用接口：只能用于主机和某一种类型的设备进行连接 Intel 8279、Intel 8275</li>
</ul>
</li>
<li><p>按数据传送的控制方式分类</p>
<ul>
<li>中断接口 Intel 8259</li>
<li>DMA接口 Intel 8257</li>
</ul>
<blockquote>
<p>前面介绍过3种数据传送的控制方式，程序查询方式不需要接口来控制。</p>
</blockquote>
</li>
</ul>
<h3 id="5-4程序查询方式"><a href="#5-4程序查询方式" class="headerlink" title="5.4程序查询方式"></a>5.4程序查询方式</h3><h6 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h6><p><strong>单个设备</strong></p>
<p>如果在传输过程种只有一个设备参与内存和I/O之间数据传输，在执行程序的过程中，CPU会执行到一个输入输出指令又这个指令发出启用设备命令，相应的设备接收到命令以后就开始数据准备，数据准备好以后再传输给CPU，CPU在发出设备启用命令之后就开始检查状态标记，I看/O接口中数据、设备是否准备好进行输入和输出，如果准备就绪就进行数据交换，如果没有CPU就踏步状态。直到开始交换数据为止。</p>
<p>测试指令负责检查状态标记。准备就绪阶段使用转移(分支)指令。交换数据使用传送指令或输入输出指令或访存指令</p>
<p><strong>多个设备</strong></p>
<p>如果在传输过程种多个设备要通过程序查询方式和CPU、内存进行数据交换，当我们需要把参与传输的设备，根据他的优先级，根据轻重缓急对他进行排序，优先级越高的设备被查询到的时间越早。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.1-1.png" alt></p>
<p>程序流程</p>
<p>程序查询方式要完成内存和外部设备之间的数据输入输出，需要借助CPU中的某一个寄存器，对数据进行暂存，如果数据有用，要对寄存器中的数据进行保存，可以写入内存，压入堆栈或放入放入CPU中闲置寄存器中，保存后设置计数器的值，为了控制传输的数据量(到底多大数据)。为了完成内存和I/O之间的数据传输，需要知道内存块起始地址，所以需要设置主存缓冲区首址。然后启动外设。CPU开始查询I/O接口或设备的状态，看是否准备好，如果没有，就原地踏步的方式反复查询，一直到状态标志表明数据已经准备好，开始进行数据传输，传送一个字，传送完后，修改设置的初始值，修改内存地址，修改计数器的值，为输入或输出下一个数据做准备。然后判断是否传输完，如果没有就再次启动外设，循环过程，直到传输完，结束I/O传送。</p>
<p>两种计数器方式；</p>
<ul>
<li><p>如果要传送n个字，计数器的值设为n，每完成一个字的传输，计数器-1，直到0为止</p>
</li>
<li><p>设置为负n，并且用补码来表示，每传输一个字，计数器+1，直到计数器发生溢出，值变为0</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.4-2.png" alt></p>
<h6 id="程序查询方式的接口电路"><a href="#程序查询方式的接口电路" class="headerlink" title="程序查询方式的接口电路"></a>程序查询方式的接口电路</h6><p>设备选择电路：它给出的设备选择信号实际是整个I/O接口电路的选择信号，只有它有效I/O接口才会工作。</p>
<p>如果SEL信号有效，并且启动命令有效，I/O接口就会开始工作。</p>
<p>输入(外部设备—&gt;主机)流程：CPU通过地址线给出外部设备的地址，设备选择电路把设备地址或者端口号和地址线上的地址比较，如果相同SEL就有效，在启动命令和SEL信号都有效的情况下，对两个状态标记置位或复位，标记D为0表示数据未准备好，标记B为1表示开始工作忙状态，设备接收到B信号和启动命令信号之后设备开始工作，将设备准备好，并且数据通过输入的数据线保存到DBR当中，设备工作结束。设备通过状态线向接口电路送入设备工作结束信号，该信号会修改两个标记，D为1表示数据准备好，B为0表示设备已经工作完成。D信号被送出。CPU查询的就是D信号。CPU通过数据线读入数据。</p>
<h3 id="5-5程序中断方式"><a href="#5-5程序中断方式" class="headerlink" title="5.5程序中断方式"></a>5.5程序中断方式</h3><p>中断的概念：指CPU在执行程序的过程当中，如果发生意外事件或是特殊事件，CPU要中断当前程序的执行，转而去处理特殊事件或异常事件，通过执行中断服务程序的方式来进行处理。处理结束之后要返回到被中断的程序的程序断点，继续去执行原来的程序。</p>
<p>如果有中断请求还要判断能不能进行响应，如果能响应才中断现行程序的执行。</p>
<p>中断需要保存程序的断点，中断返回之后要知道从哪继续执行，要保存中断现场(寄存器的值)，做完之后再去执行中断服务程序。</p>
<h6 id="I-O中断的产生"><a href="#I-O中断的产生" class="headerlink" title="I/O中断的产生"></a>I/O中断的产生</h6><p>中断源：在主机外部、内部和CPU的外部、内部能够引发CPU发生中断的因素都称为中断源。</p>
<p>例打印机<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.5-1.png" alt></p>
<h6 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h6><p>采用中断方式不仅仅需要5.3介绍的基本接口电路，还需要有中断请求标志，有外部设备对中断请求标志进行设置，表示有中断请求了。这个中断请求标志能否变成中断请求信号向CPU发出中断请求，还要看中断请求标志是否会被屏蔽。</p>
<ul>
<li><p>配置中断请求触发器INTR和中断屏蔽触发器MASK：就是配置两个标志</p>
<ul>
<li>屏蔽触发器：正在执行的程序或中断服务程序重要性要比这个设备提出的中断请求的重要性要高，这个中断标志就会被屏蔽</li>
<li>INTR值为1表示有中断请求，0为无请求，并且通过中断请求线可以把中断请求送给CPU，通知CPU外部设备有一个中断请求</li>
<li>Q端输出为1表示中断会被屏蔽，0表示开放。要进行数据传输的时候，I/O接口中的状态标记应该是工作休息状态(D=1)。</li>
<li>当D输出为1，MASK Q端为0 Q非端输出为1。两端都为1的时候，中断请求触发器设置为1，表示有中断请求。指令执行周期结束之前CPU会发出中断查询信号，会使INTR的D端的输入被送到输出当中，产生中断请求信号。</li>
</ul>
</li>
<li><p>排队器：排出优先级最高的设备</p>
<ul>
<li><p>硬件：在CPU内或在接口电路中(链式排队器)</p>
<ul>
<li>接口电路：把硬件的排队电路放在每个接口中，每个接口和排队电路相关的电路连接在一起，就组成了一个链，叫菊花链方式或链式排队器</li>
<li>INTR上面一横：表示相应的中断请求信号，他的非端进行输入。</li>
<li>在该链式排队器中，每一个接口，他的排队线路包含了两个门电路一个非门一个与非门。这个接口中的排队电路把他相互的连接在一起，构成了一个链式排队器。1号设备对应的中断请求信号，被输入到链式排队器中，从设备优先级来说，图左侧优先级高</li>
<li>如果所有中断源都没有中断请求，INTR非的值就为1，每个INTP’输出都是1，如果某一个设备有中断请求INTR<del>i</del>=1，INTR<del>i</del>非就为0</li>
<li>当INTR<del>1</del>有请求INTR<del>1</del>=1，INTR<del>1</del>非=0，那么在第一部分的输出端就为1，在2部分经过非门后，INTP‘<del>2</del>就变成0，在与门和与非门之间的线输出就为0，后面都是一样。也就是说如果某一个优先级的设备提出中断请求的话，排在后面的INTP’都会变成0，在它之前的都是1</li>
<li>方框1是非门的意思</li>
<li>若2有效，前面无效，则前面输出均为1，后面都为0.所以组成是若干个1和若干个0。那么中断请求就是若干个1中最后的一个1，优先级最高。</li>
<li>在INTP<del>i</del>‘外接一个与非门同时连接INTR<del>i</del>，再通过非门，传输出去，这样就只有最后一个1才有效。(这里比较简单稍微想想就行了)</li>
</ul>
<blockquote>
<p>与门：同时输入为高电平1时候才输出高电平，否则低电平</p>
<p>非门：输入取反</p>
<p>与非门：先与再非</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.5-2.png" alt></p>
<ul>
<li>软件：通过查询的方法，中断的优先级在表格中进行规定，排队的过程就是高优先级到低优先级的查询的过程(详见第八章)。</li>
</ul>
</li>
<li><p>中断向量地址形成部件：传递中断程序的入口地址</p>
<ul>
<li>寻址入口之地同样两种方法：由软件产生(详见第八章)、硬件向量法</li>
</ul>
</li>
<li><p>硬件向量法：由硬件产生向量地址，再由向量地址找到入口地址</p>
<ul>
<li>中断号：如8086中支持255个中断这256个中断被编号为0到255</li>
<li>中断向量：和中断服务程序相关的入口地址。包括断地址或偏移量，有时候也指程序状态字，也包括执行中断服务程序的时候需要的一些状态信息。</li>
<li>程序断开字：一些非体系寄存器或表示程序状态的寄存器，这些寄存器指令无法读取，在计算机内部就把它集成成一个字，这个字称为程序状态字</li>
<li>向量地址：指中断向量保存的内存单元的地址(存储中断向量的存储单元地址)如：中断服务程序入口地址，它所保存的内存单元的地址，或者是利用跳转指令，通过该指令跳转到中断服务程序，这时他的向量地址，是指跳转指令在内存中的地址。</li>
<li>中断服务程序的入口地址，可以由中断向量来生成。</li>
<li>要形成向量地址，要用一个硬部件“中断向量地址形成部件”，输入为排队器(链式排队器或其它类型的中断优先级的排队器)的输出结果(只有一位高电平其它低电平)。输出对应了向量地址。</li>
<li>中断向量地址形成部件 从属性上看是 <strong>设备编码器</strong></li>
</ul>
</li>
<li><p>程序中断方式接口电路的基本组成</p>
<ul>
<li>设备选择电路：输出是接口的选择信号，只有该输出有效接口才开始工作。</li>
<li>命令译码蓝框是我们的命令缓存器、命令译码器、命令寄存器，通过译码确认本次操作确认本次操作对接口和响应设备做什么样的操作。</li>
<li>D、B：标记触发器(在程序查询方式中介绍过)</li>
<li>INTR：表示中断请求标记，如果中断源有中断请求INTR的值可能会设为1，具体是不是设为1和中断屏蔽触发器有关。</li>
<li>如果中断没被屏蔽，并且设备工作完成，在中断查询信号的控制下INTR输出就为1。</li>
<li>设备编码器：就是硬件结构的中断地址向量形成部件。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.5-3.png" alt></p>
<h6 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I/O中断处理过程"></a>I/O中断处理过程</h6><p><strong>CPU响应中断的条件和时间</strong></p>
<p>条件：允许中断触发器EINT = 1(用开中断指令设置EINT为”1”、用关中断指令或硬件自动复位将EINT置“0”)</p>
<p>时间：当D=1(随机)且MASK=0时。</p>
<blockquote>
<p>CPU不能随时中断，一般在每条指令执行阶段的结束前，CPU查询是否有中断请求。CPU发中断查询信号(将INTR置“1”)</p>
</blockquote>
<p><strong>I/O中断处理过程</strong></p>
<p>输入为例：CPU在执行主程序的过程中，执行到输入指令，要求指定的外部设备将数据输入到主机中。CPU在数据线上给出设备的地址，设备地址送到接口电路中后，利用设备选择电路和设备地址进行比较，如果相同这个接口以及相对应设备被选中，SEL信号有效。由CPU送来启动命令或对接口设备的控制命令，该命令经过译码后输入到接口中，在接口中译码。当该命令和SEL信号同时有效才会使触发器B和D被设置。输入操作要求外部设备将数据输入接口再到主机。因此在启动命令启动后B应被设为1表示设备开始工作同时数据还未准备好触发器D设为0，设备工作结束以后，会把输入数据送入输入接口中的数据缓冲寄存器DBR。同时修改D、B的状态，这时设备工作结束，设备准备好，CPU随时可以把数据取走。因此D被设为1，设备处于空闲，所以B为0。如果接口提出的中断请求没有被屏蔽，意味着MASK触发器非端为1，D输出也为1，两个值经过与非门和非门将值送入INTR输入端。CPU在执行指令结束阶段后发出中断查询信号，这个信号会把接口中中断请求触发器INTR值置位1，同时启动排队器进行排队。经过排队器排队后输出信号只有一个是1其他都是0，CPU发出中断响应信号，发出后形成向量地址，向量地址经过数据线传给CPU传给PC，PC利用地址取出中断程序的入口地址或跳转指令。设备编码器的地址会通过数据线传递给CPU，CPU利用地址找到中断服务程序的入口地址，进而去执行中断服务程序，完成对应操作取走数据。</p>
<h6 id="中断服务程序流程"><a href="#中断服务程序流程" class="headerlink" title="中断服务程序流程"></a>中断服务程序流程</h6><p><strong>中断服务程序的流程</strong></p>
<ol>
<li><p>保护现场</p>
<ul>
<li>程序断点的保护(中断隐指令完成)：中断返回后，去执行哪条指令的地址要保持。和程序执行状态，不能由指令直接读取的状态。由硬件完成。</li>
</ul>
<blockquote>
<p>中断隐指令并不是一条指令而是硬件要完成的一系列操作。</p>
</blockquote>
<ul>
<li>寄存器内容的保护：通用寄存器或体系结构寄存器如果被利用到，它的值也要保存。一般利用进栈指令进行保存也可以保存在内存单元的指定位置，也可以转存到寄存器。</li>
</ul>
<blockquote>
<p>体系结构寄存器和非体系结构寄存器相对立，体系结构寄存器是可以被程序员“看到”，一般是通用寄存器部分可以被修改和赋值。而非体系结构寄存器是“用户透明”的，不可见的，机器自身执行指令使用。</p>
</blockquote>
</li>
<li><p>中断服务：不同I/O设备具有不同内容的设备服务</p>
</li>
<li><p>恢复现场：如果采用进栈指令保存，用出栈指令。如果保存到内存单元，就用取数指令。</p>
</li>
<li><p>中断返回：中断返回指令</p>
</li>
</ol>
<p><strong>单重中断和多重中断</strong></p>
<p>单重中断：指CPU在执行中断服务程序过程中，如果有了新的中断请求，不管新的中断请求优先级有多高都不能中断现行的中断服务程序。</p>
<p>多重中断(中断的嵌套)：允许级别更高的中断源中断现行的中断服务程序 </p>
<p>单重中断的流程：在指令执行结束之后查询是否有中断请求，如果没有接着执行下一条，如果有要响应中断请求，进入中断周期(保护断点、形成中断服务程序的入口地址、关中断)中断周期是在一条指令解释的几个阶段中一个阶段(取指令、形成操作数地址、取操作数、执行，执行之后是中断周期)。中断周期结束就进入中断服务程序的执行。保护现场、设备服务、恢复现场、开中断中断返回。在中断返回之后才把中断打开让EINT为1，在整个中断服务程序中EINT都为0。即使有优先级更高的请求CPU也不会响应。</p>
<blockquote>
<p>中断周期的操作都是由硬件按照时序来完成的</p>
</blockquote>
<p>多重中断的流程：前面和单重中断流程一致。在中断服务程序开始执行过程中不一样。为了让更高级的中断请求能响应。把开中断的位置提前，在设备服务的过程中允许响应更高级的中断请求。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.5-5.png" alt></p>
<h3 id="5-6DMA方式"><a href="#5-6DMA方式" class="headerlink" title="5.6DMA方式"></a>5.6DMA方式</h3><h6 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h6><p>中断方式：I/O设备和主存数据交换，必须经过CPU中的寄存器。模型中给定ACC寄存器。在内存和I/O设备数据交换的过程中尽管CPU和数据交换可以并行，但是依然要中断现行程序，来执行中断服务程序。</p>
<p>DMA：外部设备和内存之间的数据交换可以直接通过DMA接口而不需要CPU。</p>
<blockquote>
<p>程序中断的数据通路和程序查询是相同的</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-1.png" alt></p>
<p><strong>DMA与主存交换数据的三种方式</strong></p>
<ul>
<li><p>停止CPU访问主存：从第一块数据交换开始，CPU就放弃了对总线的控制权和内存的访问权，都交给DMA接口</p>
<ul>
<li>优势：控制简单</li>
<li>劣势：只有指令缓存器中有指令或指令已经取入Cache，CPU才可以继续工作。如果没有CPU就不工作或保持状态，无法充分发挥CPU对主存的利用率。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-2.png" alt></p>
</li>
<li><p>周期挪用(或周期窃取)</p>
<ul>
<li>周期：访存周期</li>
<li>如果DMA接口准备好数据传输，就申请建立总线的使用权，占用一个或几个内存访问周期，完成数据的传输，在数据传输的间隔或数据准备阶段，DMA接口放弃对总线的占用</li>
<li>DMA访问主存有三种可能<ul>
<li>CPU不访问：DMA正好可以访问</li>
<li>CPU正在访问：DMA等待</li>
<li>CPU和DMA同时请求访存：DMA优先。因为DMA上都是高速设备，如果不响应可能会造成数据丢失</li>
</ul>
</li>
</ul>
<blockquote>
<p>存储墙问题Memory wall</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-3.png" alt></p>
</li>
<li><p>DMA与CPU交替访问：实用性不强</p>
<ul>
<li>CPU工作周期分为：C<del>1</del>、C<del>2</del><ul>
<li>C<del>1</del>专供DMA访存</li>
<li>C<del>2</del>专供CPU访存</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于在固定时间点存储器和I/O总线使用权是固定的，就不需要DMA提出申请对总线的控制器和对内存的使用权，所以速度快。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-4.png" alt></p>
</li>
</ul>
<h6 id="DMA-接口的功能和组成"><a href="#DMA-接口的功能和组成" class="headerlink" title="DMA 接口的功能和组成"></a>DMA 接口的功能和组成</h6><p><strong>DMA 接口功能</strong></p>
<ul>
<li><p>向 CPU 申请 DMA 传送：DMA要向CPU提出总线和内存占用请求</p>
</li>
<li><p>处理总线 控制权的转交：一旦允许，要转交控制权</p>
</li>
<li><p>管理 系统总线、控制 数据传送</p>
</li>
<li><p>确定 数据传送的 首地址和长度、修正传送过程中的数据地址和长度：也要知道数据传输方向、修改长度主要是为了数据块的传输是否结束</p>
</li>
<li><p>DMA传送结束时，给出操作完成信号</p>
</li>
</ul>
<p><strong>DMA 接口组成</strong></p>
<p>假设为单总线结构</p>
<ul>
<li>要进行数据传输CPU首先要告诉DMA接口传输的地址，所以需要一个<strong>地址寄存器AR</strong></li>
<li>需要知道传输的数据量所以需要<strong>计数器WC</strong>进行传输量的计数</li>
<li><strong>数据缓存器BR</strong>：外部设备的数据或存储单元输出的数据要暂存其中</li>
<li><strong>设备地址寄存器DAR</strong>：<ul>
<li>供设备选择电路使用，看下这次访问的设备是不是接口中当前连接的设备。可以把设备地址保存其中</li>
<li>对硬盘访问的时候，DAR还能保存柱面号，磁道号，扇区号</li>
</ul>
</li>
<li>地址线：AR把要访问的内存地址送给主存</li>
<li>数据线：要给AR、WC、DAR、BR置值。</li>
<li>外部设备和数据缓存器直接相连。</li>
<li>输入输出控制是由<strong>DMA控制逻辑</strong>来进行控制，要控制接口内部进行协调工作，控制在给定的时序发出给定的信号(如：给CPU发出DMA请求、向主存发出读写控制信号)</li>
<li>外部设备如果进行DMA传输，要向DMA控制逻辑发出请求信号DREQ(设备请求缩写)。DMA要向CPU发出控制信号，DMA控制器要对设备给出应答信号DACK，还要对CPU发出总线使用的请求信号HRQ。CPU发出应答信号HLDA由MDA控制器接收。</li>
<li><strong>中断机构</strong>：用于数据传输完后，对后续工作进行处理。计数器为0时表示传输结束，就会向中断机构发信号，给中断机构的中断请求触发器置1，当一条指令执行结束后，由中断机构向CPU发出中断请求。由CPU做数据传输后处理</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-5.png" alt></p>
<h6 id="DMA-的工作过程"><a href="#DMA-的工作过程" class="headerlink" title="DMA 的工作过程"></a>DMA 的工作过程</h6><p><strong>DMA传送过程</strong></p>
<ol>
<li><p>预处理：在数据传输之前要做的一些响应的设置</p>
<ul>
<li>通过几条输入输出指令预置如下信息    <ul>
<li>通知DMA控制逻辑传输方向(入/出)</li>
<li>设备地址—&gt;DMA的DAR</li>
<li>主存地址—&gt;DMA的AR</li>
<li>传送字数—&gt;DMA的WC</li>
</ul>
</li>
</ul>
</li>
<li><p>数据传送</p>
<ul>
<li>是否允许传送：能否占用总线和内存的使用权</li>
<li>主存地址由AR送入总线</li>
<li>由DMA控制逻辑进行一个字的传输，传输完后修改主存地址为下一次传输做准备。同时修改字计数器</li>
<li>通过计数器的值是否为0来判断传输是否结束。如果没结束再判断是否允许数据传输。如果结束了，就向CPU申请程序中断。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-6.png" alt></p>
</li>
<li><p>后处理：执行中断程序，做DMA结束处理</p>
</li>
</ol>
<blockquote>
<p>全部做完后继续执行主程序</p>
<p>CPU先做预处理，启动设备后，CPU继续执行输入输出指令后的一些指令，真正的数据输入输出操作由DMA接口完成。DMA接口控制完成一批数据的传送。</p>
</blockquote>
<p><strong>以输入为例，看DMA接口工作流程</strong>：这里的输入指数据从外部设备送入主存。数据从外部设备送入BR，BR保存了要输入的数据，之后通过DREQ信号通知DMA接口数据已经准备好。DMA控制逻辑通过HRQ信号通过总线向CPU提出总线和主存的占用请求。CPU在允许的情况下给出HLDA信号，然后放弃总线和主存的占用。要进行数据传输要给出主存地址，地址通过AR寄存器给出使系统总线上地址总线有效。再由DMA控制器通过DACK信号通知设备已经开始进行数据传输。数据和控制信号由DMA控制器和BR发出。DMA控制器发出对内存的控制指令，同时BR通过数据线将数据送到数据总线。每传送一个内存AR和WC+1。然后判断是否传输完，如果没有就再来一次，如果结束，WC发出溢出。溢出信号送到中断机构使中断机构中的中断请求触发器参加中断排队。CPU接收到中断请求后去执行中断服务程序做后处理。</p>
<p>如果是<strong>输出</strong>：首先要将BR中的数据送入设备，这时候BR空，数据传输完。由设备通过DREQ信号通知DMA控制器BR空可以用于接收下一个数据。DMA控制器通过HRQ信号向CPU发出总线和内存的控制请求。CPU在允许的情况下给出HLDA应答信号，这时内存和总线控制权都交给DMA接口。如果要进行输出还要给出要访问的内存单元的地址。AR给出该地址。同时DMA通过DACK信号对设备应答。通过这些控制信号以及给出的地址信号，主存当中的数据会被再次写入到BR中。同时要修改AR和WC。再判断传输是否结束，如果没有再循环刚才的过程。如果结束，用WC的溢出信号告诉中断机构，把中断机构中的INTR信号置1。由中断机构发出中断请求。进行后处理。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-7.png" alt></p>
<p>后处理的工作内容</p>
<ul>
<li><p>校验送入主存的数是否正确</p>
</li>
<li><p>是否继续用 DMA</p>
</li>
<li><p>测试传送过程是否正确，错则转诊断程序</p>
</li>
</ul>
<blockquote>
<p>后处理是CPU在响应了DMA接口以后中断请求以后执行中断服务程序来完成</p>
</blockquote>
<p><strong>DMA接口与系统的连接方式</strong></p>
<p>一台机器上可以有多个DMA接口，都要连接到总线上。</p>
<p>连接方式：</p>
<ul>
<li><p>具有公共请求线的DMA请求：DMA接口通过地址线数据线和主存进行连接同时所有的DMA接口共享一条请求线</p>
<ul>
<li>请求线是送至CPU。</li>
<li>进行DMA响应的时候各个DMA接口也是有优先级排序的。CPU通过查询线一个一个进行查询。越靠近CPU的DMA接口优先级越高。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-8.png" alt></p>
</li>
<li><p>独立的DMA请求：类似于独立请求方式。每个DMA接口要和地址线数据线进行连接。每个接口都有独立的DMA请求信号、DMA响应信号。排队的工作在CPU内。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-9.png" alt></p>
</li>
</ul>
<blockquote>
<p>优缺点可以参照第三章中串行和独立请求方式的优缺点。也可以模拟第三章给出的方法，给出第三中连接方法。</p>
</blockquote>
<p><strong>DMA方式与程序中断方式的比较</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>中断方式</th>
<th>DMA方式</th>
</tr>
</thead>
<tbody><tr>
<td>数据传送</td>
<td>程序(中断服务程序)</td>
<td>硬件</td>
</tr>
<tr>
<td>响应时间</td>
<td>指令执行结束</td>
<td>存取周期(设备与主存直接数据交换)</td>
</tr>
<tr>
<td>处理异常情况</td>
<td>能</td>
<td>不能</td>
</tr>
<tr>
<td>中断请求(两者的目的和作用不一样)</td>
<td>传送数据</td>
<td>后处理</td>
</tr>
<tr>
<td>优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h6 id="DMA-接口的类型"><a href="#DMA-接口的类型" class="headerlink" title="DMA 接口的类型"></a>DMA 接口的类型</h6><ul>
<li><p>选择型：在物理上连接多个设备，在逻辑上只允许连接一个设备。</p>
<ul>
<li>如果是选择型接口这些寄存器、时序电路就只有一套。某一个设备要使用该接口进行数据传输，CPU通过允许一条输入输出指令，要对这些寄存器设置。其他设备无法和主存进行DMA请求、数据交换。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-10.png" alt></p>
</li>
<li><p>多路型：在物理上连接多个设备，在逻辑上只允许连接多个设备。</p>
<ul>
<li>但正在进行传输的时候也只能有一个设备与内存进行传输</li>
<li>数据准备阶段可以有多个设备进行数据准备</li>
</ul>
</li>
</ul>
<blockquote>
<p>通道是一种小型的DMA处理机也是一种DMA接口。每个通道下都有若干个子通道，每个子通道都有主存地址寄存器、设备地址寄存器、字计数器。这些子通道可以控制多个设备，设备进行数据传输的时候，CPU执行到输入输出指令，要控制某个设备进行输入输出，他就对相应的子通道当中的寄存器进行设置。设置完后他就继续执行自己的程序。碰到了吓一跳输入输出指令如果两个设备用不同的子通道，还会对其他的子通道当中主存地址寄存器、字计数器、设备地址寄存器再次进行设置。外部设备在之后的时间里可以进行数据准备。这个数据准备是多个外部设备并行进行的。外部设备准备好后通过子通道向通道提出数据传输请求。这时候不同设备的数据传输是串行执行的。</p>
</blockquote>
<p><strong>多路DMA接口工作原理</strong></p>
<p>假设磁盘每隔30微秒(包含了数据的传送时间和数据的准备时间)提出一次数据传输请求。</p>
<p>假设磁带每隔45微秒提出一个DMA请求。</p>
<p>假设打印机每隔150微秒提出一个DMA请求。</p>
<p>假设真正用于数据传送的时间只有5微秒。DMA接口的数据送入主存或主存数据送入DMA接口。</p>
<p>一个多路型接口连接了这三个设备，由于打印机最早提出请求，就最先响应打印机，把5微秒给打印机。然后磁盘和磁带同时发出请求(速度越高的设备优先级越高)。响应磁盘用5微秒完成数据传输。因为请求之前数据已经放入数据缓存器里，所以这5微秒就用于接口的数据和内存的数据进行传输。再响应磁带请求。</p>
<blockquote>
<p>尽管一个多路型接口连接了很多设备，但依然有很多时间是空闲的。还可以连接更多的设备。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.6-11.png" alt></p>
<h1 id="计算机组成原理—数字"><a href="#计算机组成原理—数字" class="headerlink" title="计算机组成原理—数字"></a>计算机组成原理—数字</h1><ul>
<li>计算机中 数的表示：硬件识别和处理的数据类型。</li>
<li>在计算机系统的指令集中包含对这些中类型操作的指令</li>
<li>运算器的设计：分析数据的比算方法，对其改进，借助该算法，研究在硬件如何实现。给出相应硬件组成。</li>
</ul>
<h2 id="六、计算机的运算方法"><a href="#六、计算机的运算方法" class="headerlink" title="六、计算机的运算方法"></a>六、计算机的运算方法</h2><h3 id="6-1无符号数和有符号数"><a href="#6-1无符号数和有符号数" class="headerlink" title="6.1无符号数和有符号数"></a>6.1无符号数和有符号数</h3><h6 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h6><p>概念：没有正负号的数据。</p>
<p>把它变换为二进制，用计算机当中的寄存器或存储器按规定长度，保存到计算机中。如果保存在寄存器中，那<strong>寄存器的长度</strong>就直接反映了<strong>无符号数的表示范围</strong></p>
<h6 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h6><p>概念：有正负号的数据。</p>
<p>有符号数包含数值部分和数值部分。</p>
<p><strong>机器数与真值</strong></p>
<p>机器数：符号数字化的数(保存在计算机中的数)</p>
<p>真值：带符号的数(不一定是十进制)</p>
<blockquote>
<p>小数点的位置可以以约定的方式给出。没有任何硬件来表示。 </p>
<p>可以通过小数点的位置分类：小数定点机(小数点约定在符号位后面)、整数定点机</p>
</blockquote>
<p><strong>原码表示法</strong></p>
<p><strong>PS</strong>：我觉得以下公式有点鬼扯。就理解为0是正1是负。原码组成就是符号位+照抄</p>
<p>定义(x为真值，n为整数的位数)：|X|<del>原</del>=</p>
<ul>
<li>0,x    2^n^＞x≥0</li>
<li>2^n^-x   0≥x＞-2^n^</li>
</ul>
<p>如 x=+1110 [x]<del>原</del>=0,1110 用逗号将符号位和数值部分隔开。</p>
<p>​    x=-1110 [x]<del>原</del>=2^4^+1110 =1,1110</p>
<blockquote>
<p>0的原码计算不同，表示的机器数也不同。0有两种形式</p>
<p>符号位+照抄</p>
</blockquote>
<p><strong>小数</strong>的原码表示</p>
<p>定义：[x]<del>原</del>=</p>
<ul>
<li>x     1&gt;x≥0</li>
<li>1-x  0≥x＞-1</li>
</ul>
<blockquote>
<p>小数的0也有两个表示方式</p>
</blockquote>
<p>如 x=+0.1101 [x]<del>原</del>=0.1101</p>
<p>​     x=-0.1101 [x]<del>原</del>=1-(-0.11.1)=1.1101</p>
<blockquote>
<p>小数点将符号位和数值部分隔开。</p>
</blockquote>
<p>整数用<strong>逗号</strong>表示，小数用<strong>小数点</strong>表示。但在计算机中是不需要存储表示的。</p>
<p><strong>特点</strong>：简单、直观</p>
<p>缺点：加减法运算有问题。</p>
<table>
<thead>
<tr>
<th>要求</th>
<th>数1</th>
<th>数2</th>
<th>实际操作</th>
<th>结果符号</th>
</tr>
</thead>
<tbody><tr>
<td>加法</td>
<td>正</td>
<td>郑</td>
<td>加</td>
<td>正</td>
</tr>
<tr>
<td>加法</td>
<td>正</td>
<td>负</td>
<td>减</td>
<td>可正可负</td>
</tr>
<tr>
<td>加法</td>
<td>负</td>
<td>正</td>
<td>减</td>
<td>可正可负</td>
</tr>
<tr>
<td>加法</td>
<td>负</td>
<td>负</td>
<td>加</td>
<td>负</td>
</tr>
</tbody></table>
<p>思考：能否只作加法？ 找到一个与负数等价的正数来替代这个负数，使减—&gt;加</p>
<p><strong>补码表示法</strong></p>
<p>PS：公式复杂，正数就是0+照抄。负数就是1+原码取反+1。补码转原码也是除符号位取反+1。</p>
<p>补的概念：一个负数加上”模“即得该负数得补数。</p>
<p>一个正数和一个负数互为补数时，它们绝对值之和即为模数。</p>
<blockquote>
<p>在时钟内可以用-3当作+9，-5当作+7.</p>
</blockquote>
<p>如：寄存器四位：-1011可以记作0101。三位011记作101</p>
<p>补码定义(x为真值 n为整数的位数)：[x]<del>补</del>=</p>
<ul>
<li>0，x        2^n^&gt;x≥0</li>
<li>2^n+1^+x     0&gt;x≥ -2^n^(mod 2^n+1^)</li>
</ul>
<p>如x=+1010  [x]<del>补</del>=0,1010</p>
<p>​    x=-1011000 [x]<del>补</del>=1,0101000</p>
<p><strong>小数</strong>的补码表示</p>
<p>定义(x为真值)：[x]<del>补</del>=</p>
<ul>
<li>x      1&gt;x≥0</li>
<li>2+x   0&gt;x≥-1 (mod2)</li>
</ul>
<p>如 x=+0.1110   [x]<del>补</del>=0.1110</p>
<p>​     x=-0.1100000   [x]<del>补</del>=1.0100000</p>
<blockquote>
<p>补码的100…0当特例来记</p>
</blockquote>
<p><strong>反码表示法</strong></p>
<p>PS：正数为0+照抄，负数为1+取反</p>
<p>定义(x为真值，n为整数位数)：[x]<del>反</del>=</p>
<ul>
<li>0，x            2^n^&gt;x≥0          </li>
<li>(2^n+1^-1)+x   0≥x&gt; -2^n^(mode 2^n+1^-1)</li>
</ul>
<p>如    x=+1101 [x]<del>反</del>=0,1101</p>
<p>​        x=-1101 [x]<del>反</del>=1,0010</p>
<p><strong>小数</strong>的反码</p>
<p>定义：</p>
<p>[x]<del>反</del>=</p>
<ul>
<li>x    1&gt;x≥0</li>
<li>(2-2^-n^)+x  0≥x&gt;-1 (mod 2-2^-n^)</li>
</ul>
<p>如：x=+0.1101 [x]<del>反</del>=0.1101</p>
<p>​        x= -0.1010   [x]<del>反</del>=1.0101</p>
<p><strong>小结</strong>：</p>
<ul>
<li>最高位为符号位，书写上用“,”(整数)或”.“(小数)将数值部分和符号位隔开</li>
<li>对于正数，原码=补码=反码</li>
<li>对于负数，符号位为1，其数值部分原码除符号位外每位取反末尾加1—&gt;补码，原码除符号位外每位取反—&gt;反码</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.1-1.png" alt></p>
<p><strong>移码表示法</strong></p>
<p>PS：移码和补码只差一个符号位</p>
<p>补码表示很难直接判断其真值大小</p>
<p>定义：[x]<del>移</del>=2^n^+x (2^n^&gt;x≥-2^n^)</p>
<blockquote>
<p>不管是正负数都加2^n^</p>
<p>无小数</p>
</blockquote>
<p>如： x=10100  [x]<del>移</del>=1,10100</p>
<p>​         x=-10100 [x]<del>移</del>=0,01100 </p>
<h3 id="6-2数的定点表示和浮点表示"><a href="#6-2数的定点表示和浮点表示" class="headerlink" title="6.2数的定点表示和浮点表示"></a>6.2数的定点表示和浮点表示</h3><h6 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h6><p>概念：小数点按约定方式标出。小数点位置是由计算机体系结构设计人员，在设计过程中约定的。在硬件实现和软件实现都要遵守约定，软件编程人员要根据该约定在程序中调整数值的大小来适应约定。</p>
<p>两种形式</p>
<ul>
<li>小数点在数符后面</li>
<li>小数点在数值后</li>
</ul>
<p>根据小数点的位置把计算机分为两类：小数定点机、整数定点机。</p>
<table>
<thead>
<tr>
<th>定点机</th>
<th>小数定点机（范围）</th>
<th>整数定点机（范围）</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td>-(1-2^-n^)~+(1-2^-n^)</td>
<td>-(2^n^-1)~+(2^n^-1)</td>
</tr>
<tr>
<td>补码</td>
<td>-1~+(1-2^-n^)</td>
<td>-2^n^~+(2^n^-1)</td>
</tr>
<tr>
<td>反码</td>
<td>-(1-2^-n^)~+(1-2^-n^)</td>
<td>-2^n^~+(2^n^-1)</td>
</tr>
</tbody></table>
<h6 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h6><p>为啥引入浮点数表示</p>
<ul>
<li>编程困难，程序员要调节小数点的位置</li>
<li>数的表示范围小，为了表示两个大小相差很大的数据，需要很长的机器字长。</li>
<li>数据存储单元的利用率低</li>
</ul>
<p><strong>浮点数的表示形式</strong></p>
<p>表示：N=S×r^j^ 浮点数的一般形式</p>
<p>S尾数(小于等于1、可正可负) j阶码(可正可负) r尾数的基值</p>
<p>如r=2  N=11.0101=0.110101×2^10^（10二进制）</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.2-1.png" alt></p>
<p><strong>浮点数的表示范围</strong></p>
<p>前半部分为阶码，后半部分为尾数</p>
<p>发生上溢时做错误处理，发生下溢时 按机器零(0)处理</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.2-2.png" alt></p>
<p><strong>练习</strong></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.2-3.png" alt></p>
<p>为了满足最大精度，必须让<strong>尾数尽可能长</strong>。</p>
<p>2^15^=32768。15&lt;2^4^。所以阶码给4位，两个符号位。剩余都给尾数部分。所以m=4，n=18.</p>
<p><strong>浮点数的规格化形式</strong></p>
<p>​    r=2：尾数最高位为1</p>
<p>​    r=4：尾数最高2位不全为0 </p>
<p>​    r=8：尾数最高3位不全为0</p>
<p>基数不同，浮点数的<strong>规格化形式不同</strong>。</p>
<p><strong>浮点数的规格化</strong></p>
<p>r=2 </p>
<ul>
<li>左规 尾数左移一位，阶码减1</li>
<li>右规 尾数右移一位，阶码加1</li>
</ul>
<p>r=4</p>
<ul>
<li>左规 尾数左移二位，阶码减1</li>
<li>右规 尾数右移二位，阶码加1</li>
</ul>
<p>基数r越大，可表示的的<strong>浮点数的范围越大</strong>，浮点数的<strong>精度越低</strong></p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.2-4.png" alt></p>
<p>19=16+2+1=10011  除138右移7位 0.0010011</p>
<p>定点表示：0.0010011000</p>
<p>浮点规格化表示：x=0.1001100000×2^-10^</p>
<p>定点机中：[x]<del>原</del> = [x]<del>补</del>= [x]<del>反</del> = 0.0010011000</p>
<p>浮点机种：[x]原 = 1, 0010;0. 1001100000、[x]<del>补</del> = 1, 1110; 0. 1001100000、[x]<del>反</del> = 1, 1101;0. 1001100000</p>
<p><strong>分号</strong>隔开阶码和尾数</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.2-5.png" alt></p>
<p><strong>机器零</strong></p>
<ul>
<li>当浮点数尾数为0时，不论其阶码为何值按机器零处理</li>
<li>当浮点数阶码等于或小于它所表示的最小数时，不论尾数为何值，按机器零处理<ul>
<li>如5位补码(含符号位)1,0000表示-16，无论尾数，都为0</li>
</ul>
</li>
</ul>
<p>当阶码用移码，尾数用补码表示时，机器零为0,0000;0.00…0</p>
<p>有利于机器中“判0”电路实现</p>
<h6 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h6><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.2-6.png" alt></p>
<p>该阶码的偏置值必普通移码的偏置值少1，范围为-126~127，没有全0和全1。</p>
<p>尾数规格化表示：非“0”的有效位最高位一定为“1”(隐含)，所以可以省略一位来提高精度。</p>
<p>754标准对实数有三种规定。</p>
<table>
<thead>
<tr>
<th></th>
<th>符号位S</th>
<th>阶码</th>
<th>尾数</th>
<th>总位数</th>
</tr>
</thead>
<tbody><tr>
<td>短实数</td>
<td>1</td>
<td>8</td>
<td>23</td>
<td>32</td>
</tr>
<tr>
<td>长实数</td>
<td>1</td>
<td>11</td>
<td>52</td>
<td>64</td>
</tr>
<tr>
<td>临时实数</td>
<td>1</td>
<td>15</td>
<td>64</td>
<td>80</td>
</tr>
</tbody></table>
<h3 id="6-3定点运算"><a href="#6-3定点运算" class="headerlink" title="6.3定点运算"></a>6.3定点运算</h3><h6 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h6><p>机器用语：数据相对于小数点移动。</p>
<p>左移：绝对值扩大。右移：绝对值缩小</p>
<blockquote>
<p>小数点是设计时规定的，无法移动</p>
</blockquote>
<p><strong>移位规则</strong></p>
<p>符号位不变</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-1.png" alt></p>
<p>算数移位的硬件实现：</p>
<ul>
<li>真值为正(左移)：符号位不变，所以构成一个循环。数值位左移最高位丢弃(向下箭头表示)，最低位补0(0箭头表示)</li>
<li>真值为正(右移)：符号位自我复制，并把自身0给右边一位。最低位丢掉</li>
<li>负数的原码(左移)：符号位不动，高位丢弃，低位补零。</li>
<li>负数的原码(右移)：符号位不动，低位丢弃，高位补零。</li>
<li>负数的补码(左移)：符号位不动，高位丢弃，低位补零</li>
<li>负数的补码(右移)：符号位自我复制并且右移，低位丢弃</li>
<li>负数的反码(左移)：符号位不动，高位丢弃，低位补1</li>
<li>复数的反码(右移)：符号位自我复制并且右移 ，低位丢弃</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>真值为正</th>
<th>负数的原码</th>
<th>复数的补码</th>
<th>负数的反码</th>
</tr>
</thead>
<tbody><tr>
<td>若左移丢1</td>
<td>出错</td>
<td>出错</td>
<td>正确(若丢0出错)</td>
<td>正确</td>
</tr>
<tr>
<td>若右移丢1</td>
<td>影响精度</td>
<td>影响精度</td>
<td>影响精度</td>
<td>正确</td>
</tr>
</tbody></table>
<p>算术移位：有符号数的移位(算数位不参与)</p>
<p>逻辑移位：无符号数的移位(算数位参与)</p>
<h6 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h6><p>加法：</p>
<ul>
<li>整数 [A]<del>补</del>+[B]<del>补</del>=[A+B]<del>补</del>(mod 2^n+1^)</li>
<li>小数 [A]<del>补</del>+[B]<del>补</del>=[A+B]<del>补</del>(mod 2)</li>
</ul>
<p>减法(A-b=A+(-B))：</p>
<ul>
<li>整数 [A-B]<del>补</del>=[A+(-B)]<del>补</del>=[A]<del>补</del>+[-B]<del>补</del> (mod 2^n+1^)</li>
<li>小数 [A-B]<del>补</del>=[A+(-B)]<del>补</del>=[A]<del>补</del>+[-B]<del>补</del> (mod 2)</li>
</ul>
<blockquote>
<p>对于整数来说mod 2^n+1^不论正负数，他的补码形式都可以用x+2^n+1^来表示，根据该规则不用区分加数被加数和正负数。把A的补码表示成2^n+1^+A。如果A为小数形式可以变为2+A。因为正数的话多出来的高位会自动丢弃</p>
</blockquote>
<p>连同<strong>符号位</strong>一起相加，符号位产生的进位自然丢掉</p>
<p><strong>溢出判断</strong></p>
<ul>
<li><p>一位符号位判溢出：参加的两个数符号相同，其结果的符号与原操作数的符号不同，即为溢出</p>
<ul>
<li><p>最高有效位的进位⊕符号位的进位=1</p>
<ul>
<li>最高有效位的进位：数值部分运算的进位</li>
<li>符号位的进位：两个1，或符号位一个1最高有效位一个1。</li>
</ul>
</li>
<li><p>如果用一位符号位判溢出，在硬件上要记录符号位的进位和最高有效位的进位。然后送入异或电路，如果输出为1表示发生了溢出。</p>
<blockquote>
<p>⊕表示异或逻辑运算，只有两个变量相异才为1，相同为0</p>
</blockquote>
</li>
</ul>
</li>
<li><p>两个符号位判溢出（符号位是2位不是1位）</p>
<ul>
<li><p>小数：[x]<del>补</del>=</p>
<ul>
<li>x        1&gt;x≥0</li>
<li>4+x     0&gt;x≥-1 (mod4)</li>
</ul>
</li>
<li><p>若双符号位相同：未溢出；若双符号位不同：溢出。</p>
<ul>
<li>最高符号位代表真正符号位，第二位实际是溢出值</li>
</ul>
</li>
</ul>
<blockquote>
<p>推广：</p>
<p>小数：可以以2^k^作为模，那么它的补码符号位部分就占了k位。</p>
<p>整数：可以以2^n+m^作为模，符号位m位</p>
</blockquote>
</li>
</ul>
<p><strong>补码加减法的硬件配置</strong></p>
<p>加法器：来完成运算。</p>
<p>A(ACC寄存器)：保存被加数</p>
<p>X(寄存器)：保存加数(或减数)的补码</p>
<p>G<del>A</del>、G<del>S</del>：两个标记，如果做加法G<del>A</del>置1，如果减法G<del>S</del>置1。</p>
<p>求补控制逻辑：用来完成B的补码到-B的补码的过程。如果是减法就每位取反，包括符号位。</p>
<blockquote>
<p>加一操作可以利用另一个加法器，或直接用图上加法器加完再运算原加法。但是这样会非常麻烦</p>
<p>以下我略懂(日后看)：B的补码到-B的补码过程中，每位取反非常容易可以在加法器和寄存器之间加一个反向器。末尾加一通过第一位送过来的进位把它置1来实现末尾加1的操作</p>
</blockquote>
<h6 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h6><p>计算机如何做二进制的乘法运算？</p>
<ol>
<li><p>分析笔算乘法</p>
<ul>
<li>可以用异或电路完成符号位的单独处理</li>
<li>可以把乘数放入一位的寄存器中，每判断一位是否为1。判断完后寄存器的值右移一位。来完成某一位是否加被乘数</li>
<li>4个位积相加，用累加。加的时候第二寄存器的值要左移一位和原来的位积相加。实际上可以将被乘数的位置不懂，位积每次相加的时候右移一位来替代被乘数左移。</li>
<li>用两个寄存器保存乘积的值，来保证位数扩大一倍</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-2.png" alt></p>
</li>
<li><p>改进笔算乘法</p>
<ul>
<li>将被乘数A+0，再右移一位，等到新的部分积，再部分积+被乘数(若为0则+0，若为1则加A)，再右移一位，以此类推</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-3.png" alt></p>
<blockquote>
<p><strong>小结</strong></p>
<p>乘法 运算可用 加和移位实现。n(n为位数) = i，加 i 次，移 i 次</p>
<p>由乘数的末位决定被乘数是否与原部分积相加。0丢弃1相加</p>
<p>乘数时放入乘商寄存器中，乘法的累加值的高位放入ACC寄存器，ACC数值部分长度随着右移加长。那它的低位被移到了MQ寄存器中，MQ寄存器保存的乘数也在逐渐右移。被乘数只与ACC寄存器中保存的高位相加，MQ中的低位不操作。</p>
<p>X寄存器保存被乘数不需要移位功能。但MQ和ACC都需要移位功能。</p>
<p>全加器：要实现被乘数和部分积的高位相加的操作。需要n+1</p>
</blockquote>
</li>
<li><p>原码的乘法运算</p>
<ul>
<li>符号位和数值位分开运算</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-4.png" alt></p>
<ul>
<li>原码一位递推公式(类似第2步改进乘法笔算)<ul>
<li>因为运算采用的是绝对值运算，所以移位时用的是逻辑右移(带符号位)。因为如果运算进位是进到符号位，绝对值符号位初始值为0。</li>
<li>符号位异或操作，数值部分按绝对值相乘</li>
<li>特点：<ul>
<li>绝对值运算</li>
<li>用移位的次数判断乘法是否结束</li>
</ul>
</li>
<li>例：<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-5.png" alt></li>
</ul>
</li>
<li>硬件配置<ul>
<li>A：n+1位，其中有一位最高位并不是最高位，他保存的是低位数值部分相加以后向高位的进位</li>
<li>X：保存被乘数，计算过程中被乘数保持不变</li>
<li>Q(MQ)：乘商寄存器，计算刚开始时这里保存的乘数的数值位，随着计算的进行一边计算一边移位。他的高位部分逐渐被累加和的低位部分占据，乘数的低位部分，每次移位都会遗留移位，直到完成n次移位所有的数值位部分都移掉。运算结束。</li>
<li>计算器C：用来记录移位次数。数值部分位n，它就位n每次移位-1。为0时结束</li>
<li>S：符号位，通过异或方式给S置值</li>
<li>G<del>M</del>：乘法标志</li>
<li>移位和加控制：由Q的最低位控制</li>
<li>控制门：当Q最低位为1时，控制门开打，被乘数送往加法器。如果是0，控制门把0送入加法器和A累加或者不送入，由移位和加控制直接进行移位操作。</li>
<li>A、X、Q均为n+1位：Q实际n位就够了，但是计算机中，寄存器不是专用做乘法，还有很多其它应用。</li>
</ul>
</li>
</ul>
</li>
<li><p>补码的乘法运算(完全不懂，再看)</p>
<ul>
<li><p>补码一位乘运算规则(被乘数：[x]<del>补</del>、乘数[y]<del>补</del>)</p>
<ul>
<li><p>被乘数任意，乘数为正：与原码乘相似，但加和移位按补码规则运算。乘积符号自然形成</p>
<ul>
<li>公式：[x×y]<del>补</del>=[x]<del>补</del>×[y]<del>补</del>，y<del>0</del>=0</li>
</ul>
</li>
<li><p>被乘数任意，乘数为负：乘数去掉符号位，操作与(被乘数任意，乘数为正)一样，最后加[-x]<del>补</del>，校正</p>
<ul>
<li>公式：[x×y]<del>补</del>=[x]<del>补</del>×0.y<del>1</del>…y<del>n</del>+[-x]<del>补</del>，y<del>0</del>=1</li>
</ul>
<p><strong>改进公式(统一)</strong>：[x×y]<del>补</del>=[x]<del>补</del>×0.y<del>1</del>…y<del>n</del>+[-x]<del>补</del>×y<del>0</del></p>
</li>
</ul>
<blockquote>
<p>因为分情况判断会造成硬件非常复杂。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>两位乘教材上自己看</p>
</blockquote>
<ul>
<li><p>Booth算法(被乘数、乘数符号任意)</p>
<ul>
<li><p>到最后就类似原码的乘法</p>
</li>
<li><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-6.png" alt="推导过程"></p>
</li>
<li><p>最后一步是不需要乘2^-1^所以不移位。[z<del>n</del>]为每步的部分积<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-7.png" alt="运算过程"></p>
</li>
<li><p>关键是实现y<del>i+1</del>-y<del>i</del>：用译码器</p>
<ul>
<li>译码器输入为y<del>i</del>和y<del>i+1</del>，输出四根线00、01、10、11。其中11和00做相同操作，做一个或操作。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">y<del>i</del>  y<del>i+1</del></th>
<th align="center">y<del>i+1</del>-y<del>i</del></th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0  0</td>
<td align="center">0</td>
<td align="center">右移1位</td>
</tr>
<tr>
<td align="center">0  1</td>
<td align="center">1</td>
<td align="center">+[x]<del>补</del>，右移1位</td>
</tr>
<tr>
<td align="center">1  0</td>
<td align="center">-1</td>
<td align="center">+[-x]<del>补</del>，右移1位</td>
</tr>
<tr>
<td align="center">1  1</td>
<td align="center">0</td>
<td align="center">右移1位</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>举例：符号位给2位，为了满足数值进位。移位的过程是按照补码的规则<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-8.png" alt></p>
</li>
<li><p>Booth算法硬件配置</p>
<ul>
<li>A(ACC累加器)：存放部分积和最后的积高位部分</li>
<li>Q(MQ寄存器)：保存乘数</li>
<li>X：保存x(被乘数)</li>
<li>移位和加控制逻辑：判断加什么</li>
<li>都是n+2位寄存器。这里用的双符号位。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>小结：</p>
<ul>
<li>整数与小数乘法完全相同，只需将逗号替代小数点</li>
<li>原码乘 符号位 单独处理。补码乘 符号位 自然形成。</li>
<li>原码乘去掉符号位运算 即为无符号数乘法</li>
<li>不同的乘法运算需有不同的硬件支持</li>
</ul>
<h6 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h6><ol>
<li><p>分析笔算除法</p>
<ul>
<li>商符单独处理：容易实现 用异或电路就可以</li>
<li>心算上商：在计算机里完成移位和比较的过程。</li>
<li>余数不动低位补”0”减去右移一位的除数：n位加法器无法完成该操作，要用2n位的加法器实现。</li>
<li>上商位置不固定</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-9.png" alt></p>
</li>
<li><p>笔算除法和机器除法的比较</p>
<table>
<thead>
<tr>
<th>笔算除法</th>
<th>机器除法</th>
</tr>
</thead>
<tbody><tr>
<td>商符单独处理</td>
<td>符号位异或形成</td>
</tr>
<tr>
<td>心算上商</td>
<td>|x|-|y|&gt;0 上商1、|x|-|y|&lt;0 上商0</td>
</tr>
<tr>
<td>余数不动低位补“0” 减右移一位的除数</td>
<td>余数左移一位低位补“0”减除数</td>
</tr>
<tr>
<td>2倍字长加法器</td>
<td>1倍字长加法器</td>
</tr>
<tr>
<td>上商位置不固定</td>
<td>在寄存器最末位上商(然后每次上商都把商值得寄存器左移一位)</td>
</tr>
</tbody></table>
<blockquote>
<p>在笔算中，是除数右移会导致长度太长，所以机器中可以采用余数左移</p>
</blockquote>
</li>
<li><p>原码除法</p>
<ul>
<li>⊕：异或运算</li>
<li>约定：<ul>
<li>小数定点除法 x* <strong>＜</strong> y* 整数定点除法 x* <strong>＞</strong> y*<ul>
<li>如果遇到，可以停止计算，说明发生了溢出</li>
</ul>
</li>
<li>被除数不等于0</li>
<li>除数不能为0：除数不能为0否则系统会发生异常</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-10.png" alt></p>
<ul>
<li>恢复余数法<ul>
<li>上商5次：第一次是小数前面得0</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-11.png" alt>)<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-12.png" alt></p>
<ul>
<li><p>不恢复余数法(加减交替法)</p>
<ul>
<li>2R<del>i</del>表示余数左移1位</li>
<li>其余和恢复余数法一致，但减完后若上商0则左移一位加而不是减。</li>
<li>上商n+1：第一次上商来判断溢出</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-13.png" alt></p>
<ul>
<li>硬件实现<ul>
<li>A：保存被除数的余数</li>
<li>X：保存除数</li>
<li>Q：保存商</li>
<li>移位和加控制逻辑：通过上商的最后一位来确认左移后是加还是减除数。</li>
<li>C：用移位的次数或加法的次数来控制除法操作停止</li>
<li>G<del>D</del>：除法标志</li>
<li>S：符号位</li>
<li>V：是否发生溢出</li>
<li>A、X、Q均为n+1位</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.3-14.png" alt></p>
</li>
</ul>
</li>
</ol>
<h3 id="6-4浮点四则运算"><a href="#6-4浮点四则运算" class="headerlink" title="6.4浮点四则运算"></a>6.4浮点四则运算</h3><p>乘除法运算可以根据定点运算和浮点的加减法运算自学(不考)</p>
<p><strong>浮点加减运算</strong></p>
<p>阶码一致才能运算。</p>
<ol>
<li><p>对阶</p>
<ul>
<li><p>求阶差：Δj=j<del>x</del>-j<del>y</del>=</p>
<ul>
<li>= 0 j<del>x</del>=j<del>y</del>  已对齐 </li>
<li>&gt; 0 j<del>x</del>&gt;j<del>y</del> x向y看齐降低x阶码使他和y的阶码相同或y向x看齐</li>
<li>&lt; 0 j<del>x</del>&lt;j<del>y</del> x向y看齐增加x阶码使他和y的阶码相同或y向x看齐</li>
</ul>
<blockquote>
<p>尾数右移比左移 合理，移位左移数据位丢失误差大</p>
<p>小阶向大阶看齐</p>
</blockquote>
</li>
<li><p>对阶：将阶码对齐，相应移位</p>
</li>
</ul>
</li>
<li><p>尾数求和</p>
</li>
<li><p>规格化：尽可能提高浮点数的表示精度</p>
<ul>
<li>定义：若尾数基值r=2，1/2≤|S|&lt;1。若r=4，1/4≤|S|&lt;1 以此类推</li>
<li>规格化数的判断：</li>
</ul>
<table>
<thead>
<tr>
<th>S&gt;0</th>
<th>规格化形式</th>
<th>S&lt;0</th>
<th>规格化形式</th>
</tr>
</thead>
<tbody><tr>
<td>真值</td>
<td>0.1xx…x</td>
<td>真值</td>
<td>-0.1xx…x</td>
</tr>
<tr>
<td>原码</td>
<td>0.1xx…x</td>
<td>原码</td>
<td>1.1xx…x</td>
</tr>
<tr>
<td>补码</td>
<td>0.1xx…x</td>
<td>补码</td>
<td>1.0xx…x</td>
</tr>
<tr>
<td>反码</td>
<td>0.1xx…x</td>
<td>反码</td>
<td>1.0xx…x</td>
</tr>
</tbody></table>
<p>原码：不论正负数，第一数位为1</p>
<p>补码：符号位和第一数位不同</p>
<ul>
<li><p>特例：<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.4-1.png" alt></p>
</li>
<li><p>左规(补码)：尾数左移一位，阶码减1，直到数符和第一位数不同为止</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.4-2.png" alt></p>
</li>
<li><p>右规：当尾数溢出(&gt;1)时，需右规，即尾数出现01.xx…x或10.xx…x时，尾数右移一位，阶码+1。</p>
<ul>
<li>01.的时候其实真正符号位是0,1为数值位</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.4-3.png" alt></p>
</li>
<li><p>舍入：在 对阶 和 右规 过程中，可能出现 尾数末位丢失 引起误差，需考虑舍入</p>
<ul>
<li>0舍1入法：类似四舍五入</li>
<li>恒置“1”法：不论舍弃什么值，末尾都为1</li>
</ul>
<blockquote>
<p>舍入：数据的长度超过计算机中存储数据的物理器件能保存的数据的长度。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.4-4.png" alt></p>
</li>
<li><p>溢出判断：整个浮点数溢出</p>
<ul>
<li>-1/2不是规格化数据，所以取不到</li>
<li>下溢，阶码小于-128，阶码为10，xx…x</li>
<li>上溢，阶码大于127，阶码为01，xxx…x</li>
</ul>
</li>
</ol>
<h3 id="6-5算术逻辑单元"><a href="#6-5算术逻辑单元" class="headerlink" title="6.5算术逻辑单元"></a>6.5算术逻辑单元</h3><p>前面介绍的运算硬件电路在计算机中被集成到算术逻辑单元中</p>
<h6 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h6><p>ALU电路是一个组合逻辑电路，没有记忆功能。输入消失，输出端的运算结果也会消失。为了对输出的运算结果保存，并且使运算稳定，在输入端A<del>i</del>、B<del>i</del>和输出端连接寄存器。</p>
<ul>
<li>A<del>i</del>、B<del>i</del>：表示参加运算的数据</li>
<li>F<del>i</del>：输出结果</li>
<li>K<del>i</del>：决定做什么运算</li>
</ul>
<blockquote>
<p>自主学习四位ALU 74181</p>
</blockquote>
<p>在74181当中，控制端M如果输入低电平(0)表示算术运算，如果是高电平(1)逻辑运算。另外四个控制端S<del>0</del>S<del>3</del>取不同值，可做不同运算。</p>
<h6 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h6><p><strong>并行加法器(略讲后面会细讲)</strong></p>
<p>图上：n+1个全加器构成的并行加法器</p>
<p>两个n+1位的数可以利用该加法器以并行的方式完成加法运算。</p>
<p>每个全加器三个输入</p>
<ul>
<li>C<del>i</del>：低位向相邻高位的进位</li>
<li>A<del>i</del>、B<del>i</del>：对应了参与两个数的相应位</li>
<li>S<del>i</del>：本位和，加法和的结果，指出运算结果某一位是1或0</li>
</ul>
<p>在S<del>i</del>和C<del>i</del>的算术过程中，A<del>i</del>和B<del>i</del>都是已知的，只有C<del>i-1</del>是未知的。所以C<del>i-1</del>的产生速度提高就能提高运算器的速度。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-2.png" alt></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-2.png" alt></p>
<p>C<del>i</del>根据重叠律让A<del>i</del>B<del>i</del>C<del>i-1</del>乘3分别与前面的结合提取公因式</p>
<p><strong>结论</strong>：若A<del>i</del>、B<del>i</del>都为1，那么C<del>i</del>就为1。若A<del>i</del>、B<del>i</del>至少一个为1，C<del>i-1</del>才会进位</p>
<p>因此d<del>i</del>=A<del>i</del>B<del>i</del> 本地进位(A<del>i</del>B<del>i</del>叫本地进位，由本地参与运算的两个数据相应的位产生进位)</p>
<p>t<del>i</del>=A<del>i</del>+B<del>i</del> 传送条件，如果t<del>i</del>=1那么C<del>i-1</del>的结果会被传送到C<del>i</del></p>
<p>则<strong>C<del>i</del>=d<del>i</del>+t<del>i</del>C<del>i-1</del></strong></p>
<blockquote>
<p>A的反+A=1</p>
<p>重叠律：A+A+A=A。</p>
</blockquote>
<p>串行进位链</p>
<p>进位链：传送进位的电路</p>
<p>串行进位链：进位以串行的方式进行传送</p>
<p>根据<code>非(A 或B) = (非A) 且(非B)</code>可以转化式子</p>
<blockquote>
<p>根据<a href="https://blog.51cto.com/1003995416/1837744" target="_blank" rel="noopener">德摩根定律</a>中非(A 或B) = (非A) 且(非B)化简</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-3.png" alt></p>
<p><strong>并行加法器</strong></p>
<p>用到了与或非门</p>
<p>电路实现参照算式，大方框最后一步是非门，小方框1是非门。</p>
<blockquote>
<p>与门一般是与非门+非门。考虑到成本和内部电路</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-4.png" alt></p>
<p><strong>单重分组跳跃进位链</strong></p>
<p>n位全加器分若干小组，小组中的进位同时产生，小组与小组之间采用串行进位。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-5.png" alt></p>
<p><strong>双重分组跳跃进位链</strong></p>
<p>n位全加器分若干大组，大组中又包含若干小组。每个大组中小组的最高位进位同时产生。大组与大组之间采用串行进位</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-6.png" alt></p>
<ul>
<li>大组进位分析<ul>
<li>图1为公式推导，图2为第2大组中每个小组的进位，图3为具体小组的电路实现，图4大组内进位过程，图5为两个大组结合进位过程</li>
<li>第8组进位是C<del>3</del>。组成是最右边C<del>0</del>、C<del>1</del>、C<del>2</del>。</li>
<li>D<del>i</del>和T<del>5</del>都是该小组本地产生，不依赖于外来进位</li>
<li>通过公式推导，使得让原来依赖C<del>3</del>、C<del>7</del>…都改换成依赖C<del>-1</del>。小组的进位直接依赖C<del>-1</del></li>
<li>图上可以看出来T<del>8</del>和D<del>8</del>都是2.5T后同时产生的。</li>
</ul>
</li>
</ul>
<blockquote>
<p>书p289第一句话关键，看懂就懂了</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-7.png" alt></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-8.png" alt></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-9.png" alt></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-10.png" alt></p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.5-11.png" alt></p>
<h2 id="七、指令系统"><a href="#七、指令系统" class="headerlink" title="七、指令系统"></a>七、指令系统</h2><h3 id="7-1机器指令"><a href="#7-1机器指令" class="headerlink" title="7.1机器指令"></a>7.1机器指令</h3><p>机器指令指计算机系统的CPU能直接识别并执行的操作命令。</p>
<p>一个处理器能执行的所有的机器指令称为指令集。</p>
<p>指令集是计算机系统软件和硬件的交界面。</p>
<p>指令的字长：一条指令它的长度的位数。固定或可变</p>
<p><strong>指令的一般格式</strong></p>
<p>格式：操作码字段+地址码字段</p>
<ul>
<li><p>操作码：指出机器做什么操作。在很多机器的指令集中操作码还要指出对什么数据做操作。另外在一些机器中操作码还指出了操作数的寻址方式。</p>
<ul>
<li>长度固定：用于指令字长较长的情况，RISC(精简指令集计算机)。 <ul>
<li>如IBM 370 操作码8位</li>
</ul>
</li>
<li>长度可变 在实际上操作码字段可以分开，在不同位置表示<ul>
<li>如x86处理器  </li>
</ul>
</li>
</ul>
<blockquote>
<p>如：IBM360指令系统中，加法操作因为数据类型不一样表示的基值不一样，一个加法指令一共8条。分别对应定点数和浮点数，浮点数的尾数进制是2还是16等</p>
</blockquote>
</li>
</ul>
<p>扩展操作码技术</p>
<p>方法：</p>
<ul>
<li><p>保留编码的码点作为扩展标志</p>
<ul>
<li>操作码的位数随地址数的减少而增加</li>
<li>若前4位或8位等，全1表示扩展。后面的几位表示扩展的操作码</li>
<li>OP：操作码。A<del>1</del>、A<del>2</del>、A<del>3</del>：地址码</li>
<li>短操作码不能是长操作码的前缀。(数据结构里有讲)</li>
<li>三地址：A<del>1</del>、A<del>2</del>、A<del>3</del>。两地址：A<del>2</del>、A<del>3</del>。一地址：A<del>3</del></li>
<li>高频指令用短操作码，低频指令用长操作码。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.1-1.png" alt></p>
</li>
<li><p>利用操作码中某一位作为扩展标志</p>
</li>
</ul>
<p><strong>地址码</strong></p>
<ul>
<li>四地址<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.1-2.png" style="zoom: 50%;"><ul>
<li>OP：操作码 8位</li>
<li>A<del>1</del> 第一操作数地址 6位</li>
<li>A<del>2</del> 第二操作数地址 6位</li>
<li>A<del>3</del> 结果的地址 6位</li>
<li>A<del>4</del> 下一条指令地址 6位</li>
<li>取指令、取A<del>1</del>、取A<del>2</del>、保存A<del>3</del>。所以需要四次访存。取A<del>4</del>就是取指令</li>
<li>寻址范围 2^6^ = 64</li>
<li>在现代计算机中，采用PC来表示下一条要取得或执行的指令。PC代替A<del>4</del>就变为三地址指令。原来一个A是6位地址，替代后就是一个A8位地址</li>
</ul>
</li>
<li>三地址 <img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.1-3.png" style="zoom: 50%;"><ul>
<li>都是8位</li>
<li>寻址范围 2^8^ = 256</li>
<li>用A<del>1</del>或A<del>2</del>代替A<del>3</del>，将结果保存到原操作数的地址中，可以进一步扩大地址码位数。成二地址</li>
</ul>
</li>
<li>二地址<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.1-4.png" style="zoom: 50%;"><ul>
<li>寻址范围 2^12^ = 4K</li>
<li>3访存或4访存</li>
<li>可以将保存在指定寄存器中，进一步减少访存次数。如保存到ACC</li>
<li>若其中一个操作数需要在ACC中有，另一个操作数在内存。结果保存到ACC，进一步简化到一地址</li>
</ul>
</li>
<li>一地址<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.1-5.png" style="zoom: 50%;"><ul>
<li>寻址范围 2^12^ = 4K</li>
<li>两次访存</li>
</ul>
</li>
<li>零地址<ul>
<li>如：对ACC数据操作。在ACC采用隐含寻址的方式。比如清零、给ACC数据取反、或者对其中某一类数据进行操作或判断是否全1，全0、堆栈类型的计算机加法类型的操作只要有操作码即可(栈顶两个数据加，结果保存到栈顶)。</li>
</ul>
</li>
</ul>
<p><strong>指令字长</strong></p>
<p>取决于：操作码的长度、操作数地址的长度、操作数地址的个数</p>
<ul>
<li>指令字长<strong>固定</strong>：等于存储字长或短于存储字长</li>
<li>指令字长<strong>可变</strong>：按字节的倍数变化</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li><p>当用一些硬件资源代替指令字中的地址码字段后</p>
<ul>
<li>可扩大指令的寻址范围</li>
<li>可缩短指令字长(指令是包括操作码和地址码)</li>
<li>可减少访存次数 </li>
</ul>
</li>
<li><p>当指令的地址字段为寄存器时</p>
<p>​    三地址 OP R<del>1</del>, R<del>2</del> , R<del>3</del></p>
<p>​    二地址 OP R<del>1</del> , R<del>2</del></p>
<p>​    一地址 OP R<del>1</del> </p>
<ul>
<li>可缩短指令字长(寄存器个数少如16个4位足够)</li>
<li>指令执行阶段不访存</li>
</ul>
</li>
</ul>
<h3 id="7-2操作数类型和操作类型"><a href="#7-2操作数类型和操作类型" class="headerlink" title="7.2操作数类型和操作类型"></a>7.2操作数类型和操作类型</h3><p><strong>操作数类型</strong></p>
<p>操作数：指令要进行处理的数据</p>
<ul>
<li>地址：如：跳转指令中操作数部分就是地址或相对地址。绝对地址无符号数，相对地址是有符号数</li>
<li>数字：定点数、浮点数、十进制数</li>
<li>字符：用ASCII表示</li>
<li>逻辑数：逻辑运算</li>
</ul>
<p><strong>数据在存储器中的存放方式</strong></p>
<p>大端：高字节在低地址</p>
<p>小端：低字节在低地址</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.2-1.png" alt></p>
<p>存储字长64位(CPU在访存过程中通过一次访问内存最多能拿到64位的数据)、机器字长32位(那64位就是双字)</p>
<p>半字：一个字节的一半</p>
<p>存储方式：</p>
<ul>
<li><p>从任意位置开始存储</p>
<ul>
<li>优点：不浪费存储资源</li>
<li>缺点：除了访问一个字节之外，访问其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.2-2.png" alt></p>
</li>
<li><p>从一个存储字的起始位置开始访问</p>
<ul>
<li>优点：无论访问何种类型的数据，在一个周期内 均可完成，读写控制简单。</li>
<li>缺点：浪费了宝贵的存储资源</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.2-3.png" alt></p>
</li>
<li><p>边界对准方式(从地址的整数倍位置开始访问)</p>
<ul>
<li>数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.2-4.png" alt></p>
</li>
</ul>
<p><strong>操作类型(汇编学了就成了)</strong></p>
<ul>
<li><p>数据传送</p>
<table>
<thead>
<tr>
<th>源</th>
<th>目的</th>
<th>例如</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>寄存器</td>
<td>MOVE</td>
</tr>
<tr>
<td>寄存器</td>
<td>存储器</td>
<td>STORE、MOVE、PUSH</td>
</tr>
<tr>
<td>存储器</td>
<td>寄存器</td>
<td>LOAD、MOVE、POP</td>
</tr>
<tr>
<td>存储器</td>
<td>存储器</td>
<td>MOVE</td>
</tr>
</tbody></table>
<ul>
<li>特殊类型的数据传送指令：置”1“、清”0“</li>
</ul>
</li>
<li><p>算术逻辑操作</p>
<ul>
<li>加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算</li>
<li>与、或、非、异或、位操作、位测试、位清除、位求反</li>
<li>如：8086  ADD SUB MUL DIV INC DEC CMP NEG  AAA AAS AAM AAD  AND OR NOT XOR TEST </li>
</ul>
</li>
<li><p>移位操作</p>
<ul>
<li>算术移位、逻辑移位</li>
<li>循环移位（带进位和不带进位）</li>
</ul>
</li>
<li><p>转移</p>
<ul>
<li>无条件转移 JMP</li>
<li>条件转移(分支指令)<ul>
<li>结果为零转 （Z = 1）JZ</li>
<li>结果溢出转 （O = 1）JO</li>
<li>结果有进位转 （C = 1）JC</li>
<li>跳过一条指令 SKP</li>
</ul>
</li>
<li>调用和返回</li>
</ul>
</li>
<li><p>陷阱(Trap)与陷阱指令  </p>
<ul>
<li>意外事故的中断</li>
<li>一般不提供给用户直接使用，在出现事故时，由CPU自动产生并执行(隐指令)</li>
<li>设置供用户使用的陷阱指令 提供给用户使用的陷阱指令，完成系统调用<ul>
<li>如 8086 INT TYPE 软中断</li>
</ul>
</li>
</ul>
</li>
<li><p>输入输出 </p>
<ul>
<li>如果I/O端口的编址空间被作为内存编制空间的一部分，就不需要输入输出指令，直接用访问存储器或内存的指令，就可以对外部设备输入输出。</li>
<li>若外部设备有自己的独立地址空间或单独编址就需要单独的输入输出指令。对外部设备进行保存。</li>
<li>入： 端口到CPU的寄存器  如：IN AX,n、IN AX,DX</li>
<li>出：CPU的寄存器到端口 如：OUT n,AL、OUT DX,AX</li>
</ul>
</li>
</ul>
<h3 id="7-3寻址方式"><a href="#7-3寻址方式" class="headerlink" title="7.3寻址方式"></a>7.3寻址方式</h3><p>寻址方式：确定本条指令的操作数地址或下一条要执行指令的指令地址</p>
<p>寻址方式：指令寻址、数据寻址</p>
<p><strong>指令寻址</strong></p>
<ul>
<li>顺序寻址：(PC)+1—&gt;PC</li>
<li>跳跃寻址：由转移指令指出</li>
</ul>
<p><strong>数据寻址</strong></p>
<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-1.png" style="zoom: 67%;">

<ul>
<li>形式地址：指令字中的地址</li>
<li>有效地址：操作数的真实地址(要用寻址方式和形式地址进行一定的运算才能得到有效地址)</li>
</ul>
<p>为了讲解方便，以下约定：指令字长=存储字长=机器字长</p>
<p>数据寻址方式</p>
<ul>
<li><p>立即寻址：形式地址给出的就是操作数。</p>
<ul>
<li>#：立即寻址的特征</li>
<li>特点：<ul>
<li>指令执行阶段不访存</li>
<li>A的位数限制了立即数的范围</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-2.png" alt></p>
</li>
<li><p>直接寻址</p>
<ul>
<li>EA=A 有效地址就是形式地址</li>
<li>LDA指令：将内存单元的数据取入CPU中保存在ACC。只是模型机规定不是所有机器都这样。</li>
<li>特点：<ul>
<li>执行阶段访问一次存储器</li>
<li>A的位数决定了该指令操作数的寻址范围</li>
<li>操作数的地址不易修改(必须修改A)</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-3.png" alt></p>
</li>
<li><p>隐含寻址</p>
<ul>
<li>操作数地址隐含在操作码中或参与运算的数据所在的位置由操作码直接给出</li>
<li>蓝色的寻址特征是指后面的A的寻址方式。该指令是加法需要两个操作数，并且将加法结果保存，指令只给出一个操作数，另一个操作数隐藏在ACC当中。</li>
<li>优势：<ul>
<li>指令字中少了一个地址字段，可缩短指令字长</li>
</ul>
</li>
<li>如：8086的MUL指令(乘法指令)被乘数隐含在 AX（16位）或 AL（8位）中。MOVS指令(字符串操作)源操作数的地址隐含在 SI 中目的操作数的地址隐含在 DI 中 </li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-4.png" alt></p>
</li>
<li><p>间接寻址</p>
<ul>
<li>操作数的地址保存在某一个内存单元当中。</li>
<li>有效地址由形式地址简介提供</li>
<li>间接寻址有两种形式：<ul>
<li>一次间址(两次访存)：通过访问形式地址获得有效地址，再通过有效地址获得操作数。可扩大寻址范围，也便于编制程序。</li>
<li>多次间址(多次访存)：根据A找到一个地址A<del>1</del>，前面的1是一个标识，表示该地址依然是一个间接地址。在多次之后找到标识为0才能找到有效地址。再找到操作数。</li>
</ul>
</li>
<li>间接寻址例：在主程序调用子程序时，子程序的最后的跳转指令的地址是主程序调用主程序的下一个地址。</li>
<li>特点：<ul>
<li>可扩大寻址范围</li>
<li>便于编制程序</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-5.png" alt></p>
</li>
<li><p>寄存器寻址</p>
<ul>
<li>EA=R<del>i</del> 有效地址为寄存器编号</li>
<li>优势：<ul>
<li>执行阶段不访存，只访问寄存器，执行速度快</li>
<li>寄存器个数有限，可缩短指令字长</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-6.png" alt></p>
</li>
<li><p>寄存器间接寻址</p>
<ul>
<li>EA = ( R<del>i</del>) 有效地址在寄存器中</li>
<li>根据寄存器编号找到有效地址，根据有效地址在内存中找到操作数。</li>
<li>特点：<ul>
<li>有效地址在寄存器中， 操作数在存储器中，执行阶段访存</li>
<li>便于编制循环程序</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-7.png" alt></p>
</li>
<li><p>基址寻址</p>
<ul>
<li><p>采用专用寄存器作基址寄存器</p>
<ul>
<li>EA = ( BR ) + A              BR为基址寄存器</li>
<li>基址寄存器和变址寄存器可以用来解决程序在装入内存时，逻辑地址到物理地址的映射</li>
<li>利用ALU(加法器)将BR和A相加等到操作数在内存单元中的地址。</li>
<li>特点：<ul>
<li>可扩大寻址范围</li>
<li>有利于多道程序(多道程序分时开始执行时程序的起始地址可以放在BR中，在执行过程中动态形成操作数地址，这种方式在计算机体系结构里被称为程序的动态定位)</li>
<li>BR 内容由操作系统或管理程序确定(用户无法自行修改)</li>
<li>在程序的执行过程中 BR 内容不变，形式地址 A 可变</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-8.png" alt></p>
</li>
<li><p>采用通用寄存器作基址寄存器</p>
<ul>
<li>特点：<ul>
<li>由用户指定哪个通用寄存器作为基址寄存器</li>
<li>基址寄存器的内容由操作系统确定</li>
<li>在程序的执行过程中 R0 内容不变，形式地址 A 可变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>变址寻址</p>
<ul>
<li><p>EA = ( IX ) +A</p>
<ul>
<li>IX 为变址寄存器（专用）</li>
<li>通用寄存器也可以作为变址寄存器</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>可扩大寻址范围</li>
<li>IX 的内容由用户给定</li>
<li>在程序的执行过程中 IX 内容可变，形式地址 A 不变</li>
<li>便于处理数组问题(A作数组的起始地址，IX作下标)</li>
</ul>
</li>
<li><p>例：设数据块首地址为 D，求 N 个数的平均值</p>
<ul>
<li>直接寻址<ul>
<li>LDA取D中数据取到ACC</li>
<li>ADD使ACC数据与给出的内存地址得数据相加</li>
<li>DIV 除法操作：立即数寻址方式 ，结果保存在ACC。再保存到指定内存单元中</li>
</ul>
</li>
<li>变址寻址<ul>
<li>LDA #0：ACC清零 立即数寻址方式</li>
<li>LDX #0：X清零 X为变址寄存器</li>
<li>ADD X,D：此时D为数组首地址</li>
<li>INX：使得变址寄存器得值+1</li>
<li>CPX #N：变址寄存器得值和N进行比较</li>
<li>BEN M：前条指令如果不等跳转到ADD。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-9.png" alt></p>
</li>
</ul>
</li>
<li><p>相对寻址</p>
<ul>
<li><p>EA = ( PC ) + A：相对当前的PC值</p>
</li>
<li><p>A 是相对于当前指令的位移量（可正可负，补码）</p>
</li>
<li><p>PC的值+A的值得到内存单元的地址</p>
</li>
<li><p>特点：</p>
<ul>
<li>A 的位数决定操作数的寻址范围</li>
<li>程序浮动(程序在内存单元中，它的存储位置发生变化)</li>
<li>广泛用于转移指令</li>
</ul>
</li>
<li><p>举例：设数据块首地址为 D，求 N 个数的平均值</p>
<ul>
<li>*-3：让PC值-3(用补码表示)。可以直接得到跳转指令成功的话下条指令的地址。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-10.png" alt></p>
</li>
<li><p>举例：按字节寻址的相对寻址</p>
<ul>
<li>在现代计算机中，一条指令还未取完或执行完，PC的值已经发生了变化。所以偏移地址应该为06H</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-11.png" alt></p>
</li>
</ul>
</li>
<li><p>堆栈寻址</p>
<ul>
<li><p>堆栈：先进后出</p>
<ul>
<li>硬堆栈(堆栈计算机内常用)：由多个寄存器作为栈顶，如果操作的话，操作数均来自栈顶，结果保存在栈顶</li>
<li>软堆栈：指定的存储空间。</li>
</ul>
</li>
<li><p>栈顶地址由<strong>SP</strong>指出。</p>
</li>
<li><p>通常情况下堆栈的栈底是地址最高的，栈顶是低地址。</p>
</li>
<li><p>操作</p>
<ul>
<li>进栈：（SP）-1—&gt;SP</li>
<li>出栈：（SP）+1—&gt;SP</li>
</ul>
</li>
<li><p>SP的修改与主存编制方法有关：如果数据长度不是一个编址单元，那么就不一定是减一或加一</p>
<ul>
<li>按字编址：+-1</li>
<li>按字节编址：<ul>
<li>存储字长16(二字节)：+-2</li>
<li>存储字长32(四字节)：+-4</li>
</ul>
</li>
</ul>
</li>
<li><p>例：</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.3-12.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="7-4指令格式举例"><a href="#7-4指令格式举例" class="headerlink" title="7.4指令格式举例"></a>7.4指令格式举例</h3><p>设计指令格式时应考虑的各种因素</p>
<ul>
<li>指令系统的 兼容性：新指令集最好可以不用修改原有程序就能使用</li>
<li>其它因素<ul>
<li>操作类型：指令个数、操作的难易程度、指令的使用频率</li>
<li>数据类型：确定哪些数据类型可参与操作</li>
<li>指令格式：指令字长是否固定，操作码位数、是否采用扩展操作码技术，地址码位数、地址个数、寻址方式类型</li>
<li>寻址方式：指令寻址、操作数寻址</li>
<li>寄存器个数：寄存器的多少直接影响指令的执行时间</li>
</ul>
</li>
</ul>
<p>例：IBM 360的五种指令格式</p>
<ul>
<li><p>RR格式：寄存器-寄存器，两个寄存器参加操作，结果保存在其中一个寄存器中</p>
</li>
<li><p>RX格式：寄存器-存储器，X位变址寄存器，B为基址寄存器。D为偏移地址</p>
</li>
<li><p>RS格式：应用于数据的存储操作，在寄存器和内存之间进行成组的数据传送。R<del>1</del>到R<del>3</del>(包括)成组传输到内存中，采用基址寻址方式</p>
</li>
<li><p>SI格式：两地址，地址长32位</p>
</li>
<li><p>SS格式：存储器和存储器当中数据进行操作，在内存中进行数据传输。</p>
</li>
<li><p>IBM 360 操作码长度都为8位</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.4-1.png" alt></p>
</li>
</ul>
<p>例：Intel 8086(复杂指令集计算机)</p>
<ul>
<li><p>指令字长 地址格式 1 ~ 6 个字节</p>
<ul>
<li>INC AX 1 字节</li>
<li>MOV WORD PTR[0204], 0138H 6 字节</li>
</ul>
</li>
<li><p>地址格式</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.4-2.png" alt></p>
</li>
</ul>
<h3 id="7-5RISC技术"><a href="#7-5RISC技术" class="headerlink" title="7.5RISC技术"></a>7.5RISC技术</h3><p>RISC：精简指令集计算机</p>
<p>CISC：复杂指令集计算机</p>
<p>RISC 的主要特征</p>
<ul>
<li>选用使用频度较高的一些 简单指令，复杂的指令不用硬件实现，由简单指令组合</li>
<li>指令 长度固定、指令格式种类少、寻址方式少</li>
<li>只有 LOAD / STORE 指令访存(只有这两指令进行访存)：其它指令的操作只能在寄存器与寄存器之间进行，结果也只能保存在寄存器中。</li>
<li>CPU 中有多个 通用 寄存器</li>
<li>采用 流水技术 一个时钟周期 内完成一条指令</li>
<li>采用 组合逻辑 实现控制器(硬件方式来实现)</li>
</ul>
<p>CISC 的主要特征</p>
<ul>
<li>系统指令 复杂庞大，各种指令使用频度相差大</li>
<li>指令 长度不固定、指令格式种类多、寻址方式多</li>
<li>访存 指令 不受限制</li>
<li>CPU 中设有 专用寄存器</li>
<li>大多数指令需要 多个时钟周期 执行完毕</li>
<li>采用 微程序 控制器</li>
</ul>
<p>RISC和CISC 的比较</p>
<ul>
<li>RISC更能 充分利用 VLSI 芯片的面积</li>
<li>RISC 更能 提高计算机运算速度 指令数、指令格式、寻址方式少，通用 寄存器多，采用 组合逻辑 ，便于实现 指令流水</li>
<li>RISC 便于设计，可 降低成本，提高 可靠性</li>
<li>RISC 不易 实现 指令系统兼容</li>
</ul>
<h2 id="八、CPU-的结构和功能"><a href="#八、CPU-的结构和功能" class="headerlink" title="八、CPU 的结构和功能"></a>八、CPU 的结构和功能</h2><h3 id="8-1CPU的结构"><a href="#8-1CPU的结构" class="headerlink" title="8.1CPU的结构"></a>8.1CPU的结构</h3><p><strong>CPU的功能</strong></p>
<p>控制器的功能</p>
<ul>
<li>取指令</li>
<li>分析指令</li>
<li>执行指令，发出各种操作命令(由这些操作命令控制相应部件完成指令要求操作)</li>
<li>控制程序输入及结果的输出—</li>
<li>总线管理</li>
<li>处理异常情况和特殊请求</li>
</ul>
<p>运算器的功能</p>
<ul>
<li>实现算术运算和逻辑运算</li>
</ul>
<p>CPU的功能需求：指令控制、操作控制、时间控制、处理中断、数据加工</p>
<p><strong>CPU结构框图</strong></p>
<p>控制总线：CPU向各个设备发出控制命令，外部设备向CPU提出的请求以及外部设备的状态。</p>
<p>数据总线：向外部设备写入或读取</p>
<p>寄存器：</p>
<ul>
<li><p>PC：指出要取的指令地址</p>
</li>
<li><p>IR：指令寄存器，从内存中取出的指令放入CPU中的IR</p>
</li>
<li><p>还有其它寄存器</p>
</li>
</ul>
<p>CU：操作控制、时间控制，对指令进行移码再给定时刻给出给定的操作命令</p>
<p>ALU：数据加工。</p>
<p>中断系统：做中断处理</p>
<p><strong>CPU的寄存器</strong></p>
<p>用户可见寄存器</p>
<ul>
<li>通用寄存器：存放操作数，也可作 某种寻址方式所需的 专用寄存器</li>
<li>数据寄存器：存放操作数（满足各种数据类型如整数、浮点数），两个寄存器拼接存放双倍字长数据（如乘法时用ACC和MQ）</li>
<li>地址寄存器 ：存放地址，其位数应满足最大的地址范围。用于特殊的寻址方式 段基值 栈指针(如段寄存器，堆栈寄存器)</li>
<li>条件码寄存器：存放条件码，做程序分支的依据(如正、负、零、溢出、进位等来判断是否跳转)</li>
</ul>
<p>用户不可见寄存器：在流水线结构的计算机中，流水段之间的流水段寄存器都是用户不可见</p>
<p>控制和状态寄存器</p>
<ul>
<li>控制寄存器<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.1-1.png" alt><ul>
<li>MAR：主存地址寄存器(保存存储器所需的地址)</li>
<li>MDR：主存数据寄存器</li>
<li>除了M(主存)剩下四个都是控制寄存器</li>
<li>MAR、MDR、IR用户不可见</li>
<li>PC用户空间</li>
</ul>
</li>
<li>状态寄存器<ul>
<li>状态寄存器：存放条件码 类似条件码寄存器</li>
<li>PSW寄存器(程序状态字寄存器)：存放程序状态字<ul>
<li>程序状态字：在中断或子程序调用过程中为了让程序正确返回断点，保存的现场断点等。中断各种各样，为了应对各种情况，设计者把软硬件状态相关的寄存器集合成一个大的寄存器，就是程序状态字。普遍较长，有些上千位。可以利用交换程序状态字的方式来完成程序现场的切换</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>控制单元 CU 和中断系统</strong></p>
<p>CU ：产生全部指令的微操作命令序列(包括先后顺序)</p>
<p>CU的设计方法：</p>
<ul>
<li>组合逻辑设计：速度快。<strong>硬连线逻辑</strong></li>
<li>微程序设计：简单，适用于复杂功能的指令设计。<strong>存储逻辑</strong></li>
</ul>
<p>中断8.4讲</p>
<h3 id="8-2-指令周期"><a href="#8-2-指令周期" class="headerlink" title="8.2 指令周期"></a>8.2 指令周期</h3><p>指令周期：取出并执行一条指令所需的全部时间或解释一条指令的全部时间。</p>
<p>完成一条指令过程：取指周期(取指、分析)、执行周期(执行)。不同CPU完成一条指令有不同的阶段，这里仅仅是一个例子。</p>
<p><strong>每条指令的指令周期不同</strong></p>
<p>只有取指周期，无执行周期。如：NOP(空操作)</p>
<p>取指周期和执行周期相同。如：ADD mem(在内存单元中取出操作数和ACC寄存器中的数据相加，结果保存在ACC中)，因为访存时间往往占比最大，取指需要访存一次，取操作数需要访存一次，所以所需时间基本相同。</p>
<p>取指周期和执行周期时间不同。如MUl mem(在内存单元中取出操作数和ACC寄存器中的数据相乘，结果保存在ACC中)</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-1.png" alt></p>
<ul>
<li><p>具有简介寻址的指令周期：间址周期是获取操作数的有效地址</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-2.png" alt></p>
</li>
<li><p>带有中断周期的指令周期：执行周期结束时，需要确认是否有中断请求，如果有需要去响应。响应的过程(保存断点，形成中断程序的入口地址等)都由中断周期完成</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-3.png" alt></p>
<p>指令周期流程</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-4.png" alt></p>
<p>CPU工作周期的标志</p>
<p>指令周期的不同阶段，控制器要做不同操作，因此控制器要在不同阶段发出不同的控制命令，也需要知道当前处于哪个阶段。</p>
<p>取值周期取的指令要送入IR。间址周期取得地址要送如IR得地址码部分或MDR的地址码部分。执行周期取得操作数要放入CPU中的寄存器。中断周期要把程序断点保存到内存单元指定位置。</p>
<p>用触发器来标识当前周期</p>
<blockquote>
<p>具体如何标识，老师也没有讲的很清楚。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-5.png" alt></p>
<p><strong>指令周期的数据流</strong></p>
<ol>
<li><p>取值周期数据流</p>
<ul>
<li>取操作：PC把地址送如MAR，MAR将地址送入地址总线，再由地址总线送入存储器。</li>
<li>读操作：读命令由CU控制，CU将控制信号送入控制总线，再由控制总线送入存储器。存储器来执行读操作，把相应数据送入数据总线，再送入MDR。再送入IR。</li>
<li>下一条指令的地址就是当前PC+1。由CU控制加1。为下一步做准备。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-6.png" alt></p>
</li>
<li><p>间址周期数据流(间接寻址)</p>
<ul>
<li>从MDR(或IR)中取出地址码部分送入MAR。进行内存单元访问，取出操作数的地址，MAR把地址送入地址总线，再送入存储器。CU发出读操作送入控制总线，再送入存储器。存储器完成读操作后将数据送入数据总线再送入MDR。这时MDR保存的有效地址。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-7.png" alt></p>
</li>
<li><p>执行周期数据流(第九章详解)</p>
<ul>
<li>不同指令的执行周期数据流不同</li>
</ul>
</li>
<li><p>中断周期数据流</p>
<ul>
<li>保持断点：CU给出地址放入MAR，MAR经过地址总线送入存储器，CU再经过控制总线将写命令送入存储器。这样PC就能将断点(中断后的下一条指令，实际是保存当前PC的值)送入MDR，再经过数据总线保存到存储单元中。</li>
<li>形成中断服务程序的入口地址：8.4节详细介绍。这里只要知道中断服务程序的入口地址由CU给出写入PC。</li>
<li>硬件关中断</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.2-8.png" alt></p>
</li>
</ol>
<h3 id="8-3指令流水"><a href="#8-3指令流水" class="headerlink" title="8.3指令流水"></a>8.3指令流水</h3><p>提高机器速度</p>
<ul>
<li>提高发出速度<ul>
<li>高速芯片  Cache  多体并行(多存储体)</li>
</ul>
</li>
<li>提高 I/O 和主机之间的传送速度<ul>
<li>中断  DMA  通道  I/O处理机</li>
</ul>
</li>
<li>提高运算器速度<ul>
<li>高速芯片  改进算法  快速进位链</li>
</ul>
</li>
<li>提高整机处理能力<ul>
<li>高速器件  改进系统结构，开发系统的并行性</li>
</ul>
</li>
</ul>
<p>并行的概念：</p>
<ul>
<li>并发：两个或两个以上事件在 <strong>同一时间段</strong> 发生</li>
<li>同时：两个或两个以上事件在 <strong>同一时刻</strong> 发生</li>
</ul>
<p>并行性的等级：</p>
<ul>
<li>过程级(粗粒度)：程序或进程并行。通常软件实现</li>
<li>指令级(细粒度)：两条或多条指令之间都处于被执行的状态，也可以是指令内部操作并行。通常硬件实现。</li>
</ul>
<p><strong>指令流水原理</strong></p>
<p>指令的串行执行：总有一个部件空闲</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-1.png" alt></p>
<p>指令的二级流水：取指和执行阶段时间上完全重叠，指令周期减半，速度提高1倍。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-2.png" alt></p>
<p>影响指令流水效率加倍的因素：</p>
<ul>
<li><p>执行时间&gt;取指时间</p>
<ul>
<li>指令部件缓冲区，用于缓冲取址部件取回的指令，如果速度过快，就在缓冲区进行缓冲，如果指令指令部件空闲，就可以到缓冲区取指令。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-3.png" alt></p>
</li>
<li><p>条件转移指令 对指令流水的影响</p>
<ul>
<li>必须等 上条 指令执行结束，才能确定 下条 指令的地址</li>
<li>可以采用分支预测法。</li>
</ul>
</li>
</ul>
<p>指令的六级流水</p>
<ul>
<li>FI：取指令</li>
<li>DI：指令译码</li>
<li>CO：形成操作数地址</li>
<li>FO：取操作数</li>
<li>EI：执行</li>
<li>WO：结果写回</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-4.png" alt></p>
<p><strong>影响指令流水线性能的因素</strong></p>
<p>结构相关：不同指令争用同一功能部件产生资源冲突。</p>
<ul>
<li><p>如：一条指令利用运算器计算下条指令地址，另外一条一条利用运算器来完成指定运算。</p>
</li>
<li><p>FI、FO、WO都要使用到内存单元，会造成资源冲突。</p>
</li>
<li><p>解决方法：停顿、指令存储器和数据存储器分开、指令预取技术(适用于访存周期短的情况)</p>
</li>
</ul>
<p>数据相关：不同指令因重叠操作，可能改变操作数的 读/写 访问顺序</p>
<ul>
<li>写后读相关(RAW)：对某个存储单元或存储器先写操作后读操作。</li>
<li>读后写相关(WAR)</li>
<li>写后写相关(WAW)</li>
<li>解决方法：后推法(前一条指令完成第二条指令才开始)、采用旁路技术(从前指令的运算器输出后直接送入后指令的运算器)</li>
</ul>
<p>控制相关：由转移指令引起</p>
<ul>
<li><p>如果CPX比较相等顺序执行，不相等就跳转到M</p>
</li>
<li><p>转移指令会使得并行的一些指令作废</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-5.png" alt></p>
<p><strong>流水线性能</strong></p>
<p>吞吐率：单位时间内 <strong>流水线所完成指令</strong> 或 <strong>输出结果</strong> 的 <strong>数量</strong></p>
<p>​    设m段的流水线各段时间为Δt</p>
<ul>
<li><p>最大吞吐率：满负荷运转，没有发生资源冲突，数据相关，控制相关等。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-6.png" alt></p>
<blockquote>
<p>如果满负荷运转，每经过一个Δt就会有一个结果输出</p>
</blockquote>
</li>
<li><p>实际吞吐率：实际一段时间内完成指令条数</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-7.png" alt></p>
<blockquote>
<p>m×Δt为第一条指令，(n-1)×Δt为后面的指令</p>
</blockquote>
</li>
</ul>
<p>加速比S<del>p</del>：<strong>m</strong> 段的 <strong>流水线的速度</strong> 与等功能的 <strong>非流水线的速度</strong> 之比</p>
<blockquote>
<p>这里给出的公式都是理想型的。实际<strong>m</strong> 段的 <strong>流水线的速度的时间</strong> 与等功能的 <strong>非流水线的速度的时间</strong> 之比</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-8.png" alt></p>
<p>效率：流水线中各功能段的 <strong>利用率</strong></p>
<ul>
<li>建立时间：第一条指令进入流水到结果输出</li>
<li>排空时间：最后一条指令进入流水线到结果输出</li>
<li>由于流水线有 <strong>建立时间</strong> 和 <strong>排空时间</strong>，因此各功能段的 <strong>设备不可能 一直</strong> 处于 <strong>工作</strong> 状态。</li>
<li>空间：指流水段。</li>
<li>时间：流水段的运行。</li>
<li>效率=工作面积 除 (T<del>时间</del>×S<del>空间</del>)</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-9.png" alt></p>
<p><strong>流水线的多发技术</strong></p>
<p>超标量技术：</p>
<ul>
<li>每个时钟周期内可 并发多条独立指令 配置多个功能部件</li>
<li>不能调整 指令的 执行顺序通过编译优化技术，把可并行执行的指令搭配起来</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-10.png" alt></p>
<p>超流水线技术：</p>
<ul>
<li><p>在 一个时钟周期  内 再分段。在一个时钟周期内 一个功能部件使用多次</p>
</li>
<li><p>不能调整 指令的 执行顺序靠编译程序解决优化问题</p>
</li>
<li><p>在流水线的设计过程中，流水段之间要加入锁存器，每个流水段的结果保存到锁存器作为下个流水段执行时它的操作信号、控制信号或操作数据。 但在超流水线技术中，依然有锁存器，但一个流水段的再细分是没有锁存器。</p>
</li>
<li><p>不同指令在同一流水段中，相互的信号不能叠加</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-11.png" alt></p>
<p>超长指令字技术：</p>
<ul>
<li>由编译程序 挖掘 出指令间 潜在 的 并行性(根据计算机中执行部件的数量和种类，指令之间也不能有相关性)，将 多条 能 并行操作 的指令组合成 一条具有 多个操作码字段 的 超长指令字（可达几百位）</li>
<li>采用 多个处理部件</li>
<li>图上黑色为执行部件，执行部件有多个，如取数，存数，定点运算，浮点运算。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-12.png" alt></p>
<p><strong>流水线结构</strong></p>
<p>指令流水线结构：</p>
<ul>
<li>完成一条指令分 6 段， 每段需一个时钟周期(不同类型机器实现方式不同，这里只是参考)</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-13.png" alt></p>
<p>运算流水线：</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.3-14.png" alt></p>
<h3 id="8-4中断系统"><a href="#8-4中断系统" class="headerlink" title="8.4中断系统"></a>8.4中断系统</h3><p><strong>概述</strong></p>
<p>引起中断的因素</p>
<ul>
<li>人为设置的中断：如 转管指令</li>
<li>程序性事故：溢出、操作码不能识别、除法非法</li>
<li>硬件故障</li>
<li>I/O 设备</li>
<li>外部事件：用 键盘中断 现行程序</li>
</ul>
<p><strong>中断请求标记和中断判优逻辑</strong></p>
<p>中断请求标记  INTR(中断触发器)</p>
<ul>
<li>一个请求源 一个INTR 中断请求标记触发器</li>
<li>多个INTR 组成 中断请求标记寄存器</li>
<li>每位依次：是否发生电源掉电。是否过热等等。每位标识一个中断源。</li>
<li>可以 INTR 分散 在各个中断源的 接口电路中 或 INTR 集中 在 CPU 的中断系统 内 </li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-1.png" alt></p>
<p>中断判优逻辑</p>
<ul>
<li>硬件实现（排队器）<ul>
<li>分散 在各个中断源的 接口电路中(第五章中链式排队器)</li>
<li>集中 在CPU内 或外部某个专门用于判优的部件</li>
<li>INTP<del>i</del>输出1的要求是前面中断请求高的都没有中断请求。只有一位是1其它都是0。优先级高的若为1会将1传递给后面的，使得后面都为0。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-2.png" alt></p>
<ul>
<li>软件实现（程序查询）<ul>
<li>按优先级的顺序，依次判断是否有中断请求，如果有转入相应的服务程序入口地址，如果没有就判断下一优先级的中断请求</li>
</ul>
</li>
</ul>
<p><strong>中断服务程序入口地址的寻找</strong></p>
<ul>
<li><p>硬件向量法：硬件的方式来形成中断向量地址</p>
<ul>
<li>根据哪个中断源，确定执行哪个中断服务程序。用中断向量地址去找到中断服务程序的入口地址。</li>
<li>中断服务程序的入口地址有两种方法给出<ul>
<li>在中断向量地址的存储单元中存放一条跳转指令其中包含了中断服务程序的入口地址</li>
<li>给出向量地址后，在内存单元中指定的位置保存的中断服务程序的入口地址，取回后送入PC中，去执行中断服务程序。</li>
</ul>
</li>
<li>特点：速度快、设计灵活性低</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-3.png" alt></p>
</li>
<li><p>软件查询法</p>
<ul>
<li>SKP：跳过下一条指令。SKP DZ 1#功能为：查询第一号中断源他的触发器D为0还是1。如果为1就执行相应中断服务程序。如果为1就跳过这条命令。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-4.png" alt></p>
</li>
</ul>
<p><strong>中断响应</strong></p>
<p>响应中断的条件</p>
<ul>
<li><p>假如CPU只能支持单重中断(CPU在响应某个中断源的中断请求并且开始执行中断源的中断服务程序的情况下，即使有新的中断源发出中断服务请求CPU也不能进行响应)</p>
</li>
<li><p>当允许中断触发器 EINT=1时 才能运行中断源发出的中断请求。</p>
</li>
</ul>
<p>响应中断的时间</p>
<ul>
<li><p>通常情况下执行阶段结束以后才能响应中断请求。但有些复杂指令执行时间长，为了及时的处理一些异常，允许CPU在执行过程中进行中断响应。 </p>
</li>
<li><p>指令执行周期结束时刻由CPU发查询信号。查询信号会发到每个中断源中的中断请求触发器，查询信号会驱动中断请求触发器，将触发器输出端置1，再把中断请求信号发入排队器。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-5.png" alt></p>
</li>
</ul>
<p>中断隐指令</p>
<ul>
<li><p>保护程序断点：</p>
<ul>
<li>断点存于 特定地址（0号地址）内</li>
<li>断点进栈</li>
</ul>
</li>
<li><p>寻址服务程序入口地址</p>
<ul>
<li>硬件向量法：将中断向量地址送入PC。PC中保存的向量地址包含了中断服务程序的入口地址或一条跳转指令(会跳转到中断服务程序)</li>
<li>软件查询法：将中断识别程序入口地址 M送入PC</li>
</ul>
</li>
<li><p>硬件关中断：在单重中断机器的执行中断服务程序过程中有新的中断源会打断当前的中断服务程序的执行。 在多重中断CPU中采用关中断方式也是为了保存程序断点保存程序现场。</p>
<ul>
<li>中断允许触发器置0</li>
<li>IN中断标记：CPU当前是否允许响应新的中断请求</li>
<li>EINT 允许中断标记</li>
<li>R—S触发器：都为R—S触发器</li>
<li>中断允许触发器输出为1，另外要有中断请求(排队器送出的信号中至少有一个为1，实际中断排队器输出信号如果有中断请求，只有一根线是1，所以用或门表示中断请求，而且1对应的就是中断响应优先级最高的中断请求)。两者都为1表示允许相应中断，而且有中断请求。那么这时通过S端把中断标记寄存器置1，一旦置1，那么中断允许触发器就置0。另外中断排队器排出的结果还要送给向量地址形成部件用来形成向量地址送给PC，为执行中断服务程序做准备</li>
</ul>
</li>
</ul>
<blockquote>
<p>隐指令表示这三个操作都是由计算机硬件来完成的，但是并不是在某条具体指令的驱动下完成的。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-6.png" alt></p>
<p><strong>保存现场和恢复现场</strong></p>
<p>保护现场</p>
<ul>
<li>保存断点：由隐指令来做<ul>
<li>中断隐指令一共三个操作：保存断点、形成中断服务程序的入口地址、硬件关中断</li>
</ul>
</li>
<li>保存寄存器内容：通过中断服务程序完成</li>
</ul>
<p>恢复现场：由中断服务程序完成</p>
<ul>
<li>如：在保护现场过程中，保存寄存器内容可以用push指令把寄存器内容压入堆栈，恢复时用出栈指令</li>
<li>PUSH、POP、IRET都是相应指令</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-7.png" alt></p>
<p><strong>多重中断</strong></p>
<p>概念：CPU在执行中断服务程序的过程中，如果有新的中断源提出了中断请求，并且新的中断源并且它的优先级比正在处理的它的优先级更高就要进行响应</p>
<p>实现多重中断的条件</p>
<ul>
<li>CPU内部有一个允许中断触发器，在中断服务时要响应中断服务程序，EINT要提前被打开。</li>
<li>优先级别高 的中断源 有权中断优先级别低 的中断源</li>
<li>例：在执行主程序过程中，中断源B、C同时提出中断请求，响应优先级高的B。执行结束后返回主程序，这时中断源C还在CPU只要发出查询信号CPU主程序的执行要再次中断，响应中断源C的中断请求。在执行过程中，即使低优先级的D发出中断请求，CPU不会响应继续执行C。返回主程序，再响应D，执行D时，优先级更高的A提出中断请求，CPU就执行中断服务程序A，结束后再执行D，D结束后返回主程序。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-8.png" alt></p>
<p>屏蔽技术</p>
<p>(第五章有介绍)可以通过中断屏蔽技术，设置中断屏蔽字，来改变中断服务的优先级，从而提高系统设计和响应的灵活性</p>
<ul>
<li><p>屏蔽触发器的作用：设置中断屏蔽字</p>
<ul>
<li>MASK：中断屏蔽触发器</li>
<li>INTR：保存中断屏蔽字</li>
<li>D：完成触发器。</li>
<li>图左：D表示设备已经完成工作向CPU提出中断请求。该中断请求能提出的条件是这个中断源还未被屏蔽。那么MASK的Q端输出应该为0表示未屏蔽。在D为1，MASK的非端输出也为1时，才能向中断请求触发器在CPU查询信号的作用下使中断请求触发器输出为0表示不能通过这个电路向CPU发出中断请求。</li>
<li>图右：如果排队器集中在CPU或某个部件中，就可以采用该方法。实际上该排队器可以和中断屏蔽触发器结合使用。MASK<del>i</del>为各个中断源对应的屏蔽信号。正在执行某个中断服务请求，该中断服务请求就对应了一个屏蔽字。字的长度和中断源的个数相等。每个MASK<del>i</del>对应了中断屏蔽字的一位。如果MASK<del>i</del>=1表示对应的中断源的中断服务请求不会被响应，也无法提出。这里MASK<del>i</del>为1，那么MASK<del>i</del>的非就为0。那么INTP<del>i</del>输出为0就无法进入中断排队器。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-9.png" alt></p>
</li>
<li><p>屏蔽字</p>
<ul>
<li>假如有16个中断源，每个中断源都对应了一个屏蔽字。每个屏蔽字表示当这个中断源它的中断服务程序在执行的过程中是否允许某一个中断源它提出的中断服务请求进入到中断排队器中排队。如果对应值为1就表示屏蔽，0表示开放</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-10.png" alt></p>
</li>
<li><p>屏蔽技术可改变处理优先等级</p>
<ul>
<li>处理优先级，可改变(通过重新设置屏蔽字)</li>
<li>中断响应优先级，中断屏蔽字(由硬件电路(排队器)给出)不能改变。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-11.png" alt></p>
</li>
<li><p>在修改之前：A、B、C、D同时发出中断请求，A响应级别最高，主程序不能屏蔽任何中断，所以中断屏蔽字为全0。响应A执行A的中断服务程序，在执行A过程中，会把中断屏蔽字置为全1。尽管B、C、D还有中断服务请求但不会被响应。然后执行B的中断服务程序，C的中断服务程序，D的中断服务程序。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-12.png" alt></p>
</li>
<li><p>在修改后，中断处理的优先级为A、D、C、B：A、B、C、D同时发出中断请求进入中断排队器排队，A响应级别最高，响应A执行A的中断服务程序，在执行A过程中，会把中断屏蔽字置为全1。B、C、D不能打断A的执行，结束后返回主程序。中断屏蔽字改为全0。此时B优先级最高，响应B，执行B过程中中断屏蔽字C、D都是开放的。C、D提出的中断服务请求能够进入中断排队器进行排队，C优先级更高，响应C。中断屏蔽字置为C对应的屏蔽字，C只能屏蔽C本身和B，所以D还能发出中断服务请求并且进入中断排队器。就执行D中断服务程序。结束后返回C，再结束后返回B，直到处理完</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-13.png" alt></p>
</li>
<li><p>屏蔽技术的其它作用</p>
<ul>
<li>可以人为地屏蔽某个中断源的请求</li>
</ul>
</li>
<li><p>新屏蔽字的设置</p>
<ul>
<li>保护现场：利用push指令，把一些寄存器的值保护起来，以便返回时用到。</li>
<li>置屏蔽字</li>
<li>开中断：要提前开中断，为了能够实现多重中断。</li>
<li>关中断：恢复现场之前关闭</li>
<li>恢复现场</li>
<li>恢复屏蔽字：来使得恢复现场过程不被打断</li>
<li>开中断</li>
<li>中断返回</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-14.png" alt></p>
</li>
</ul>
<p>多重中断的断点保护</p>
<ul>
<li><p>断点进栈：由中断隐指令(硬件)完成</p>
</li>
<li><p>断点存入“0”(带引号，可以是一个给定的地址)地址：中断隐指令完成</p>
</li>
<li><p>中断周期</p>
<ul>
<li>保持断点：0地址送入MAR、命令存储器写操作、断点写入0地址。断点在PC中(保存了下一条要执行的地址，指的是当前执行的程序的下一条指令的地址)。PC值送入MDR。MDR再送入主存进行保存</li>
</ul>
</li>
<li><p>如果一直保存在指定地址，那么多重保存会使得后面断点冲掉前面断点的保存</p>
</li>
<li><p>例</p>
<ul>
<li>SERVE：中断服务程序的入口地址</li>
<li>将ACC寄存器内容保存到SAVE中</li>
<li>LDA 0：取数操作，将地址为0的内存单元中的数据放入ACC寄存器。</li>
<li>STA RETURN：将上操作取出的值保存到RETURN单元。</li>
<li>0地址内容转存：转存的就是断点，通过转存把程序断点保护</li>
<li>JMP @ RETURN：跳转到RETURN保存的地址，就是程序的断点。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.4-15.png" alt></p>
</li>
</ul>
<h2 id="九、控制单元的功能"><a href="#九、控制单元的功能" class="headerlink" title="九、控制单元的功能"></a>九、控制单元的功能</h2><p>控制单元是计算机系统的控制核心，在控制单元的控制之下，整个计算机系统才能正确、持续、稳定的运行</p>
<h3 id="9-1微操作命令分析"><a href="#9-1微操作命令分析" class="headerlink" title="9.1微操作命令分析"></a>9.1微操作命令分析</h3><p>在取值、间址、分析、执行、中断的过程中，控制单元要发出哪些微控制命令。</p>
<p>微操作命令：这些命令在指令解释过程中由控制单元发出的一些指令，这些指令所要完成的动作和整条指令要完成的功能相比小得多，所以叫微操作命令。</p>
<p>在第七章已经讲解了完成一条指令可以分为4个工作周期：取指周期、间址周期、执行周期、中断周期</p>
<h6 id="取址周期"><a href="#取址周期" class="headerlink" title="取址周期"></a>取址周期</h6><p>取值过程中不需要ALU，所以图上未给出。</p>
<ol>
<li>PC把包含的指令地址送入MAR，再经过地址总线送入存储器</li>
<li>然后由控制单元向存储器发出读命令，读出的数据由存储器通过数据总线送入MDR再由MDR送入IR中，指令就被取到IR寄存器。</li>
<li>在取值周期还要完成译码任务，就是确定该指令具体做什么操作。是由指令操作码部分给出。所以把指令的操作码部分送入CU，由CU确定操作。</li>
<li>结束后PC+1</li>
</ol>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.1-1.png" alt></p>
<h6 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h6><p>通过间址周期把操作数的地址从存储器中取出放入指令寄存器中所保存的指令的地址码部分。</p>
<ol>
<li>先将指令形式地址送入MAR，也就是IR中地址码部分。再由MAR通过地址总线传输到存储器的地址线上。要实现该操作，控制器要发出将IR的地址码部分送给MAR的控制信号，再由控制器向存储器发出读操作命令。</li>
<li>存储器接收到地址和读操作命令后，在指定的内存单元中，取出操作数，通过数据总线，传输给MDR</li>
<li>被取出的地址再送入IR中。这时IR中地址码部分就是操作数的物理地址。</li>
</ol>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.1-2.png" alt></p>
<h6 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h6><ul>
<li>非访存类指令<ul>
<li>CLA(对ACC清零)：控制器将0送入ACC</li>
<li>COM(将ACC取反)：也是一条控制命令</li>
<li>SHR(算术右移)：右移左边的数据写入右侧。同时最高位ACC<del>0</del>再写回ACC<del>0</del>(最高位补原来符号位)</li>
<li>CSL(循环左移)：最高为移到最低位，右边数据写入左边，ACC<del>0</del>写到ACC<del>n</del>(最后一位)</li>
<li>STP(停机指令)：将停机标志G置零</li>
</ul>
</li>
<li>访存指令<ul>
<li>加法指令(ADD X)：ADD是操作码 X为其中一个数的地址码<ul>
<li>Ad(IR)—&gt;MAR：将IR中地址码部分送入MAR</li>
<li>1—&gt;R：CU发出读命令。</li>
<li>M(MAR)—&gt;MDR：读命令给出后把MAR中保存的地址作为存储器地址，把数据取出。</li>
<li>(ACC) + (MDR)—&gt;ACC ：将ACC内容和MDR内容相加</li>
</ul>
</li>
<li>存数指令 STA X：把ACC中数据保存到内存单元X中<ul>
<li>Ad(IR)—&gt;MAR：把IR中保存的指令的地址码部分送入MAR进行访存</li>
<li>1—&gt;W：写命令</li>
<li>ACC—&gt;MDR：ACC中内容送入MDR寄存器</li>
<li>MDR—&gt;M(MAR)：写入MAR寄存器指定的内存单元中完成写操作</li>
</ul>
</li>
<li>取数指令 LDA X：把内存单元X的数据取出保存在ACC寄存器<ul>
<li>Ad (IR)—&gt;MAR：把IR中的地址码部分送入MAR</li>
<li>1—&gt;R：发出读命令</li>
<li>M (MAR)—&gt;MDR：把MAR指定的内存单元的内容送入MDR中</li>
<li>MDR—&gt;ACC：把MDR寄存器内容存入ACC</li>
</ul>
</li>
</ul>
</li>
<li>转移指令<ul>
<li>无条件转移 JMP X<ul>
<li>Ad (IR)—&gt;PC：把IR中地址码部分送入PC</li>
</ul>
</li>
<li>条件转移 BAN X(举例一种如果上次计算结果值为负就转移)<ul>
<li><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.1-3.png" style="zoom:45%;">：通过判断ACC最高位A<del>0</del>是正是负。如果是1就是将IR保存的地址码部分送入PC跳转成功。如果A<del>0</del>为0表示非负，PC送入PC跳转不成功接着执行下一条</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>三类指令的指令周期：</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.1-4.png" alt></p>
<h6 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h6><ol>
<li><p>保存断点</p>
<ul>
<li><p>存入”0”地址</p>
<ul>
<li>0—&gt;MAR：0送入MAR</li>
<li>1—&gt;W：控制单元向存储器发出写命令</li>
<li>PC—&gt;MDR：保存PC内容送入MDR</li>
<li>MDR—&gt;M(MAR)：把MDR的内容保存到MAR指定的内存单元中</li>
</ul>
</li>
<li><p>程序断点进栈</p>
<ul>
<li>( SP ) - 1—&gt;MAR：形成新的栈顶地址送入MAR</li>
<li>1—&gt;W：控制单元向存储器发出写命令</li>
<li>PC—&gt;MDR：保存PC内容送入MDR</li>
<li>MDR—&gt;M(MAR)：把MDR的内容保存到MAR指定的内存单元中</li>
</ul>
<blockquote>
<p>1表示立即数或有效(不清)，1—&gt;W表示立即进行W操作</p>
</blockquote>
</li>
</ul>
</li>
<li><p>形成中断服务程序的入口地址(这里采用硬件向量法)：向量地址保存到PC中</p>
</li>
<li><p>关中断：把0送到EINT中断允许触发器中</p>
</li>
</ol>
<h3 id="9-2控制单元的功能"><a href="#9-2控制单元的功能" class="headerlink" title="9.2控制单元的功能"></a>9.2控制单元的功能</h3><h6 id="控制单元的外特性"><a href="#控制单元的外特性" class="headerlink" title="控制单元的外特性"></a>控制单元的外特性</h6><p>控制单元的输入输出信号</p>
<ul>
<li><p>输出信号包括了CPU内部的控制信号，控制CPU内部件的执行，另外还有送到系统总线的控制信号，如控制外部设备总线的操作。</p>
</li>
<li><p>输入信号包括来自于指令寄存器的指令的操作码部分。还有时钟信号控制单元在时钟信号的控制之下进行工作还有各种标志，这些标志为指令正确执行必须要有的。如：跳转指令它的运行结果的标志是本条指令是否跳转的依据。</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-1.png" alt><strong>输入信号</strong></p>
<ul>
<li>时钟<ul>
<li>CU受时钟控制</li>
<li>各种微操作命令在时钟信号的控制之下，在指定的时间点被发出</li>
<li>一个时钟脉冲，发一个操作命令或一组需同时执行的操作命令</li>
</ul>
</li>
<li>指令寄存器：OP ( IR ) CU<ul>
<li>控制信号 与操作码有关</li>
<li>保存了要执行的指令，操作码部分必须送入CU中，由控制单元进行译码，指出这条指令要做什么操作，以便指令执行阶段对不同的指令发出不同的控制信号</li>
</ul>
</li>
<li>标志<ul>
<li>CU 受标志控制</li>
</ul>
</li>
<li>外来信号<ul>
<li>如：<ul>
<li>INTR 中断请求</li>
<li>HRQ 总线请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>输出信号</strong></p>
<ul>
<li><p>CPU内部的各种控制信号</p>
<ul>
<li>R<del>i</del>—&gt;R<del>j</del>：寄存器和寄存器之间的数据传输</li>
<li>(PC) + 1—&gt;PC：控制PC+1</li>
<li>ALU ＋、－、与、或 ……：控制运算器做数据运算和逻辑运算</li>
</ul>
</li>
<li><p>送至控制总线的信号</p>
<ul>
<li>IO/M：低电平访问I/O，高电平访问存储器</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-2.png" alt></p>
</li>
</ul>
<h6 id="控制信号举例"><a href="#控制信号举例" class="headerlink" title="控制信号举例"></a>控制信号举例</h6><p><strong>不采用CPU内部总线的方式</strong></p>
<p>即：CPU内部的各个部件采用分散连接的方式</p>
<ul>
<li><p>取指令：PC要送到MAR，告诉要取指令的地址。MAR要把地址送入内存，取回的指令送到MDR，再被送到IR寄存器。如果取回的是数据要送入AC(ACC)中。如果是加法指令取回的数据可能直接送入ALU。</p>
</li>
<li><p>若是间接寻址，拿回的是操作数的地址，那MDR要把地址送入MAR中，以便把操作数从内存单元中取出。</p>
</li>
<li><p>IR寄存器的操作码部分要送给CU，进行译码。</p>
</li>
<li><p>时钟要送入CU中，以控制控制单元发出各种类型的控制信号</p>
</li>
<li><p>这些控制信号控制ALU做各种操作</p>
</li>
<li><p>以ADD @ X(间接寻址的方式)为例</p>
<ul>
<li><p>图1取指周期、图2间址周期、图3执行周期</p>
</li>
<li><p>取值周期：操作发起从PC开始，由CU控制PC和MAR之间的数据通路C<del>0</del>把PC内容送给MAR。再把数据经过C<del>1</del>控制电路送出，送给内存单元的地址线。同时CU要发出一个读命令告诉CPU要进行读操作。取回的指令，从内存单元经过C<del>2</del>放入MDR中，再由MDR经过C<del>3</del>送入IR寄存器。IR的操作码部分经过C<del>4</del>送入CU，进行译码，最后PC+1。这里从C<del>0</del>到C<del>4</del>五个控制信号都由CU产生</p>
</li>
<li><p>间址周期：指令已经取回，指令在IR和MDR都有保存。形式地址从MDR(或IR)获得。MDR将指令的地址码部分通过C<del>5</del>送入MAR寄存器，在通过C<del>1</del>送到存储器地址线。然后控制单元发出读命令，通过C<del>2</del>读到的操作数的地址送入到MDR，再由C<del>3</del>把MDR中保存的操作数的地址保存如IR的地址码部分。</p>
</li>
<li><p>执行周期：操作数的地址现在保存在MDR(和IR)中。C<del>5</del>由CU发出指令将MDR内容送入MAR。再通过C<del>1</del>把MAR的地址，送入内存单元的地址线。再由CU发出读操作命令，读入的数据通过C<del>2</del>被送入MDR。C<del>6</del>和C<del>7</del>打开把操作数送入ALU。ALU通过控制信号得知做加法操作。在控制信号的控制之下完成加法，并通过C<del>8</del>把结果保存到C<del>8</del></p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-3.png" alt>)<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-4.png" alt>)<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-5.png" alt></p>
<p><strong>采用</strong> <strong>CPU</strong> <strong>内部总线方式</strong></p>
<p>Y：作为ALU输入的一个寄存器</p>
<p>Z：保存ALU的输出</p>
<p>以ADD @ X取值为例</p>
<ul>
<li><p>图1取指周期、图2间址周期、图3执行周期</p>
</li>
<li><p>取指周期：PC通过控制信号PC<del>o</del>(OUT缩写)把保存的值送入CPU内部总线，再通过MAR<del>i</del>送入MAR。MAR把指令地址送入地址线，CU发出读命令送入存储器。读出的指令通过数据线送入MDR中，再经过MDR<del>o</del>送到CPU内部总线，再经过IR<del>i</del>送入IR。IR保存的指令的操作码部分送入CU进行译码，PC+1。</p>
</li>
<li><p>间址周期：MDR通过MDR<del>o</del>把形式地址送入CPU内部总线，再经过MAR<del>i</del>送入MAR中。再由MAR送入地址线。CU把1送给R(发出读操作)。读回的内容经过数据线送入MDR中，然后MDR输出控制信号有效通过内部总线再由IR<del>i</del>送入IR。</p>
</li>
<li><p>执行周期：MDR通过MDR<del>o</del>把保存的操作数的地址再经过MAR<del>i</del>送到MAR再经过地址线送到内存。CU发出读命令信号驱动内存读操作。通过数据线送到MDR。将MDR保存的操作数通过MDR<del>o</del>经过CPU内部总线再Y<del>i</del>的控制之下送入Y寄存器。Y保存的数据送入ALU，AC保存的数据通过内部总线送入ALU。CU控制ALU做加法操作。结果保存到Z。Z再经过内部总线，送入AC。</p>
</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-6.png" alt>)<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-7.png" alt>)<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-8.png" alt></p>
<h6 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h6><p><strong>机器周期</strong></p>
<p>概念：所有指令执行过程中的一个基准时间</p>
<p>考虑因素：每条指令的执行步骤，每一步骤所需的时间</p>
<p>基准时间的确定：</p>
<ul>
<li>以完成最复杂指令功能的时间为准</li>
<li>以访问一次存储器的时间为基准。通常访存操作耗时最长</li>
</ul>
<p>若指令字长=存储字长，取指周期=机器周期</p>
<blockquote>
<p>12m晶振的51单片机时钟周期为1/12us，1机器周期等于12个时钟周期，所以机器周期为1us，而指令周期等于1-4（大概）个机器周期</p>
</blockquote>
<p><strong>时钟周期</strong></p>
<p>一个机器周期内可完成若干个微操作</p>
<p>每个微操作需一定时间(可能一个时钟周期内完成，也可能多个)</p>
<p>将一个机器周期分成若干个时间相等的时间段（节拍、状态、时钟周期）</p>
<p>时钟周期是控制计算机操作的最小单位时间</p>
<p>用时钟周期控制产生一个或几个微操作命令</p>
<ul>
<li><p>T<del>0</del>、T<del>1</del>、T<del>2</del>、T<del>3</del>：不同的节拍，在节拍的上升点，可以利用上升点让CU产生不同的控制命令让CPU内部的各个部件以及计算机的其他部件发出响应操作</p>
</li>
<li><p>节拍是机器中最小的时间单位</p>
<blockquote>
<p>这边略微不清楚</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-9.png" alt></p>
</li>
</ul>
<p><strong>多级时序系统</strong></p>
<p>指令周期、机器周期、节拍(状态)组成多级时序系统</p>
<blockquote>
<p>PPT上无指令周期</p>
</blockquote>
<p>一个指令周期包含若干个机器周期</p>
<p>一个机器周期包含若干个时钟周期</p>
<p>机器周期包含的节拍数不同，指令周期包含的机器周期不同</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-10.png" alt></p>
<p><strong>机器速度与机器主频的关系</strong></p>
<p>在机器周期所含时钟周期数 相同 的前提下，两机 平均指令执行速度之比 等于 <strong>两机主频之比</strong></p>
<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9.2-11.png" style="zoom:50%;">

<p>机器速度 不仅与 主频有关 ，还与机器周期中所含时钟周期（主频的倒数）数 以及指令周期中所含的 机器周期数有关。</p>
<h6 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h6><p>产生不同微操作命令序列所用的时序控制方式</p>
<p><strong>同步控制方式</strong>：任一微操作均由统一基准时标的时序信号控制</p>
<ul>
<li>采用定长的机器周期：每个机器周期含有相同的节拍数<ul>
<li>以 最长 的微操作序列和 最复杂 的微操作作为 标准</li>
</ul>
</li>
<li>采用不定长的机器周期：机器周期内，节拍数不等</li>
<li>采用中央控制和局部控制相结合的方法(与总线类似)<ul>
<li>一部分操作由中央控制节拍来控制，延长的部分由局部控制节拍控制</li>
<li>局部控制的节拍宽度与中央控制的节拍宽度一致</li>
</ul>
</li>
</ul>
<p><strong>异步控制方式</strong>：无基准时标信号、无固定的周期节拍和严格的时钟同步、采用应答方式</p>
<p><strong>联合控制方式</strong>：同步与异步相结合</p>
<ul>
<li>大部分情况下用同步，特殊情况下有一些微操作，它的完成时间很难确定就采用异步控制</li>
</ul>
<p><strong>人工控制方式</strong>：</p>
<ul>
<li>Reset：机器恢复起始状态</li>
<li>连续 和 单条 指令执行转换开关：让指令一条一条走或连续</li>
<li>符合停机开关：</li>
</ul>
<h2 id="十、控制单元的设计"><a href="#十、控制单元的设计" class="headerlink" title="十、控制单元的设计"></a>十、控制单元的设计</h2><h3 id="10-1组合逻辑设计"><a href="#10-1组合逻辑设计" class="headerlink" title="10.1组合逻辑设计"></a>10.1组合逻辑设计</h3><h6 id="组合逻辑控制单元框图"><a href="#组合逻辑控制单元框图" class="headerlink" title="组合逻辑控制单元框图"></a>组合逻辑控制单元框图</h6><p><strong>CU</strong> <strong>外特性</strong></p>
<ul>
<li>节拍发生器：控制CU发出顺序，时间。产生多个节拍信号。在每个节拍信号的起始端CU可产生给定的控制命令</li>
<li>0到2^n-1^只有一条线是高电平</li>
<li>C<del>0</del>C<del>k</del>为发出的控制信号。同时一个或几个有效。几个有效表示可以并行操作或有先后顺序但在一个节拍内能完成</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-1.png" alt></p>
<p><strong>节拍信号</strong></p>
<p>节拍信号是在时钟控制下产生的</p>
<p>节拍信号的宽度或高电平的长度是一个时钟周期</p>
<p>在第一个时钟周期发出T<del>0</del>第二个时钟周期发出T<del>1</del>依次。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-2.png" alt></p>
<h6 id="微操作的节拍安排"><a href="#微操作的节拍安排" class="headerlink" title="微操作的节拍安排"></a>微操作的节拍安排</h6><p>假设：采用同步控制方式，一个机器周期内有3个节拍（时钟周期），CPU 内部结构采用非总线方式。</p>
<p>C<del>0</del>到C<del>12</del>共13个控制信号</p>
<blockquote>
<p>一个周期包含的节拍数跟这个机器周期中需要产生的控制信号的数量以及控制信号的复杂程度，都有直接关系。不同机器的节拍不同。</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-3.png" alt></p>
<p><strong>安排微操作时序的原则</strong></p>
<ul>
<li>原则一：微操作的 先后顺序不得 随意 更改<ul>
<li>如：只有把指令取到IR之后才能把指令的操作码送入CU译码</li>
</ul>
</li>
<li>原则二：被控对象不同 的微操作 尽量安排在 一个节拍 内完成<ul>
<li>就是说，可以并行执行的微操作微操作之间没有先后顺序。这样的微操作尽可能安排在同一节拍中。</li>
</ul>
</li>
<li>原则三：占用 时间较短 的微操作尽量 安排在 一个节拍 内完成并允许有先后顺序</li>
</ul>
<p><strong>取值周期微操作的节拍安排</strong></p>
<ul>
<li>T<del>0</del>(第一个节拍)：将PC指令送入MAR，发出读命令</li>
<li>ID(instruction decoder)：指令译码器</li>
<li>T<del>2</del>：将IR中指令操作码部分送到CU进行译码</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-4.png" alt></p>
<p><strong>间址周期微操作的节拍安排</strong></p>
<ul>
<li>T<del>0</del>：IR的地质部份送入MAR，CU发出读命令</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-5.png" alt></p>
<p><strong>执行周期微操作的节拍安排</strong></p>
<p>执行周期每条指令做的操作都不一样</p>
<ul>
<li>CLA：ACC清零。前两节拍什么都不做</li>
<li>COM：ACC按位取反</li>
<li>SHR：算术右移</li>
<li>CSL：循环左移</li>
<li>STP：停机</li>
<li>ADD X：把X内存单元中保存的内容和ACC内容相加，结果保存到ACC</li>
<li>STA X：把ACC的数据存入存储单元X中</li>
<li>LDA X：取内存单元中地址X的数据保存到ACC中</li>
<li>JMP X：跳转到给定的X</li>
<li>BAN X：分支指令，如果上一条指令的计算结果小于0，就跳转到X的执行指令。如果大于0 顺序执行下条指令</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-6.png" alt></p>
<p><strong>中断周期微操作的节拍安排</strong></p>
<p>都由中断隐指令来完成</p>
<ul>
<li>T<del>0</del>：<ul>
<li>0—&gt;MAR：把保存断点地址保存到MAR。</li>
<li>1—&gt;W：写命令</li>
<li>硬件关中断：给中断允许触发器置0</li>
</ul>
</li>
<li>T<del>1</del>：PC—&gt;MDR</li>
<li>T<del>2</del>：<ul>
<li>MDR—&gt;M(MAR)</li>
<li>向量地址—&gt;PC</li>
</ul>
</li>
</ul>
<h6 id="组合逻辑设计步骤"><a href="#组合逻辑设计步骤" class="headerlink" title="组合逻辑设计步骤"></a>组合逻辑设计步骤</h6><p><strong>列出操作时间表</strong></p>
<p>对应指令需要该操作标记1。</p>
<p>取指周期</p>
<ul>
<li>如果I(间址特征)有效，就要把IND设为1表示进入间址周期。如果无效，取值完直接进入执行阶段</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-7.png" alt></p>
<p>间址周期</p>
<ul>
<li>在取值阶段，CLA和COM已经做了1—&gt;EX</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-8.png" alt></p>
<p>执行周期</p>
<ul>
<li>因为执行阶段操作比较复杂，这里列出了比较多</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-9.png" alt></p>
<p><strong>写出微操作命令的最简表达式</strong></p>
<p>哪些指令在哪个工作周期在什么节拍在什么状态，要执行某个微操作。这样按逻辑表达式写出微操作。再根据逻辑表达式对表达式化简。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-10.png" alt></p>
<p>再根据表达式画出逻辑图。</p>
<p>特点：</p>
<ul>
<li>思路清晰，简单明了</li>
<li>庞杂，调试困难，修改困难</li>
<li>速度快（RISC）</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.1-11.png" alt></p>
<h3 id="10-2微程序设计"><a href="#10-2微程序设计" class="headerlink" title="10.2微程序设计"></a>10.2微程序设计</h3><h6 id="微程序设计概述"><a href="#微程序设计概述" class="headerlink" title="微程序设计概述"></a>微程序设计概述</h6><p>把能并行的微操作命令，储存起来变成一条微指令。每个节拍对应一条微指令。多条微指令就构成了机器指令。</p>
<p>微指令的格式，如果在某个节拍中要发出一个或几个控制信号，如果控制信号有效用1标识。每个位表示某一个微操作命令。</p>
<p>微指令构成了微程序，由微程序控制完成一条指令的执行过程。一条机器指令对应一个微程序</p>
<p>把微指令或微程序保存在只读存储器(ROM)中。</p>
<p>根据读出的微指令的有效微指令位置发出响应的控制信号，这种方式称为<strong>存储逻辑</strong>的方式。</p>
<blockquote>
<p>1、其实就是将可以并行的微操作合并，然后用一个微指令指代</p>
<p>2、然后如果执行该微指令，就相当于并行执行多个微操作</p>
<p>4、如果该微指令中有多个1，就说明在一个节拍中有多个微操作并行</p>
<p>5、因为微指令可以自由编程，实现微操作的多种组合</p>
<p>6、进而可以在不改变逻辑电路的前提下，于指令集中增添新指令</p>
</blockquote>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-1.png" alt></p>
<h6 id="微程序控制单元框图及工作原理"><a href="#微程序控制单元框图及工作原理" class="headerlink" title="微程序控制单元框图及工作原理"></a>微程序控制单元框图及工作原理</h6><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-2.png" alt></p>
<p><strong>微程序控制单元的基本框图</strong></p>
<ul>
<li>核心：控制存储器，微程序微指令都保存在这。</li>
<li>CMAR(控制存储器地址寄存器)：微指令地址保存在这。</li>
<li>地址译码：将CMAR的地址译码送入控制存储器。控制存储器是只读的，就可以将响应的微指令读出。</li>
<li>CMDR(control memory data register)：从控制存储器独处的微指令放入CMDR。</li>
<li>微地址形成部件：接受指令寄存器的操作码部分。</li>
<li>顺序逻辑：CMAR中地址有多个来源，要用顺序逻辑从多个来源中选一个正确的来源送入CMAR。</li>
<li>数据流：操作码送入微地址形成部件由它形成这条指令在执行阶段所对应的微程序在控制存储器中的地址。然后送入顺序逻辑，由它在多个地址中进行选择。选择正确的地址送入CMAR。再经过译码后送入控制存储器，从给定的地址中读出一条微指令，把它送入CMDR。将下地址送入顺序逻辑。顺序逻辑就给出了下条微指令地址。顺序逻辑就从为地址形成部件或下地址中选一个。</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-3.png" alt></p>
<p><strong>微程序控制单元框图及工作原理</strong></p>
<ul>
<li>每条微指令，右框部分为下地址部分</li>
<li>M+2的下地址不是M+3，微地址形成部件根据取来的指令的操作码形成，该指令在执行阶段所在的微程序在控制存储器中保存到什么地方。所以M+2的下地址不能直接标识，而是由硬件电路来形成。</li>
<li>P+2结束后如果没有中断就要进行下一条指令，回到M。</li>
<li>中断周期结束后，要转入下条指令。所以他的下地址为M</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-4.png" alt></p>
<p><strong>工作原理</strong></p>
<ol>
<li><p>取指阶段：执行取指微程序</p>
<ul>
<li>M—&gt;CMAR：把控制存储器中M的内容送入CMAR(控制存储的地址寄存器)，由CMAR指出第一条微指令在控制存储器的首地址。</li>
<li>CM(CMAR)—&gt;CMDR：把控制存储器中保存的微指令取出送入CMDR。由CMDR发出命令<ul>
<li>此时CMDR保存的就是由操作控制和顺序控制构成的微指令。操作控制部分的1对应了节拍1中将PC的值送入MAR和发出读命令。<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-5.png" style="zoom:33%;"></li>
</ul>
</li>
<li>形成下条微指令地址Ad(CMDR)—&gt;CMAR：下地址M+1通过顺序逻辑的选择送入CMAR。</li>
<li>CM(CMAR)—&gt;CMDR：取下条微指令，把CMAR取出的地址指向的控制存储器的单元内保存的微指令取出，再次放入CMDR中。由CMDR发命令<ul>
<li>命令对应的是：M(MAR)—&gt;MDR和(PC)+1—&gt;PC</li>
</ul>
</li>
<li>形成下条微指令Ad(CMDR)—&gt;CMAR：M+2</li>
<li>CM(CMAR)—&gt;CMDR：取下条微指令，由CMDR发命令<ul>
<li>命令对应的是：MDR—&gt;IR</li>
<li>下地址为XXX表示下条微指令地址由下地址阶段指出，要进入间址阶段或执行阶段。如果是执行阶段，就由操作码，根据操作码由微地址形成部件来形成要执行的指令。</li>
</ul>
</li>
</ul>
</li>
<li><p>执行阶段：执行LDA微程序</p>
<ul>
<li>OP(IR)—&gt;微地址形成部件—&gt;CMAR：由指令寄存器操作码字段送入微地址形成部件由它来形成下条指令地址。送入CMAR。</li>
<li>CM(CMAR)—&gt;CMDR：把执行阶段的第一条微指令地址取出送给CMDR。由CMDR发命令<ul>
<li>命令对应的是：Ad(IR)—&gt;MAR和读操作</li>
</ul>
</li>
<li>Ad(CMDR)—&gt;CMAR：形成下条微指令地址</li>
<li>CM(CMAR)—&gt;CMDR：把下条微指令地址取出送给CMDR。发出命令<ul>
<li>命令对应的是：M（MAR）—&gt;MDR</li>
</ul>
</li>
<li>Ad(CMDR)—&gt;CMAR：形成下条微指令地址</li>
<li>CM(CMAR)—&gt;CMDR：把下条微指令地址取出送给CMDR。发出命令<ul>
<li>命令对应的是：MDR—&gt;AC</li>
</ul>
</li>
<li>Ad(CMDR)—&gt;CMAR：形成下条微指令地址M</li>
</ul>
</li>
<li><p>取值阶段：和第一步一样</p>
</li>
</ol>
<p><strong>总结</strong>：全部微指令存在CM中，程序执行过程中只需把指令从CM中读出。<br>如果不考虑间址和中断。每条指令它的执行过程都需要执行取值微程序执行执行微程序，循环往复。</p>
<p><strong>关键</strong>：</p>
<ul>
<li>微指令的 操作控制字段如何形成微操作命令</li>
<li>微指令的 后续地址如何形成</li>
</ul>
<h6 id="微指令的编码方式-控制方式"><a href="#微指令的编码方式-控制方式" class="headerlink" title="微指令的编码方式(控制方式)"></a>微指令的编码方式(控制方式)</h6><p><strong>直接编码(直接控制)方式</strong></p>
<p>在微指令的操作控制字段中，每一位代表一个微操作命令。</p>
<p>所有执行一共需要多少微操作命令，那么它的操作控制字段就可以设置为多少位。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-6.png" alt></p>
<p><strong>字段直接编码方式</strong></p>
<p>将微指令的控制字段分成若干 “段”，每段经译码后发出控制信号。</p>
<p>经过译码后，只有一位是有效信号。如果1有效，那么输出端只有一位是1。每一位都表示在这段中对应的一个微操作。同组内所有微操作是互斥的，只能一个发出微操作命令。不同组发出的微操作命令可能可以并行。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-7.png" alt></p>
<p><strong>字段间接编码方式</strong></p>
<p>每个字段的译码结果，不仅和本字段的输入有关。而且和其它输入的译码结果相关。</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-8.png" alt></p>
<p><strong>混合编码</strong></p>
<p>直接编码和字段编码（直接和间接）混合使用。常用的直接编码，不常用间接编码。</p>
<p><strong>其它</strong></p>
<h6 id="微指令序列地址的形成"><a href="#微指令序列地址的形成" class="headerlink" title="微指令序列地址的形成"></a>微指令序列地址的形成</h6><ul>
<li><p>微指令的 下地址字段 指出</p>
</li>
<li><p>根据机器指令的 操作码 形成</p>
</li>
<li><p>增量计数器 (CMAR) + 1 —&gt; CMAR：执行阶段和取指阶段很多下条指令就是当前+1。如果使用该方法，下地址字段可以省略。</p>
</li>
<li><p>分支转移</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-9.png" alt></p>
</li>
<li><p>通过测试网络</p>
<ul>
<li>测试源：状态和条件</li>
<li>测试网络：对地位地址进行变换。然后和高位结合送入CMAR</li>
<li>可以用于微程序在小范围内的跳转和条件转移</li>
</ul>
</li>
<li><p>由硬件产生微程序入口地址</p>
<ul>
<li>如计算机开机。第一条微指令地址由专门硬件产生</li>
<li>中断周期 由 硬件 产生 中断周期微程序首地址</li>
<li>间址阶段所对应的微程序的首地址在控制存储器中是固定的。</li>
</ul>
</li>
<li><p>后续微指令地址形成方式原理图</p>
<ul>
<li>下地址由微指令顺序控制字段给出</li>
<li>由OP操作码字段经过微地址形成部件给出对应的这条指令的执行阶段所对应的微程序在控制单元的首地址</li>
<li>CMAR+1，顺序执行</li>
<li>第1条微指令等，由硬件完成</li>
<li>分支逻辑，确定是否转移。由分支逻辑从4个信号中选择一个作为CMAR的输入送入CMAR。</li>
<li>CMAR中的地址，经过译码后选定控制存储器中给定的存储单元。将内容读出放入CMDR。CMDR就可以给出相应控制信号</li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-10.png" alt></p>
</li>
</ul>
<h6 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h6><p>水平型微指令：一次能定义并执行多个并行操作</p>
<ul>
<li>如：直接编码、字段直接编码、字段间接编码、直接和字段混合编码</li>
</ul>
<p>垂直型微指令：类似机器指令操作码 的方式，由微操作码字段规定微指令的功能。</p>
<ul>
<li>一次只能定义一个操作(比较复杂操作)。</li>
</ul>
<p><strong>两种微指令格式的比较</strong></p>
<ul>
<li>水平型微指令比垂直型微指令 并行操作能力强，灵活性强</li>
<li>水平型微指令执行一条机器指令所要的微指令 数目少，速度快</li>
<li>水平型微指令 用较短的微程序结构换取较长的微指令结构</li>
<li>水平型微指令与机器指令 差别大</li>
</ul>
<h6 id="静态微程序设计和动态微程序设计"><a href="#静态微程序设计和动态微程序设计" class="headerlink" title="静态微程序设计和动态微程序设计"></a>静态微程序设计和动态微程序设计</h6><p>静态：微程序无须改变，采用ROM</p>
<p>动态：通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM</p>
<p><strong>毫微程序设计</strong></p>
<p>概念：微程序操作如果较为复杂，并且该操作内部的毫微操作也有一定的时间先后顺序。就可以用毫微程序来解释这条微指令</p>
<ul>
<li>微程序设计 用 微程序解释机器指令</li>
<li>毫微程序设计 用 毫微程序解释微指令</li>
<li>毫微指令与微指令 的关系好比 微指令与机器指令 的关系</li>
</ul>
<p><strong>毫微程序控制存储器的基本组成</strong></p>
<ul>
<li>指向CMAR<del>1</del>为3种地址输入</li>
<li>CMDR<del>1</del>：控制编码部分和指令的操作码编码方式类似，节省空间。通过微指令的地址码部分给出对应的毫微程序的地址送入CMAR<del>2</del></li>
</ul>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-11.png" alt></p>
<h6 id="串行微程序控制和并行微程序控制"><a href="#串行微程序控制和并行微程序控制" class="headerlink" title="串行微程序控制和并行微程序控制"></a>串行微程序控制和并行微程序控制</h6><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-12.png" alt></p>
<h6 id="微程序设计举例"><a href="#微程序设计举例" class="headerlink" title="微程序设计举例"></a>微程序设计举例</h6><p><strong>写出对应机器指令的微操作及节拍安排</strong></p>
<p>假设：CPU 结构与组合逻辑相同，都采用非总线的方式</p>
<ul>
<li>取指阶段微操作分析<ul>
<li>T<del>0</del>：PC—&gt;MAR 1—&gt;R</li>
<li>T<del>1</del>：M(MAR)—&gt;MDR (PC)+1—&gt;PC</li>
<li>T<del>2</del>：MDR—&gt;IR OP(IR)—微地址形成部件</li>
<li>读取指令<ul>
<li>OP(IR)—&gt;微地址形成部件—&gt;CMAR</li>
<li>Ad(CMDR)—&gt;CMAR</li>
</ul>
</li>
</ul>
</li>
<li>取指阶段的微操作及节拍安排：T<del>1</del>、T<del>2</del>、T<del>3</del>负责取微指令<ul>
<li>T<del>0</del>：PC—&gt;MAR 1—&gt;R</li>
<li>T<del>1</del>：Ad(CMDR)—&gt;CMAR</li>
<li>T<del>2</del>：M(MAR)—&gt;MDR (PC)+1—&gt;PC</li>
<li>T<del>3</del>：Ad(CMDR)—&gt;CMAR</li>
<li>T<del>4</del>：MDR—&gt;IR OP(IR)—微地址形成部件</li>
<li>T<del>5</del>：OP(IR)—&gt;微地址形成部件—&gt;CMAR</li>
</ul>
</li>
<li>执行阶段<ul>
<li>非访存指令<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-13.png" alt></li>
<li>访存指令<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-14.png" alt></li>
<li>转移类指令<img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-15.png" alt></li>
</ul>
</li>
</ul>
<p>以上：全部微操作 20个、微指令 38条</p>
<p><strong>确定微指令格式</strong></p>
<p>微指令的编码方式：微指令的编码方式</p>
<p>后续微指令的地址形成方式：由机器指令的操作码通过微地址形成部件形成、由微指令的下地址字段直接给出</p>
<p>微指令字长：</p>
<ul>
<li>由20个微操作：确定操作控制字段最少 20 位 </li>
<li>由 38 条微指令：确定微指令的 下地址字段 为 6 位</li>
<li>微指令字长 可取 20 ＋ 6 ＝ 26 位</li>
</ul>
<p>微指令字长的确定：</p>
<ul>
<li>38 条微指令中有 19 条用于形成后续微指令地址<ul>
<li>其中1条：OP(IR)—&gt;微地址形成部件—&gt;CMAR</li>
<li>18条：Ad(CMDR)—&gt;CMAR</li>
<li>若Ad(CMDR)直接送控存地址线，或多路选择器。就省去了了输至 CMAR 的时间，省去了 CMAR。OP(IR)—&gt;微地址形成部件—&gt;CMAR 同理。这样19条都可省略。38-19=19。</li>
<li>可省去 19 条微指令：38 － 19 ＝ 19操作控制字段最少取 18 位</li>
<li>可省去 2 个微操作：20 － 2 ＝ 18下地址字段最少取 5 位</li>
<li>考虑到一定的余量：去操作控制字段：24位。下地址字段6位。共30位</li>
</ul>
</li>
</ul>
<p>省去了 CMAR 的控制存储器</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-16.png" alt></p>
<p>编写微指令码点</p>
<p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/10.2-17.png" alt></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/09/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a><a class="next" href="/2020/09/25/Git%E7%AC%94%E8%AE%B0/">Git笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Scala/" style="font-size: 15px;">Scala</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/nosql/" style="font-size: 15px;">nosql</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 15px;">后端</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/scala/" style="font-size: 15px;">scala</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/wordpress/" style="font-size: 15px;">wordpress</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/springsecurity/" style="font-size: 15px;">springsecurity</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/marjora/" style="font-size: 15px;">marjora</a> <a href="/tags/virtualbox/" style="font-size: 15px;">virtualbox</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 15px;">服务器</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 15px;">博客</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机基础</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/%E6%B5%81%E7%A8%8B/" style="font-size: 15px;">流程</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 15px;">开发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/06/Redis/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Git笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/07/JVM/">JVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/27/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/Git%E7%AC%94%E8%AE%B0/">Git笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/manjaro%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">manjaro配置开发环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/docker%E7%AC%94%E8%AE%B0/">docker笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">dian的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>