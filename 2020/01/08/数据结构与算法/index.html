<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="后端Java工程师"><title>数据结构与算法 | dian的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构与算法</h1><a id="logo" href="/.">dian的博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构与算法</h1><div class="post-meta">2020-01-08</div><div class="post-content"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><a id="more"></a>

<p>程序=算法+数据结构</p>
<p>对算法的优劣的评判</p>
<ul>
<li>正确性、可读性、健壮性</li>
<li>时间复杂度(time complexity)：估算程序执行次数</li>
<li>空间复杂度(space complexity)：</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="大O表示法-Big-O"><a href="#大O表示法-Big-O" class="headerlink" title="大O表示法(Big O)"></a>大O表示法(Big O)</h4><p>用大O描述复杂度，表示数据规模n对应的复杂度</p>
<p>忽略常熟、系数、低阶</p>
<ul>
<li>9 &gt;&gt; O(1)</li>
<li>2n + 3 &gt;&gt; O(n)</li>
<li>n^2^ + 2n &gt;&gt;O(n^2^)</li>
<li>4n^3^ + 3n^2^ ++ 22n &gt;&gt;O(n^3^)</li>
<li>nlog<del>2</del>n + log<del>2</del>n &gt;&gt;O(nlogn)</li>
</ul>
<p>复杂度：2^n^&gt;n^数字^&gt;nlogn&gt;n&gt;logn</p>
<p>如果n以两倍数增加或减少则为log<del>2</del>n，如果为5倍数则是log<del>5</del>n</p>
<p>因为log<del>2</del>n = log<del>2</del>9 * log<del>9</del>n，将常数忽略，所以，所以log都不用写下标，统称log</p>
<p>如果有两个循环，分别为n和k，则表示为O(n+k)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>也是用大O表示法</p>
<p>申请n个基础变量就为O(n)，忽略基础变量的不同字节数</p>
<p><strong>fib函数的时间复杂度分析</strong></p>
<p>以5为例，以共五层，第一层为5，第二层为4和3，第三层为3，2，2，1，第四层为2，1，1，0，1，0最下一层为1，0，合并第四第五层，就是1+2+4+8=2^0^+2^1^2^2^+2^3^=2^4^-1=2^n-1^-1=0.5*2^n^-1 &gt;&gt; O(2^n^)</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>最好复杂度</li>
<li>平均复杂度：最好到最坏相加/n。多数情况为o(1)极端情况为o(n)平均复杂度为o(1)</li>
<li>最坏复杂度</li>
</ul>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><ul>
<li>数组：数组是一种顺序存储的线性表，所有元素的内存地址是连续的</li>
</ul>
<p>链表、栈、队列</p>
<p>动态数组的扩容倍数和缩容时机设计不得当的话，有可能会导致复杂度震荡</p>
<p>动态数组接口设计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;<span class="comment">//是否有该元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;<span class="comment">//添加元素</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//获得index索引的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span> <span class="params">(<span class="keyword">int</span> index,E element)</span></span>;<span class="comment">//在index位置上设置为元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">//在index位置上添加元素，其他元素后移</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//一处index位置上的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>;<span class="comment">//获取元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清空</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印数组时重写toString方法时，建议使用StringBuilder拼接字符串</p>
</blockquote>
<p><strong>内部工具函数与元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//所有的元素</span></span><br><span class="line"><span class="keyword">private</span> E[] elements;</span><br><span class="line"><span class="comment">//默认创建数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//元素未找到返回-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ELEMENT_NOT_FOUND = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//数组的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> capaticy)</span> </span>&#123;</span><br><span class="line">    capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;</span><br><span class="line">    <span class="comment">//无法直接用泛型创建数组，可以使用Object数组，然后强转</span></span><br><span class="line">    elements = (E[]) <span class="keyword">new</span> Object[capaticy];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查索引是否越界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        outOfBounds(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组越界异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outOfBounds</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index:"</span> + index + <span class="string">", Size:"</span> + size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查添加索引是否越界</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        outOfBounds(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍，1+0.5，位运算更快</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        newElements[i] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    elements = newElements;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素 </li>
</ul>
<p>思路：从最后一个元素开始依次向前移动一位，直到，需要删除元素位置即可。最后一个元素置为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E old = elements[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        elements[i - <span class="number">1</span>] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    elements[--size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素</li>
</ul>
<p>思路：</p>
<p>在指定位置插入元素：从最后一个元素开始依次向后移动一位，直到，需要添加元素的位置即可，然后将该位置的值修改为需要添加的元素</p>
<p>在末尾插入元素：调用上函数，指定位置为末尾(size)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">        elements[i] = elements[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    elements[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    add(size, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获得元素索引</li>
</ul>
<p>思路：依次对元素进行对比，找出相同元素。特别注意null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>) <span class="keyword">return</span> i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(elements[i])) <span class="keyword">return</span> i; <span class="comment">// n</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ELEMENT_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>清空</li>
</ul>
<p>思路：所有置为null(用于gc)，size置为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        elements[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态数组添加到最后一个位置的时候，虽然不需要挪动元素，但是如果遇到需要扩容的情况，需要复制所有元素，所以最坏时间复杂度也是0(n)</p>
<p>ArrayList可以通过引入first指针来优化，使得挪动的元素最多是n/2</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>动态数组会造成大量的空间浪费，链表是可以做到用多少申请多少</p>
<p>这里可以将链表和动态数组的相同方法抽出做接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ELEMENT_NOT_FOUND = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 清除所有元素</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 元素的数量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否为空</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否包含某个元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加元素到尾部</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取index位置的元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置index位置的元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 原来的元素ֵ</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在index位置插入一个元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除index位置的元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查看元素的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表的基本元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;E&gt; first;<span class="comment">//指向第一个元素</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; last;<span class="comment">//指向最后一个元素的next</span></span><br><span class="line"><span class="comment">//节点元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E element;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>链表不需要构造函数，因为链表不需要指定大小，需要既可以添加</p>
<p>链表代码一定要注意边界条件</p>
<p><strong>虚拟头节点</strong>：为了代码更加简洁清晰，引入虚拟头节点，不存储数据</p>
<p>链表在实际操作中，因为添加和删除节点时，需要先找到该节点，所以复杂度往往是o(n)</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>gc root</p>
<ol>
<li>被栈指针(局部变量)指向的对象</li>
</ol>
<p>双向链表的添加</p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>用数组模拟，每个元素存放两个数据：值、下一个元素的索引</p>
<p>链表尾的索引值用-1表示，如果为双向链表，就存储头节点下标</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>Java中的Stack继承Vector(类似ArrayList，线程安全)</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>优先考虑用双向链表实现，因为会频繁的操作头尾元素</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列就是两端都可以添加删除</p>
<p>队列底层是可以用链表或者数组实现</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>可以在两端添加删除</p>
<p>20 232</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>节点的度：子树的个数(子节点的个数)</p>
<p>树的度：所有节点度中的最大值</p>
<p>叶子节点：度为0的节点</p>
<p>层数：根节点第1层，它的子节点在第二层，以此类推(有些教程从0开始)</p>
<p>节点的深度：该节点到根节点唯一路径的节点总数</p>
<p>节点的高度：当前节点到最远叶子节点(当前节点下的叶子节点)的路径(往下看)</p>
<p>树的深度：所有节点深度中的最大值</p>
<p>树的高度：所有节点高度中的最大值</p>
<p>树的高度==树的深度</p>
<h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h3><p>特点：</p>
<ul>
<li>每个节点度最大为2</li>
<li>左子树和右子树有顺序</li>
<li>即使某节点只有一颗子树，也要区分左右子树</li>
<li>非空二叉树的第i层，最多有2^i-1^层(i≥1)</li>
<li>在高度为h的二叉树上最多有2^h^-1个结点(h≥1)</li>
<li>对于任意一个非空二叉树，如果叶子结点的个数为n<del>0</del>，度为2的节点个数为n<del>2</del>那么n<del>0</del>=n<del>2</del>+1。</li>
<li>二叉树的边数=n<del>1</del>+n<del>2</del>或n-1</li>
</ul>
<p>真二叉树(Proper Binary Tree)：所有节点的度不是0就是2</p>
<p>满二叉树(Full Binary Tree)：所有节点的度不是0就是2，且所有的叶子节点都在最后一层</p>
<ul>
<li>同样高度的二叉树中，满二叉树的叶子节点数最多，总节点数最多</li>
</ul>
<p>完全二叉树(Complete Binary Tree)：对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应</p>
<ul>
<li>叶子节点只会出现最后 2 层，最后 1 层的叶子结点都靠左对齐</li>
<li>完全二叉树从根结点至倒数第 2 层是一棵满二叉树</li>
<li>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</li>
</ul>
<p>面试题：完全二叉树768节点，求叶子节点数</p>
<ul>
<li>思路1：根据n=n<del>0</del>+n<del>1</del>+n<del>2</del>和n<del>0</del>=n<del>2</del>+1得出n=2n<del>0</del>+n<del>1</del>-1，完全二叉树的n<del>1</del>不是0就是1.所以得出384</li>
<li>思路2：最下层：768-512+1=257。倒数第二层：256-(257/2+1)=127。这里除不同向下取整。257+127=384。</li>
</ul>
<p>国外教程上Full Binary Tree指的是真二叉树，Perfect Binary Tree指的是满二叉树</p>
<p><strong>面试题</strong></p>
<p>如果一棵完全二叉树有 768 个节点，求叶子节点的个数</p>
<p>​    假设叶子节点个数为 n0，度为 1 的节点个数为 n1，度为 2 的节点个数为 n2</p>
<p>​    总结点个数 n = n0 + n1 + n2，而且 n0 = n2 + 1</p>
<p><strong>n = 2n0 + n1 – 1</strong></p>
<p>完全二叉树的 n1 要么为 0，要么为 1</p>
<p>​    n1为1时，n = 2n0，n 必然是偶数</p>
<p>​    叶子节点个数 n0 = n / 2，非叶子节点个数 n1 + n2 = n / 2</p>
<p>​    n1为0时，n = 2n0 – 1，n 必然是奇数    </p>
<p>​    叶子节点个数 n0 = (n + 1) / 2，非叶子节点个数 n1 + n2 = (n – 1) / 2</p>
<p><strong>叶子节点个数</strong> n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 ) </p>
<p><strong>非叶子节点个数</strong> n1 + n2 = floor( n / 2 ) = ceiling( (n – 1) / 2 )</p>
<p>因此叶子节点个数为 384</p>
<p><strong>遍历</strong></p>
<ul>
<li><p>前序遍历（Preorder Traversal） ：根节点、前序遍历左子树、前序遍历右子树</p>
<ul>
<li>递归：很好想</li>
</ul>
</li>
<li><p>中序遍历（Inorder Traversal） ：中序遍历左子树、根节点、中序遍历右子树</p>
<ul>
<li>递归：很好想</li>
</ul>
</li>
<li><p>后序遍历（Postorder Traversal） ：后序遍历左子树、后序遍历右子树、根节点</p>
<ul>
<li>递归：很好想</li>
</ul>
</li>
<li><p>层序遍历（Level Order Traversal）：从上到下、从左到右依次访问每一个节点</p>
<ul>
<li>队列(默写)：将根节点入队，循环执行将队头节点A出队访问，将A的左子节点入队，右子节点入队。直到队列为空</li>
</ul>
</li>
</ul>
<p>计算二叉树高度(迭代法)：用层序遍历的方法，每次遍历完一层记录队列size，这时的size就是这一层的节点数。并且高度加1。</p>
<p>判断是否为完全二叉树：树为空返回false。不为空层序遍历二叉树，left为null并且right不为null返回false。left不为null并且right不为null，入队。left为null并且right不为null，那么这两种情况接下来所有节点都为叶子节点才为完全二叉树。</p>
<p><strong>根据结果重构二叉树</strong></p>
<p>前序遍历+中序遍历可以确定唯一的二叉树：</p>
<p>后序+中序可以确定唯一的二叉树：</p>
<p>前序+后序不可以确定唯一二叉树，除非找到他是真二叉树：因为前序的根在最前，后序的根在最后。如果左子树或右子树一个为空，无法确定到底是哪个树为空</p>
<ul>
<li>如前序：4 2 1 3 6 5，中序：1 2 3 4 5 6<ul>
<li>前序遍历的第一个必为根节点，咱中序遍历中找到根节点，确定1 2 3为左子树，4 5 6为右子树</li>
<li>根据前序知左子树1 2 3中2为根节点，根据中序1为左节点 3为右节点。</li>
<li>右子树一样</li>
</ul>
</li>
</ul>
<p><strong>前驱节点</strong></p>
<p>前驱节点：中序遍历时的前一个节点</p>
<p>如果有左子树，那么前驱节点就是，``node.left.right.right…`，直到right为null</p>
<p>如果无左子树，有父节点，那么前驱节点就是，<code>node.parent.parent…</code>，直到node是parent为止</p>
<p>有可能无前驱</p>
<p><strong>后继结点</strong></p>
<p>后继结点：中序遍历时的后一节点</p>
<p>如果有右子树，后继结点为<code>node.right.left.left.…</code>，直到left为null</p>
<p>如果无右子树，有父节点，后继结点为<code>node.parent.parent…</code>，直到node为parent的左子树为止。</p>
<p>可能无后继结点。</p>
<p><strong>删除节点</strong></p>
<p>度为0和1都比较简单。</p>
<p>如果度为2，就是找左子树的前驱节点或右子树的后继结点，取代即可。就转化为删除度为1或0的节点</p>
<blockquote>
<p>如果是度为2的节点，前驱或后继节点的度只可能为1或0</p>
</blockquote>
<h3 id="二叉搜索树-Binary-Search-Tree"><a href="#二叉搜索树-Binary-Search-Tree" class="headerlink" title="二叉搜索树(Binary Search Tree)"></a>二叉搜索树(Binary Search Tree)</h3><p>BST：二叉查找树、二叉排序树</p>
<ul>
<li><p>任意一个节点的值都大于其左子树所有节点的值</p>
</li>
<li><p>任意一个节点的值都小于其右子树所有节点的值</p>
</li>
<li><p>它的左右子树也是一棵二叉搜索树</p>
</li>
<li><p>二叉搜索树存储的元素必须具备可比较性，不允许为null</p>
</li>
</ul>
<h3 id="平衡二叉搜索树-Balanced-Binary-Search-Tree"><a href="#平衡二叉搜索树-Balanced-Binary-Search-Tree" class="headerlink" title="平衡二叉搜索树(Balanced Binary Search Tree)"></a>平衡二叉搜索树(Balanced Binary Search Tree)</h3><p>常见平衡二叉搜索树：AVL树、红黑树</p>
<p><strong>AVL树</strong></p>
<p>平衡因子：其结点的左右子树高度差</p>
<p>AVL树的每个节点的平衡因子只可能是-1、0、1。超过一称为失衡</p>
<p>添加可能会导致失衡，可能使所有祖先节点都失衡，但父节点和非祖先节点不可能失衡</p>
<p><strong>四种失衡情况</strong></p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LL_%E5%8F%B3%E6%97%8B%E8%BD%AC.png" alt="img"></p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/RR%E2%80%94%E5%B7%A6%E6%97%8B%E8%BD%AC.png" alt="img"></p>
<p>![img](数据结构与算法/LR – RR左旋转LL右旋转.png)</p>
<p>![img](数据结构与算法/RL – LL右旋转RR左旋转.png)</p>
<p><strong>删除节点</strong></p>
<p>删除操作只可能会导致父节点失衡。 </p>
<p>度为0和1都比较简单。</p>
<p>如果度为2，就是找左子树的前驱节点或右子树的后继结点，取代即可。就转化为删除度为1或0的节点</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树必须满足五条性质</p>
<ul>
<li>节点为red或black</li>
<li>根节点是black</li>
<li>叶子节点(外部节点，空节点)都为black</li>
<li>red节点的子节点都是black<ul>
<li>red节点的父节点都是black</li>
<li>从根节点刀叶子节点的所有路径上不能有两个连续的red节点</li>
</ul>
</li>
<li>从任一节点到叶子节点的所有路径都包含相同数目的black</li>
</ul>
<p>红黑树等价4阶B树。black节点与他的red子节点融合即为一个B树节点。红黑树的black节点数和4阶B树的节点数相同</p>
<p>红黑树的最大高度：2*log<del>2</del>(n+1)</p>
<p>平均时间复杂度</p>
<ul>
<li>搜索：O(logn)</li>
<li>添加<ul>
<li>AVL：O(logn)</li>
<li>红黑：O(1)次的旋转操作</li>
</ul>
</li>
<li>删除：O(logn)，O(1)次的旋转操作<ul>
<li>AVL：O(logn)</li>
<li>红黑：O(1)次的旋转操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>对比AVL树，在添加删除时候，修复的操作。红黑树效率更高。AVL最坏情况是2倍logn</p>
<p>红黑树在删除时，也可能发生递归，依次网上旋转，但根据统计，这不可能发生。反正就不可能老师也没明说。结论最多三次</p>
</blockquote>
<p>总结：若搜索次数多，选AVL树。若搜索、插入、删除差不多选红黑树。</p>
<p>红黑树的平均统计性能优于AVL树</p>
<p><strong>添加</strong></p>
<p>已知：B树中，新元素必定添加到叶子节点中</p>
<p>添加节点时，默认为红节点，这样只有第四条性质可能不满足</p>
<p>添加的时候，叶子节点只有可能4中情况：红黑红、黑红、红黑、黑</p>
<p>最下排的节点，每个节点添加可能性，一共12种</p>
<ul>
<li><p>有四种是，parent为黑。就完全满足性质，不需要做任何处理</p>
</li>
<li><p>剩下八种不满足性质4，parent为红。</p>
<ul>
<li><p>LL/RR情况修复：父节点染黑，祖父染红。然后让祖父节点成为父节点的子节点，让原祖父节点的父节点指向父节点。</p>
<ul>
<li>判定条件：叔父(父节点的兄弟节点)节点不是红色</li>
</ul>
<ol>
<li>parent染成黑，grand染成红</li>
<li>grand进行单旋操作<ul>
<li>LL；右旋转</li>
<li>RR：左旋转</li>
</ul>
</li>
</ol>
</li>
<li><p>LR/RL情况修复：让自身成为父节点和祖父节点的父节点。</p>
<ul>
<li>判定条件：叔父节点不是红色</li>
</ul>
<ol>
<li>自己染黑，grand染红(父节点本身就是红)</li>
<li>进行双旋操作<ul>
<li>LR：parent左旋转，grand右旋转</li>
<li>RL：parent右旋转，grand左旋转</li>
</ul>
</li>
</ol>
</li>
<li><p>上溢LL：叔父节点为红色</p>
<ul>
<li>parent、uncle染成黑色</li>
<li>grand向上合并</li>
<li>将grand染红，当作新添加的节点处理<ul>
<li>grand向上合并时，可能继续发生上溢，若一直溢到根节点，只需将<strong>根节点染黑即可</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>上溢RR：叔父节点为红色</p>
<ul>
<li>parent、uncle染黑</li>
<li>grand染红向上合并，当作新添加的节点</li>
</ul>
</li>
<li><p>上溢RL</p>
<ul>
<li>parent、uncle染黑</li>
<li>grand染红向上合并，当作新添加的节点</li>
</ul>
</li>
<li><p>上溢：LR</p>
<ul>
<li>parent、uncle染黑</li>
<li>grand染红向上合并，当作新添加的节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>红黑树中没有平衡因子的概念，红黑树不存在失去平衡，只需要满足五条性质即可</p>
</blockquote>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201205111636439.png" alt="image-20201205111636439"></p>
<p><strong>删除</strong></p>
<p>在B树中，真正被删除的元素都在叶子节点中，</p>
<p>如果删除的是红色节点，性质依然满足，不需要其它任何操作</p>
<p>有三种情况</p>
<ul>
<li><p>拥有2个红子节点的黑节点</p>
<ul>
<li>不会被直接删除，会找他的子节点代替删除</li>
</ul>
<blockquote>
<p>前驱或后继节点代替，恰好子节点就是前驱和后继节点</p>
</blockquote>
</li>
<li><p>拥有一个红节点的黑节点</p>
<ul>
<li>判定条件：用以替代的子节点是红</li>
<li>将替代的子节点染黑</li>
</ul>
</li>
<li><p>黑叶子节点：黑色叶子节点被删除后，相当于在B树该节点没有元素，发生下溢</p>
<ul>
<li><p>判定条件：用以替代的子节点是黑(不存在)    </p>
</li>
<li><p>情况1：兄弟能借</p>
<ul>
<li>兄弟为黑且他的子节点至少一个是红</li>
<li>步骤<ul>
<li>叶子节点被删除后，导致B树节点下溢</li>
<li>如果兄弟节点至少有一个红节点且兄弟节点为黑</li>
<li>旋转，将居中的元素代替父节点以及颜色，父节点下来，左右子节点染黑。</li>
</ul>
</li>
</ul>
<blockquote>
<p>当兄弟节点有两个红子节点，就有两种旋转方式，选其一即可。</p>
</blockquote>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201205180724295.png" alt="image-20201205180724295"></p>
</li>
<li><p>情况2：兄弟黑不能借</p>
<ul>
<li>判定条件：兄弟为黑没有1个红子节点</li>
<li>父节点下溢</li>
<li>若父节点为红：将兄弟染红，父节点染黑即可。</li>
<li>若父节点为黑：将兄弟染红，父节点染黑即可。将父节点当作被删除的节点处理即可。</li>
</ul>
</li>
<li><p>情况3：兄弟为红</p>
<ul>
<li>让兄弟的孩子变成自己的兄弟。让原来的红兄弟，变成祖父节点，父节点指向原兄弟节点的子节点。这样又回到了情况1。</li>
</ul>
</li>
</ul>
<blockquote>
<p>黑色兄弟不可能有黑色子节点，因为它处在最后一层。</p>
</blockquote>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201205230728902.png" alt="image-20201205230728902"></p>
</li>
</ul>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树是一种<strong>多路</strong>搜索树，多用于文件系统和数据库实现</p>
<p>特点</p>
<ul>
<li>1个节点可以存储超过2个元素，可以拥有超过2个子节点</li>
<li>拥有二叉搜索树的一些性质</li>
<li>平衡，每个节点的字数高度一致</li>
</ul>
<p>n阶B树：表示节点最多有n个子节点，每个节点存储元素个数≤n-1，根节点至少1个，非跟节点至少m/2(向上取整)-1</p>
<p><strong>添加</strong></p>
<p>必定添加到叶子节点，如果叶子节点超过数量限制，就找中间值，提到父节点，进行上溢，如果父节点还是溢出，依次上溢，如果根节点依然上溢，就提出一个新的根节点。</p>
<p><strong>删除</strong></p>
<p>叶子节点中，直接删除。</p>
<p>非叶子节点，找前驱或者后继元素，覆盖即可</p>
<p>非叶子节点的前驱或后继必然在叶子节点中</p>
<p>如果删除后叶子结点的值的数量低于限制，发生下溢</p>
<p>下溢解决：</p>
<ul>
<li>如果下溢节点临近的兄弟节点，有至少 ┌ m/2 ┐ 个元素，可以向其借一个元素(最大的) 将父节点的元素 b 插入到下溢节点的 0 位置（最小位置） 用兄弟节点的元素 a（最大的元素）替代父节点的元素 b<ul>
<li>原来a节点的右子节点也要跟着他移动，但会移到左节点</li>
</ul>
</li>
<li>如果下溢节点临近的兄弟节点，只有 ┌ m/2 ┐ − 1 个元素将父节点的元素 b 挪下来跟左右子节点进行合并 合并后的节点元素个数等于┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过 m − 1 这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>又称霍夫曼编码，现代压缩算法的基石。</p>
<blockquote>
<p>现在压缩算法不咋用这了</p>
</blockquote>
<p>步骤：</p>
<ol>
<li>先计算出每个字母的出现频率（权值）</li>
<li>利用这些权值，构建一棵哈夫曼树（又称为霍夫曼树、最优二叉树）<ul>
<li>以权值作为根节点构建 n 棵二叉树，组成森林</li>
<li>在森林中选出 2 个根节点最小的树合并，作为一棵新树的左右子树，且新树的根节点为其左右子树根节点之和</li>
<li>从森林中删除刚才选取的 2 棵树，并将新树加入森林</li>
<li>重复 2、3 步骤，直到森林只剩一棵树为止，该树即为哈夫曼树</li>
</ul>
</li>
</ol>
<p>例：ABBBCCCCCCCCDDDDDDEE</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201210222730842.png" alt="image-20201210222730842"></p>
<p>left为0，right为1，可以得到对应的哈夫曼编码</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody><tr>
<td>1110</td>
<td>110</td>
<td>0</td>
<td>10</td>
<td>1111</td>
</tr>
</tbody></table>
<p>这样构建的不会出现歧义</p>
<p><strong>总结</strong></p>
<ul>
<li>n 个权值构建出来的哈夫曼树拥有 n 个叶子节点</li>
<li>每个哈夫曼编码都不是另一个哈夫曼编码的前缀</li>
<li>哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近</li>
<li>带权路径长度：树中所有的叶子节点的权值乘上其到根节点的路径 长度。与最终的哈夫曼编码总长度成正比关系。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>特点：不存放重复的元素</p>
<p>可以用链表或平衡二叉搜索树</p>
<p>添加：通过判断是否有该元素，有就覆盖，无就添加。</p>
<p> 局限性：使用平衡二叉搜索树需要元素具有可比较性</p>
<blockquote>
<p>用链表或平衡二叉搜索树的接口判断是否有该元素。</p>
</blockquote>
<h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射(Map)"></a>映射(Map)</h2><p>也叫字典</p>
<p>由红黑树底层实现的map，由于不需要value具有可比较性，所以是一个一个的比较找出。</p>
<p>也可以用Map来实现set，这时候value的泛型为Object。value传null值。</p>
<p>Java的TreeSet底层就是用TreeMap来实现。</p>
<p>Java的TreeMap底层用的是红黑树</p>
<blockquote>
<p>Java官方没单独的红黑树实现，是直接写在需要用的地方</p>
</blockquote>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>也叫散列表</p>
<p>哈希表内部的数组元素，也叫Bucket(桶)，整个数组叫Buckets或Bucket Array</p>
<p>添加、搜索、删除流程类似</p>
<ol>
<li>利用哈希函数生成key对应的index。O(1)</li>
<li>根据index操作定位数组元素。O(1)</li>
</ol>
<p>哈希冲突：2个不同的key，计算出相同的结果</p>
<p>解决哈希冲突常见方法</p>
<ul>
<li>开放定址法：按照一定规则向其他地址探测，直到遇到空桶。(找其它所以对应的桶)</li>
<li>再哈希法：设计多个哈希函数</li>
<li>链地址法：通过链表将同一index的元素串起来</li>
</ul>
<p>JDK1.8：默认使用单向链表将元素串起来。在添加元素时，可能会转化为红黑树来存储元素。</p>
<ul>
<li>如(jdk8)：当哈希表容量≥64且单向链表的节点数大于8时</li>
<li>当红黑树节点少到一定数时，转化为单向链表</li>
</ul>
<blockquote>
<p>JDK1.8的哈希表使用链表+红黑树解决哈希冲突</p>
</blockquote>
<p>哈希表中哈希函数的大致实现步骤</p>
<ol>
<li>先生成key的哈希值(整数)</li>
<li>再让key的哈希值跟数组的大小进行相关运算，生成索引值<ul>
<li>为了提高效率可以用<code>&amp;</code>运算，前提是数组的长度设计为2的幂。<code>return hash_code(key)&amp;(table.length-1);</code></li>
</ul>
</li>
</ol>
<p>在Java中，HashMap的key必须实现了hashCode、equals方法，也允许key为null</p>
<ul>
<li><p>整数：值当作哈希值</p>
</li>
<li><p>浮点数：将存储的二进制格式转化为整数</p>
</li>
<li><p>Long：<code>return (int)(value ^ (value &gt;&gt;&gt; 32))</code></p>
</li>
<li><p>Double：<code>long bits = doubleToLongBits(value); return (int)(bits^(bits &gt;&gt;&gt; 32));</code></p>
</li>
<li><p>字符串：</p>
<ul>
<li>如jack可以表示为j*n^3^+a*n^2^+c*n^1^+k*n^0^等价于[(j*n+a)*n+c]*n+k</li>
<li>jdk中乘数n为31。31不仅仅是奇素数而且，jvm会31*i可以优化为(i&lt;&lt;5)-i</li>
</ul>
<blockquote>
<p>素数和其它数相乘结果比其它方式更容易产生唯一性，减少哈希冲突</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Double和Long充分利用高32位和低32位混合计算出哈希值。value和它又移32位进行亦或运算。</p>
<p>&amp;和|容易发生hash冲突。</p>
</blockquote>
<blockquote>
<p><code>&gt;&gt;&gt;</code>：符号右移，忽略符号位，空位都以0补齐</p>
<p><code>&gt;&gt;</code>：算数右移</p>
</blockquote>
<p><code>instanceof</code>如果是子类，返回也是true。<code>obj.getClass()!=getClass()</code>不是</p>
<p>HashMap中红黑树节点比较代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(K k1, K k2, <span class="keyword">int</span> h1, <span class="keyword">int</span> h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较哈希值</span></span><br><span class="line">    <span class="keyword">int</span> result = h1 - h2;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较equals</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(k1, k2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希值相等，但是不equals</span></span><br><span class="line">    <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; k2 != <span class="keyword">null</span> </span><br><span class="line">        &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">        &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        <span class="comment">// 同一种类型并且具备可比较性</span></span><br><span class="line">        <span class="keyword">if</span> (k1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Comparable) k1).compareTo(k2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一种类型，哈希值相等，但是不equals，但是不具备可比较性</span></span><br><span class="line">    <span class="comment">// k1不为null，k2为null</span></span><br><span class="line">    <span class="comment">// k1为null，k2不为null</span></span><br><span class="line">    <span class="keyword">return</span> System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找、添加、删除时如不具备可比较性，并且哈希值相同。或equals为false但compareTo结果为0。不能通过内存地址来查找，应该遍历红黑树上所有节点。因为内存地址不同，但equals结果可能为true。</p>
<blockquote>
<p>jdk上也会扫描所有节点</p>
</blockquote>
<p>装填因子(Load Factor)：节点总数量/哈希表桶数组长度，也叫负载因子</p>
<p>在JDK8的HashMap中，装填因子超过0.75，就扩容到原来两倍</p>
<p><code>equals</code>规范</p>
<ul>
<li>自反性：x.equals(x)返回true</li>
<li>对称性：非null的x，y。y.equals(x)==x.equals(y)</li>
<li>传递性：a=b b=c =&gt;a=c</li>
<li>一致性：多次调用结果一致</li>
<li>任何非null的x，x.equals(null)必须返回false</li>
</ul>
<p>TreeMap和HashMap</p>
<ul>
<li>元素具备可比较性且要求升序遍历选TreeMap</li>
<li>无序遍历选HashMap</li>
</ul>
<p>推荐的最佳素数</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201208173406499.png" alt="image-20201208173406499"></p>
<p>LinkedHashMap：在HashMap的基础上维护其添加顺序的链表(红黑树依然在)。跨树的。不用管index。</p>
<p>JDK的源码</p>
<p>LinkedHashMap：</p>
<ul>
<li>有头节点，尾节点</li>
<li>每当创建新节点都会放到末尾</li>
</ul>
<p>HashMap</p>
<ul>
<li>当容量达到1&lt;&lt;30就不再允许扩容</li>
<li>默认装填因子0.75</li>
<li><code>DEFAULT_INITIAL_CAPACITY</code>默认大小：1&lt;&lt;4</li>
<li>当链表节点数量<code>TREEIFY_THRESHOLD</code>超过8(大于8)就转化成红黑树。</li>
<li><code>UNTREEIFY_THRESHOLD</code>当节点数小于6，红黑树转化为链表。</li>
<li><code>MIN_TREEIFY_CAPACITY</code>：转化为红黑树，容量最小为64</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种树状的数据结构(不要跟内存模型中”堆空间”混淆)。</p>
<p>分为：</p>
<ul>
<li>二叉堆</li>
<li>多叉堆</li>
<li>索引堆</li>
<li>二项堆</li>
<li>斐波那契堆</li>
<li>左倾堆</li>
<li>斜堆</li>
</ul>
<blockquote>
<p>常用于解决Top k问题</p>
</blockquote>
<p>重要心智：任意节点的值总≥(≤)子节点的值</p>
<ul>
<li>若任意节点的值总≥子节点的值称：最大堆、大根堆、大顶堆</li>
<li>若任意节点的值总≤子节点的值称：最小堆、小根堆、小顶堆</li>
</ul>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆的逻辑结构就是一颗完全二叉树，也叫完全二叉堆。物理结构一般用数组实现即可</p>
<p>索引 i 的规律（ n 是元素数量）</p>
<ul>
<li>i = 0 ，根节点</li>
<li>i &gt; 0 ，它的父节点的索引为 floor( (i – 1) / 2 )</li>
<li>若2i + 1 ≤ n – 1，它的左子节点的索引为 2i + 1<ul>
<li>大于就无左子节点</li>
</ul>
</li>
<li>若2i + 2 ≤ n – 1 ，它的右子节点的索引为 2i + 2<ul>
<li>大于就无右子节点</li>
</ul>
</li>
</ul>
<p><strong>添加</strong></p>
<p>先添加到数组的末尾位置也就是叶子节点，然后与父节点比较。如果不符合就交换位置，符合就停止，然后循环比较。</p>
<blockquote>
<p>这样添加需要会导致重复覆盖，可以先进行比对，确定位置后，再覆盖。</p>
</blockquote>
<p>该过程叫上滤</p>
<p>时间复杂度：O(logn)</p>
<p><strong>删除</strong></p>
<p>拿到最后一个元素，交换位置，然后删除最后一个元素。</p>
<p>再将换后的新元素，依次向下比较，如果不符合就交换位置，符合就停止</p>
<p>该过程叫下滤</p>
<p>时间复杂度：O(logn)</p>
<blockquote>
<p>也可以像添加一样优化</p>
</blockquote>
<blockquote>
<p>如果某一个元素为叶子节点，那么它之后所有元素都是叶子节点</p>
</blockquote>
<p>根据完全二叉树，非叶子节点个数为n/2向下取整。可以直接写为<code>size&gt;&gt;1</code></p>
<p><strong>批量建堆</strong></p>
<p>自上而下的上滤：O(nlogn)</p>
<ul>
<li>从索引1开始每个元素都上滤</li>
<li>仅叶子节点就近n/2个，而且每个深度都为logn</li>
</ul>
<p>自下而上的下滤：O(n)</p>
<ul>
<li>从<code>size&gt;&gt;1-1</code>到0为止</li>
<li>假设满树，总数为n，高位h，那么n=2^h^-1<ul>
<li>所有节点树高之和位H(n)=2^0^<em>(h-0)+2^1^</em>(h-1)+2^2^<em>(h-2)……+2^h-1^</em>[h-(h-1)]=h*(2^h^-1)-[(h-2)*2^h^+2]=2n-log<del>2</del>(n+1)=O(n)</li>
</ul>
</li>
</ul>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201210191238622.png" alt="image-20201210191238622">)<img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201210191605069.png" alt="image-20201210191605069"></p>
<p>下滤效率较高</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201210190422369.png" alt="image-20201210190422369"></p>
<p><strong>Top K问题</strong></p>
<p>全排序时间复杂度：O(nlogn)</p>
<p>二叉堆时间复杂度：O(nlogk)</p>
<p>步骤：</p>
<ol>
<li>新建一个小顶堆</li>
<li>扫描n个整数<ul>
<li>前k个数入堆</li>
<li>从k+1开始，如果大于堆顶元素，就replace</li>
</ul>
</li>
</ol>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>用堆来实现</p>
<p>优先级高的</p>
<p>可以用最大堆或最小堆来实现</p>
<p>Java官方使用的是最小堆。越小优先级越高</p>
<blockquote>
<p>最大堆是越大优先级越高</p>
</blockquote>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>也叫字典树、前缀树、单词查找树</p>
<p>搜索效率主要与字符串长度有关</p>
<p>多叉树，一个节点一个字符，根节点为空</p>
<p>节点需要有一个标记，来标记此节点是否为结束位</p>
<p>缺点：内存消耗大</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>右旋转又叫zig，旋转后的状态叫zigged</p>
<p>左旋转叫zag ，旋转后的状态叫zagged</p>
<h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><p>表达式分三种：</p>
<ul>
<li>前缀表达式：又称波兰表达式</li>
<li>中缀表达式</li>
<li>后缀表达式：又称逆波兰表达式</li>
</ul>
<table>
<thead>
<tr>
<th>前缀</th>
<th>中缀</th>
<th>后缀</th>
</tr>
</thead>
<tbody><tr>
<td>+ 1 2</td>
<td>1 + 2</td>
<td>1 2 +</td>
</tr>
<tr>
<td>+ 2 * 3 4</td>
<td>2 + 3 * 4</td>
<td>2 3 4 * +</td>
</tr>
<tr>
<td>+ 9 * - 4 1 2</td>
<td>9 +(4 - 1) * 2</td>
<td>9 4 1 -2 * +</td>
</tr>
</tbody></table>
<p>若将表达式的操作数作为叶子节点，运算符作为父节点。刚好组成二叉树。</p>
<p>前序遍历就是前缀表达式</p>
<p>中序遍历就是中缀表达式</p>
<p>后序遍历就是后缀表达式</p>
<h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><p>非递归的前序遍历：一路往左，并且将右节点入栈，左到底后，将栈顶元素弹出，然后循环这逻辑</p>
<p>非递归的中序遍历：一路往左，依次将当前节点入栈，到底后出栈，访问它的右节点，然后对该节点也执行上面的逻辑，依次循环。</p>
<p>非递归的后序遍历：将当前节点入栈，将右节点入栈，将左节点入栈，将栈顶(不弹出)的右节点入栈，左节点入栈</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><table>
<thead>
<tr>
<th>名称</th>
<th>最好时间复杂度</th>
<th>最坏时间复杂度</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>In-place</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序（Bubble Sort）</td>
<td>O(n)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>选择排序（Selection Sort）</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>插入排序（Insertion Sort）</td>
<td>O(n)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>归并排序（Merge Sort）</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>快速排序（Quick Sort）</td>
<td>O(nlogn)</td>
<td>O(n^2^)</td>
<td>O(nlogn)</td>
<td>O(logn)</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>希尔排序（Shell Sort）</td>
<td>O(n)</td>
<td>O(n^4/3^)~O(n^2^)</td>
<td>取决于步长</td>
<td>O(1)</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>堆排序（Heap Sort）</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>计数排序（Counting Sort）</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>基数排序（Radix Sort）</td>
<td>O(d ∗ (n + k))</td>
<td>O(d ∗ (n + k))</td>
<td>O(d ∗ (n + k))</td>
<td>O(n + k)</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>桶排序（Bucket Sort）</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + m)</td>
<td>x</td>
<td>√</td>
</tr>
</tbody></table>
<p>冒泡、选择、插入、归并、快速、希尔、堆排序，属于比较排序（Comparison Sorting）</p>
<blockquote>
<p>in-place：原地算法，不依赖额外资源，输出覆盖输入。一般为O(1)空间复杂度</p>
</blockquote>
<blockquote>
<p>k为序列内max-min</p>
</blockquote>
<blockquote>
<p>d为最大值的位数</p>
</blockquote>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>可以记录最后依次交换的位置，用来减少比较次数。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>在序列中找到最大元素与末尾元素交换。忽略该元素</p>
<p>平均性能略优于冒泡，但最好情况下依旧很差</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将序列进行原地建堆，重复执行以下操作，直到堆元素数量为1</p>
<ul>
<li>交换堆顶元素与尾元素</li>
<li>堆元素减1</li>
<li>对0位置进行一次siftDown操作</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序类似于扑克牌的排序</p>
<p>执行流程：</p>
<ol>
<li>在执行过程中，插入排序会将序列分为2部分。<ul>
<li>头部是已经排好的序列，尾部是待排序的</li>
</ul>
</li>
<li>从头开始扫描每个元素<ul>
<li>每扫描到一个元素，就插入到头部合适的位置</li>
</ul>
</li>
</ol>
<blockquote>
<p>实现，尾部向前排，可向前依次交换实现</p>
<p>也可以用二分搜索相应的位置插入来优化，为了稳定性，需要二分搜索返回第一个大于该元素的位置。</p>
</blockquote>
<p>逆序对：如&lt;2,3,8,6,1&gt;的逆序对为：&lt;2,1&gt; &lt;3,1&gt; &lt;8,1&gt; &lt;8,6&gt; &lt;6,1&gt;。</p>
<p>逆序对数量越多，插入排序的时间复杂度越高 </p>
<blockquote>
<p>当逆序对极少时，效率极高</p>
</blockquote>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>步骤</p>
<ol>
<li>不断地将当前序列平均分割成2个子序列，直到不能再分割为止(只剩一个元素)</li>
<li>不断地将两个序列合并成一个有序序列<ul>
<li>两边从头开始，哪个大按序加入序列。</li>
</ul>
</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array/</a></p>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/comments/</a></p>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p>
<blockquote>
<p>较快于堆排序</p>
</blockquote>
<h3 id="休眠排序"><a href="#休眠排序" class="headerlink" title="休眠排序"></a>休眠排序</h3><p>开辟与序列长度数量的线程数，根据要排序数值大小，使得睡多久</p>
<blockquote>
<p>段子，莫尝试</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>最坏情况可以有方法来降低它出现的概率</p>
<blockquote>
<p>比归并和堆排序更快</p>
</blockquote>
<p>执行步骤</p>
<ol>
<li>在序列中选择一个轴点元素(pivot)<ul>
<li>假设每次选择0位置为轴点元素</li>
</ul>
</li>
<li>利用pivot将序列一分为二个子序列<ul>
<li>小于pivot的元素放pivot左</li>
<li>大于pivot的元素放pivot右</li>
<li>等于pivot的元素放pivot左右都可</li>
</ul>
</li>
<li>再对这两个子序列进行1，2步操作<ul>
<li>直到不能再分割为止</li>
</ul>
</li>
</ol>
<p>快排本质：逐渐将每个元素都转换为轴点元素</p>
<p><strong>实现</strong></p>
<p>序列设置begin和end，左闭右开，end在最后一个元素之后。备份轴点(begin)。扫描元素，从右(end)开始如果元素比轴点大end–。如果比轴点小，将end元素覆盖begin元素且begin++并且改为从左往右扫描。如果遇到比轴点元素大，将begin元素覆盖end元素且end–，改扫描方向。如果遇到比轴点元素小，begin++；直到begin和end重合，再将备份元素覆盖此位置。</p>
<p>与轴点元素相同的元素，如果选择只做减减或加加容易出现最差情况。所以一般都放到另一边，然后调转方向</p>
<p><strong>复杂度</strong></p>
<p>时间复杂度</p>
<ul>
<li><p>最好情况：轴点左右元素数量均匀T(n)=2*T(n/2)+O(n)=O(nlogn)</p>
</li>
<li><p>最差情况：轴点左右元素数量极度不均匀T(n)=T(n-1)+O(n)=O(n^2^)</p>
</li>
</ul>
<p>空间复杂度：由于递归调用，空间复杂度为O(logn)，不稳定排序</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也称递减增量排序</p>
<p>将序列看作一个矩阵，分成m列，逐列进行排序，m逐渐减为1，当m为1时，整个序列完全有序。</p>
<blockquote>
<p>在m逐渐变为1的过程中，逆序对的数量在减少，因此希尔排序底层一般使用插入排序对每列进行排序。</p>
</blockquote>
<p>矩阵的列数取决于步长序列</p>
<ul>
<li><p>如，步长序列为{1,3,5,23,65……}表示依次分成65列，23列，5列，3列，1列</p>
</li>
<li><p>步长序列不同，执行效率不同</p>
</li>
<li><p>希尔本人给出的步长序列为n/2^k^，如n为16时，序列为{1,2,4,8}</p>
</li>
</ul>
<p><strong>复杂度</strong></p>
<p>希尔本人给出的步长序列，最坏情况时间复杂度是O(n^2^)</p>
<p>已知的最好步长序列，最坏情况的时间复杂度是O(n^4/3^)</p>
<ul>
<li>k为0，1，2，3，4，5如果k超过数据规模就结束</li>
<li>K为偶数：9(2^k^-2^k/2^)+1</li>
<li>K为奇数：8*2^k^-6*2^(k+1)/2^+1</li>
</ul>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数、桶、基数都不是基于比较排序，典型的空间换时间，有些时候，平均时间复杂度可以比O(nlogn)更低</p>
<p>核心思想：统计每个整数在序列中出现的次数，来推导出每个整数在有序序列的索引</p>
<p>用数组，下标表示数字，如果出现一次，数组[下标]++</p>
<p>缺点：稀疏序列极浪费空间</p>
<p>改进：数组长度设置为max-min、记录值为出现次数加上前个下标的值(就是前面的所有元素出现的次数)这样能快速获取其索引与出现次数。然后对照原队列，从右往左依次找到相应下标，算出索引值。每算出一个数值的索引，将它对应下标的值减1。</p>
<blockquote>
<p>改进后是在计数后，再加步骤，将下标的值修改，然后对照原队列算出索引值。这样稳定性就不会被破坏</p>
</blockquote>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>步骤：依次对个位数、十位数、百位数、千位数……进行排序</p>
<blockquote>
<p>个位数、十位数、百位数的取值范围固定0~9，可以使用计数排序进行排序</p>
</blockquote>
<blockquote>
<p>也可以用二维数组，第一个下标为当前位数的值，第二个下标表示出现的第几个数</p>
</blockquote>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201216220912638.png" alt="image-20201216220912638"></p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h2 id="常见递推式与复杂度"><a href="#常见递推式与复杂度" class="headerlink" title="常见递推式与复杂度"></a>常见递推式与复杂度</h2><table>
<thead>
<tr>
<th>递推式</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>T(n) = T(n/2) + O(1)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>T(n) = T(n − 1) + O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>T(n) = T(n/2) + O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>T(n) = 2 ∗ T(n/2) + O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>T(n) = 2 ∗ T(n/2) + O(n)</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>T(n) = T(n − 1) + O(n)</td>
<td>O(n^2^)</td>
</tr>
<tr>
<td>T(n) = 2 ∗ T(n − 1) + O(1)</td>
<td>O(2^n^)</td>
</tr>
<tr>
<td>T(n) = 2 ∗ T(n − 1) + O(n)</td>
<td>O(2^n^)</td>
</tr>
</tbody></table>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>需求：设计一个数据结构能</p>
<ul>
<li>连接两个村庄</li>
<li>查询两个村庄是否有连路</li>
</ul>
<p>并查集能够做到俩个操作时间复杂度都为O(α(n))，α(n)&lt;5</p>
<p>并查集核心操作：查找(Find)、合并(Union)</p>
<p>两种实现思路</p>
<ul>
<li>Quick Find<ul>
<li>find的时间复杂度：O(1)</li>
<li>union的时间复杂度：O(n)</li>
</ul>
</li>
<li>Quick Union<ul>
<li>find的时间复杂度：O(logn)可以优化到O(α(n))，α(n)&lt;5</li>
<li>union的时间复杂度：O(logn)可以优化到O(α(n))，α(n)&lt;5</li>
</ul>
</li>
</ul>
<p><strong>Quick Union</strong></p>
<p>存储：用数组存储元素，下标表示该元素，值表示该元素连接的根节点的下标元素。</p>
<p>根节点存储自身下标</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201217210253127.png" alt="image-20201217210253127"></p>
<p>查找时只要看下它的值是不是一样就行了。</p>
<p>连接时，将其中一个集合的所有元素改为合并的另一个集合的根的下标</p>
<p><strong>Quick Union</strong></p>
<p>不直接连接根节点，连接直接指向的节点，所以值存储的直接相连的值的下标</p>
<p><strong>优化</strong></p>
<p>基于size的优化：元素少的树嫁接到元素多的树</p>
<ul>
<li>增加一个数组 类型为数组 记录每个元素的size</li>
</ul>
<p>基于rank的优化：矮树 嫁接到 高树</p>
<ul>
<li>增加一个数组 类型为数组 记录每个元素的高度</li>
</ul>
<p>路径压缩，在find时将路径上的所有节点直接指向根节点</p>
<ul>
<li>递归实现，最后返回根节点来赋值。</li>
</ul>
<blockquote>
<p>优化强，但实现成本高</p>
</blockquote>
<p>路径分裂：每个节点指向它的祖父节点</p>
<p>路径减半：每隔一个节点都指向它祖父节点</p>
<p><strong>扩充到任意类型</strong></p>
<ol>
<li>将类型转化为整型，或者给类型加整型属性</li>
<li>链表+map：链表做节点，map存各个节点用于迅速定位</li>
</ol>
<p>总结：建议使用Quick Union基于rank的优化加上路径分裂或路径减半</p>
<h2 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h2><p>由顶点(vertex)和边(edge)组成，表示为G=(V,E)</p>
<ul>
<li>G为图，V为顶点集，E为边集</li>
<li>顶点集有穷且非空</li>
<li>任意顶点之间都可用边来表示它们的关系，E可为空</li>
</ul>
<p>有向图：边有明确方向</p>
<p>有向无环图(DAG)：一个有向图从任意顶点出发无法经过若干条边回到该顶点。</p>
<p>出度：该点作为起点的边数</p>
<p>入度：该点作为终点的边数</p>
<p>平行边</p>
<ul>
<li>无向图中，关联同一对顶点</li>
<li>有向图中，关联同一对顶点，且方向相同</li>
</ul>
<p>多重图：有平行边或自环的图</p>
<ul>
<li>自环：自己指向自己</li>
</ul>
<p>简单图：既无平行边也无自环的图</p>
<p>无向完全图：无向图，且任意俩个顶点之间都有边 </p>
<ul>
<li>n个顶点的无向完全图有n(n-1)/2条边</li>
</ul>
<p>有向完全图：任意俩顶点间存在方向相反的两条边</p>
<p>稠密图：边数接近或等于完全图</p>
<p>稀疏图：边数远少于完全图</p>
<p>有权图：边拥有权值</p>
<p>连通图：无向图中任意两个顶点都是连通的</p>
<ul>
<li>连通：两顶点存在可相互抵达的路径</li>
</ul>
<p>连通分量：无向图的极大连通子图</p>
<ul>
<li>连通图只有一个连通分量，自身</li>
</ul>
<p>强连通图：有向图中任意两个顶点都是连通的</p>
<p>强连通分量：有向图的极大强连通子图</p>
<p>图的实现方案</p>
<ul>
<li><p>邻接矩阵</p>
<ul>
<li>一维数组存放顶点信息</li>
<li>二维数组存放边信息<ul>
<li>横竖都表示顶点，相交为0表示无法通往该顶点，相交为1表示能通往</li>
<li>若为有权图，也可以存放权值</li>
</ul>
</li>
</ul>
<blockquote>
<p>更适合稠密图</p>
</blockquote>
</li>
<li><p>邻接表 ：链表，后面只连接有边的顶点</p>
</li>
</ul>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201219212101904.png" alt="image-20201219212101904"></p>
<p><strong>遍历</strong></p>
<p>广度优先搜索(BFS)</p>
<p>将起点加入队列，然后取出队列第一个元素，加入它能一步到达的顶点(需要排除已经加入过的)。然后循环直到队列为空</p>
<blockquote>
<p>记录已经加入的节点，可以使用任意集合，在加入队列的时候，就要加入集合</p>
</blockquote>
<p>深度优先搜索(DFS)：一条道走到底，然后往回退看有没有别的路。直到走完</p>
<p>用set记录已经访问过的节点，然后递归他所有子节点，直到访问完</p>
<p>非递归思路</p>
<ol>
<li>从节点(弹出的节点或初始节点)出度中任意选择一条</li>
<li>将边的from和to入栈</li>
<li>弹出to，打印to</li>
<li>将to加入到已访问过的范围中</li>
<li>break</li>
</ol>
<h3 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h3><p>大工程可分为多个小工程，小工程之间的先后顺序联系构成AOV网</p>
<p>标准的AOV网必须是一个有向无环图(简称DAG)</p>
<p><strong>拓扑排序</strong></p>
<p>前驱活动：有向边起点的活动称为终点的前驱活动</p>
<p>后继活动：有向边终点的活动称为起点的后继活动</p>
<p>拓扑排序：将AOV网中所有活动排成一个序列，使得每个活动的前驱活动都在后继活动前。</p>
<p>卡恩算法</p>
<ol>
<li>所有入度为0的顶点放入列表中，然后将顶点从图中去掉</li>
<li>重复操作1，直到找不到入度为0的点</li>
</ol>
<p>若列表中元素个数与顶点总数相等，表面排序完成</p>
<p>若列表中元素个数少于顶点总数，则说明有环，无法拓扑排序</p>
<p>实现：</p>
<ol>
<li>遍历找到所有入度为0的点，入队列。建表，存储顶点和其对应的入读数</li>
<li>出队，遍历其出度，拿到它的终点。更新表，将对应的点的入度-1。若减后入度为0，就将它入队列。循环2</li>
</ol>
<p>AOE网络自学下</p>
<p><a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule-ii/</a></p>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>也称支撑树</p>
<p>连通图的极小连通子图，它含有图中全部n个点，恰好只有n-1条边。</p>
<blockquote>
<p>最少的边到达所有顶点</p>
</blockquote>
<p><strong>最小生成树</strong>：所有生成树中，总权值最小的那颗</p>
<p>适合有权的连通图</p>
<p><strong>求最小生成树的2个经典算法</strong></p>
<p>Prim(普里姆算法)</p>
<p>切分：把图中的节点分为两部分，称为一个切分</p>
<p>横切边：如果一个边的两个端点，分别属于切分的两部分，这个边称为横切边</p>
<p>切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树</p>
<p>算法步骤：</p>
<ul>
<li>假设图为G=(V,E)有权的连通图。准备两个集合S{u<del>0</del>}和A</li>
</ul>
<ol>
<li>找到切分C = (S,V-S)的最小横切边(u<del>0</del>,v<del>0</del>)，并入集合A，同时将V<del>0</del>并入集合S。循环直到S=V或A=n-1(n为顶点数)</li>
</ol>
<blockquote>
<p>u<del>0</del>初始为任意顶点，V<del>0</del>为横切边的另一端点</p>
</blockquote>
<blockquote>
<p>切分过程中，可能会将图，切分为三个连通图，这时候也需要一个连通图一个连通图的来</p>
</blockquote>
<p><strong>Kruskal</strong>(克鲁斯克尔算法)</p>
<p>算法步骤：将所有边根据权值大小排序，前两小的边，必为最小生成树的边，第三个开始，判断加入是否形成环，如果形成环就舍去，如果没有则加入。直到边数为顶点数-1</p>
<blockquote>
<p>判断是否形成环，可以用并查集来实现。</p>
<p>set如果存节点的话，可能会导致有多个图，图内连通，但之间没有相连</p>
</blockquote>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>两顶点之间权值之和最小的路径(有向图、无向图均可，不能有负权环)</p>
<blockquote>
<p>有向图有负权边，无负权环，存在最短路径</p>
<p>无向图不能有负权边</p>
</blockquote>
<p><strong>三个经典算法</strong></p>
<p>单源最短路径算法</p>
<ul>
<li><p>Dijkstra(迪杰斯特拉算法)：</p>
<ul>
<li>前提：不能有负权边</li>
<li>时间复杂度：可优化至O(ElogV)，E为边数量，V为节点数</li>
<li>建表，找附近直达的所有点，找最短路径，然后更新，更新表。</li>
<li>松弛操作：更新2顶点间的最短路径。(拉起一个点后，可能会使得到达其它点的路径有更短的，更新)</li>
</ul>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201224100549247.png" alt="image-20201224100549247">)<img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201224100602109.png" alt="image-20201224100602109"></p>
</li>
<li><p>Bellman-Ford(贝尔曼-福特算法)</p>
<ul>
<li>能检查出负权边和负权环</li>
<li>步骤：对所有的边进行V-1次松弛操作，得到所有可能的最短路径</li>
<li>时间复杂度：O(EV)，E边数，V节点数</li>
</ul>
<blockquote>
<p>负权环没有最短路径，每轮松弛后，路径都能更短些。在经历V-1次松弛后，再松弛一次，路径依然能更短。</p>
</blockquote>
</li>
</ul>
<p>多源最短路径算法</p>
<ul>
<li><p>Floyd(弗洛伊德算法)</p>
<ul>
<li><p>时间复杂度：O(V^3^)，效率比Dijkstra好</p>
</li>
<li><p>原理</p>
<ul>
<li>从任意顶点i到j的最短路径不外乎两种<ol>
<li>i直接到j</li>
<li>i经过若干点到j</li>
</ol>
</li>
<li>假设dist(i,j)为顶点i到j的最短距离</li>
<li>对每个顶点k，检查dist(i,k)+dist(k,j)&lt;dist(i,j)是否成立<ul>
<li>若成立，则<code>dist(i,j)=dist(i,k)+dist(k,j)</code></li>
<li>遍历完所以节点k，dist(i,j)便是i到j的最短路径</li>
</ul>
</li>
</ul>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20201230191408011.png" alt="image-20201230191408011"></p>
</li>
</ul>
</li>
</ul>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>尾调用：函数的最后一个动作是调用函数</p>
<blockquote>
<p>一些编译器能对尾调用进行一些优化，以节省栈空间 </p>
<p>尾调用优化也叫尾调用消除</p>
</blockquote>
<p>消除尾递归中的尾调用，更加容易</p>
<blockquote>
<p>JVM会消除尾递归中的尾调用，但不会消除一般的尾调用</p>
</blockquote>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>通过选择不同的岔路口来通往目的地。</p>
<blockquote>
<p>每步都选择一条路出发，能进则进，不能则回退上一步，换条路试试</p>
</blockquote>
<blockquote>
<p>DFS就是典型的回溯</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/</a></p>
<p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/</a></p>
<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/</a></p>
<p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p>
<p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets-ii/</a></p>
<p><strong>八皇后问题</strong></p>
<p>在国际象棋棋盘上拜访八个皇后，使其不能互相攻击。即任意两皇后不能处于同一行、同一列、同一斜线上。有多少种摆法？</p>
<p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p>
<p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens-ii/</a></p>
<p>暴力解法：任意选八个格子，检查每种可能性。大概有4.4*10^9^种</p>
<p>暴力优化解法：每行脂肪一个皇后，有8^8^种，检查每种摆法可能性</p>
<p>回溯法：先确定第一个皇后的位置(任意)，然后在剩下能摆的位置任意摆放一个，直到不能拜访再回溯，再拜访。(可能会回溯到第一个皇后摆放的位置)</p>
<p>细节：一行只能有一个皇后，所以一行一行的摆。拜过皇后的列不能再摆。斜方向可以算出来。然后使用回溯。</p>
<blockquote>
<p>左上到右下：同一斜线上row-col+n-1值相同，n为几个皇后</p>
<p>右上到左下：row+col即可 </p>
</blockquote>
<p>可以通过使用位运算，来替代使用数组的空间。(只适合8皇后以下)</p>
<p>通过<code>&amp;(1&lt;&lt;列)</code>的操作，若与的结果为0表示无</p>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心策略，贪婪策略</p>
<p>每部都采取当下最优解(局部最优解)</p>
<p>应用：哈夫曼树、Prim、Kruskal、Dijkstra</p>
<p>缺点：往往不能得到最优解</p>
<p><strong>01背包</strong></p>
<p>问题：有 n 件物品和一个最大承重为 W 的背包，每件物品的重量是 𝑤<del>i</del>、价值是 V<del>I</del>。在保证总重量不超过 W 的前提下，将哪几件物品装入背包，可以使得背包的总价值最大？</p>
<blockquote>
<p>每件物品只有 1 件，也就是每个物品只能选择 0 件或者 1 件，因此称为 0-1背包问题</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/assign-cookies/</a></p>
<p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p><a href="https://leetcode-cn.com/problems/can-place-flowers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-place-flowers/</a></p>
<p><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/candy/</a></p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>解决规模为 n 的问题，分解成 a 个规模为 n/b 的子问题，然后在 O (n^d^) 时间内将子问题的解合并起来</p>
<p>算法运行时间为：T (n) = aT (n/b) + O (n^d^) ，a &gt; 0, b &gt; 1, d ≥ 0</p>
<p><strong>最大子序列</strong></p>
<p>思路：将序列均匀分为2个序列。那么最大的子序列要么在左边要么在右边，要么在中间。</p>
<p>实现：中间的最大序列就是中间往左右延申</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span> nums[begin];</span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = nums[mid - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> leftSum = leftMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">2</span>; i &gt;= begin; i--) &#123;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">        leftMax = Math.max(leftMax, leftSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rightMax = nums[mid];</span><br><span class="line">    <span class="keyword">int</span> rightSum = rightMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">        rightSum += nums[i];</span><br><span class="line">        rightMax = Math.max(rightMax, rightSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax + rightMax,</span><br><span class="line">            Math.max(</span><br><span class="line">                    maxSubArray(nums, begin, mid),</span><br><span class="line">                    maxSubArray(nums, mid, end))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>大数乘法</strong></p>
<p>将n位数分为n/2位来算 </p>
<p>下图为n/2*n/2的优化</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210101110420701.png" alt="image-20210101110420701"></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>可以理解为一种从低向上的记忆性递归</p>
<p>常规思路：</p>
<ol>
<li>定义状态(状态是原问题、子问题的解)：<ul>
<li>如定义dp(i)的含义</li>
</ul>
</li>
<li>设置初始状态(边界)<ul>
<li>如设置dp(0)的值</li>
</ul>
</li>
<li>确定状态转移方程 <ul>
<li>如确定dp(i)和dp(i-1)的关系</li>
</ul>
</li>
</ol>
<blockquote>
<p>将复杂问题拆解为若干个简单的子问题，每个子问题只解决一次，保存它的解，最后推导出原问题的解</p>
</blockquote>
<p>可以用动态规划解决的问题，通常有两个特征</p>
<ul>
<li>最优子结构(最优化原理)：通过求解子问题的最优解，可以获得原问题的最优解</li>
<li>无后效：<ul>
<li>某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响（未来与过去无关）</li>
<li>在推导后面阶段的状态时，只关心前面阶段的具体状态值，不关心这个状态是怎么一步步推导出来的</li>
</ul>
</li>
</ul>
<p><strong>零钱兑换</strong></p>
<p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p>
<p>动态规划思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n为金钱总额，faces为有的硬币面额</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coins5</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] faces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || faces == <span class="keyword">null</span> || faces.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> face : faces) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; face) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = dp[i - face];</span><br><span class="line">            <span class="comment">//如果i-face的值是无法凑的，就跳过</span></span><br><span class="line">            <span class="comment">///若i-face的值是大于别的min的，也跳过</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= min) <span class="keyword">continue</span>;</span><br><span class="line">            min = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能到这说明for一直是continue，无法凑到该面值，赋-1</span></span><br><span class="line">        <span class="keyword">if</span> (min == Integer.MAX_VALUE) &#123;</span><br><span class="line">            dp[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最大连续子序列</strong></p>
<p>前面分治做过，动态规划也能做</p>
<p>状态定义：假设dp(i)是以nums[i]结尾的最大连续子序列和(nums为整个序列)</p>
<p>实现细节：若dp(i-1)为负数，那么dp(i-1)就是单独它一个数，若为正数或零则相加</p>
<p>空间和时间复杂度：O(n)</p>
<blockquote>
<p>空间复杂度，可以不存前面的值，优化到O(1)</p>
</blockquote>
<p><strong>最长上升子序列(LIS)</strong>    </p>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">问题</a></p>
<p>思路：nums为序列</p>
<ul>
<li>状态定义：dp(i) 是以 nums[i] 结尾的最长上升子序列的长度，i ∈ [0, nums.length)<ul>
<li>要以nums[i]结尾</li>
</ul>
</li>
<li>状态转移方程：<ul>
<li>当 nums[i] &gt; nums[j]。nums[i] 可以接在 nums[j] 后面，形成一个比 dp(j) 更长的上升子序列，长度为 dp(j) + 1</li>
<li>当 nums[i] ≤ nums[j]，nums[i] 不能接在 nums[j] 后面，跳过此次遍历（continue）</li>
<li>dp(i) = max { dp(i), dp(j) + 1 }</li>
</ul>
</li>
<li>初始状态：所有的 dp(i) 默认都初始化为 1</li>
<li>最长上升子序列的长度是所有 dp(i) 中的最大值 max { dp(i) }，i ∈ [0, nums.length)</li>
</ul>
<p><strong>总结思路</strong>：dp(i) 是以 nums[i] 结尾的最长上升子序列的长度，确定dp(i)是遍历dp(n) n&lt;i，如果nums[n]&lt;nums[i]，则可以接在后面长度为dp(n)+1，若不能，则跳过。选出最大的就是dp(i)的值。最后遍历每个子序列的值，max就是答案</p>
<p>空间复杂度：O(n)，时间复杂度：O (n^2^)</p>
<p><strong>二分搜索思路</strong>：</p>
<p>时间复杂度可以优化到O(nlogn)</p>
<p>思路：从左往右处理每个元素，新建一个同样长度的数组</p>
<ul>
<li>如果数组种没有元素比它大就按序往后，将该元素放置</li>
<li>如果从左数过来数组中元素大于等于当前处理的元素，则覆盖</li>
</ul>
<p>当处理完所有牌，数组有元素的个数就是最长上升子序列的长度</p>
<blockquote>
<p>这样处理的过程中，数组一直是升序的。只要比较数组中有值的最后的一个元素就可以知道数组中有没有比他大的元素。所以可以使用二分查找的方法，来找到对应数组的元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = len;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= top[mid]) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        top[begin] = num;</span><br><span class="line">        <span class="keyword">if</span> (begin == len) len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最长公共子序列</strong></p>
<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">[问题]</a> </p>
<p>思路：nums1是序列1，nums2是序列2</p>
<ul>
<li>状态定义：dp(i, j) 是【nums1 前 i 个元素】与【nums2 前 j 个元素】的最长公共子序列长度</li>
<li>状态转移方程：<ul>
<li>若nums1[i – 1] = nums2[j – 1]，那么 dp(i, j) = dp(i – 1, j – 1) + 1</li>
<li>若nums1[i – 1] ≠ nums2[j – 1]，那么 dp(i, j) = max { dp(i – 1, j), dp(i, j – 1) }</li>
</ul>
</li>
<li>初始状态：dp(i, 0)、dp(0, j) 初始值均为 0</li>
</ul>
<blockquote>
<p>这个题目，动态规划该思路大致想来是对的，细想又觉得有些地方不是很理解</p>
</blockquote>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text1 == <span class="keyword">null</span> || text2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars1 = text1.toCharArray();  </span><br><span class="line">    <span class="keyword">if</span> (chars1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = text2.toCharArray();  </span><br><span class="line">    <span class="keyword">if</span> (chars2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] rowsChars = chars1, colsChars = chars2;</span><br><span class="line">    <span class="comment">//将二维数组优化为一维数组，再选择较短的做列，优化一维数组的空间</span></span><br><span class="line">    <span class="keyword">if</span> (chars1.length &lt; chars2.length) &#123;</span><br><span class="line">        colsChars = chars1;</span><br><span class="line">        rowsChars = chars2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[colsChars.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowsChars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//leftTop来记录需要用到的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= colsChars.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTop = cur;</span><br><span class="line">            cur = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (rowsChars[i - <span class="number">1</span>] == colsChars[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = leftTop + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[colsChars.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最长公共子串</strong></p>
<p>子串与子序列不同，子串必须是连续的</p>
<p>思路：与最长上升子序列类似。2 个字符串分别是 str1、str2(i ∈ [1, str1.length]、j ∈ [1, str2.length])</p>
<ul>
<li>状态定义：dp(i, j) 是以 str1[i – 1]、str2[j – 1] 结尾的最长公共子串长度</li>
<li>状态转移方程：<ul>
<li>若str1[i – 1] = str2[j – 1]，那么 dp(i, j) = dp(i – 1, j – 1) + 1</li>
<li>若str1[i – 1] ≠ str2[j – 1]，那么 dp(i, j) = 0</li>
</ul>
</li>
<li>初始状态：dp(i, 0)、dp(0, j) 初始值均为 0</li>
<li>最长公共子串的长度是所有 dp(i, j) 中的最大值 max { dp(i, j) }</li>
</ul>
<blockquote>
<p>有了最长上升子序列的经验，这题很容易联想到</p>
</blockquote>
<p>实现：</p>
<p>优化：将二维数组优化为一维数组，再选择较短的做列，优化一维数组的空间。从左往右算。</p>
<blockquote>
<p>如果从右往左算，还要记录个leftTop的值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] rowsChars = chars1, colsChars = chars2;</span><br><span class="line">    <span class="keyword">if</span> (chars1.length &lt; chars2.length) &#123;</span><br><span class="line">        colsChars = chars1;</span><br><span class="line">        rowsChars = chars2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[colsChars.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rowsChars.length; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = colsChars.length; col &gt;= <span class="number">1</span>; col--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars1[row - <span class="number">1</span>] != chars2[col - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[col] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[col] = dp[col - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                max = Math.max(dp[col], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>01背包</strong></p>
<p>思路：values 是价值数组，weights 是重量数组</p>
<ul>
<li>状态定义：假设 dp(i, j) 是 最大承重为 j、有前 i 件物品可选 时的最大总价值，i ∈ [1, n]，j ∈ [1, W]</li>
<li>状态转移方程：<ul>
<li>若 j &lt; weights[i – 1]，那么 dp(i, j) = dp(i – 1, j)</li>
<li>若 j ≥ weights[i – 1]，那么 dp(i, j) = max { dp(i – 1, j), dp(i – 1, j – weights[i – 1]) + values[i – 1] }</li>
</ul>
</li>
<li>初始状态：dp(i, 0)、dp(0, j) 初始值均为 0</li>
</ul>
<blockquote>
<p>状态转移方程就是分两种情况：</p>
<ol>
<li>当目前的最大承重都无法放下第i件物品时，那么dp(i, j)值就为dp(i-1,j)</li>
<li>当目前能放下该第i件物品时，那么dp(i, j)值就有两种情况，就是该物品放了，或者没放。没方就是dp(i-1,j)，放了就是dp(i-1,j-weight[i-1])+values[i-1]。dp(i-1,j-weight[i-1])就是能放下该物品时剩下空间的最大总价值</li>
</ol>
</blockquote>
<p>优化：只用一维数组，并且从左往右算</p>
<blockquote>
<p>从左往右算并不是优化，如果从右往左递推，会覆盖掉前面的内容，而后面的操作是可能要用到前面的值的。所以先进行后面的操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights == <span class="keyword">null</span> || weights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values.length != weights.length || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = capacity; j &gt;= weights[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], values[i - <span class="number">1</span>] + dp[j - weights[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>01背包恰好装满</strong></p>
<p>只需要更改初始状态即可</p>
<p>dp(i, 0) = 0，总重量恰好为 0，最大总价值必然也为 0</p>
<p>dp(0, j) = –∞（负无穷），j ≥ 1，负数在这里代表无法恰好装满</p>
<blockquote>
<p>当选择不拿的时候，i往前一步一步往0靠(直到靠到初始值负无穷)，就是负值。当拿的时候，如果不是恰好装满时会出现极小值+一个数也是负数。俩者取最大还是负数</p>
<p>当选择拿的时候且恰好装满，是一个值加一个恰好装满的值(该值若是初始状态则是0)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回-1表示无法恰好装满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValueExactly</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights == <span class="keyword">null</span> || weights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values.length != weights.length || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">        dp[j] = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = capacity; j &gt;= weights[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], values[i - <span class="number">1</span>] + dp[j - weights[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[capacity] &lt; <span class="number">0</span> ? -<span class="number">1</span> : dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>是一个空间效率高的概率性高的概率型数据结构，可以用告诉你：一个元素一定不存在或者可能存在</p>
<p>优点：查询和空间效率极高</p>
<p>缺点：有一定误判率、删除困难</p>
<p>本质：一个很长的二进制向量和一系列随机映射函数(Hash函数)</p>
<p>哈希函数作用：若干个哈希函数，每个哈希函数生成一个索引</p>
<p>添加：将每个哈希函数生成的索引位置设为1</p>
<p>查询：若每个哈希函数生成的索引位置都为1则存在，有一个不为1就不存在</p>
<p>添加、查询的时间复杂度都为：O(K)，K为哈希函数的个数</p>
<p>空间复杂度为：O(m)，m为二进制位的个数</p>
<p>误判率：二进制位的个数m、哈希函数的个数k、数据规模n。可以算出误判率</p>
<blockquote>
<p>当数据规模足够大的时候，0.5和1都可以忽略</p>
</blockquote>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210102185107414.png" alt="image-20210102185107414"></p>
<p>已知误判率p、数据规模n，求二进制位的个数m、哈希函数的个数k</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210102185243711.png" alt="image-20210102185243711"></p>
<p><a href="https://mvnrepository.com/artifact/com.google.guava/guava" target="_blank" rel="noopener">谷歌的布隆过滤器</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简易完整的实现，可以看下学习下源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 二进制向量的长度(一共有多少个二进制位)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> bitSize;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 二进制向量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] bits;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 哈希函数的个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> hashSize;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n 数据规模</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> p 误判率, 取值范围(0, 1)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span> || p &lt;= <span class="number">0</span> || p &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"wrong n or p"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> ln2 = Math.log(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">// 求出二进制向量的长度</span></span><br><span class="line">		bitSize = (<span class="keyword">int</span>) (- (n * Math.log(p)) / (ln2 * ln2));</span><br><span class="line">		<span class="comment">// 求出哈希函数的个数</span></span><br><span class="line">		hashSize = (<span class="keyword">int</span>) (bitSize * ln2 / n);</span><br><span class="line">		<span class="comment">// bits数组的长度</span></span><br><span class="line">		bits = <span class="keyword">new</span> <span class="keyword">long</span>[(bitSize + Long.SIZE - <span class="number">1</span>) / Long.SIZE];</span><br><span class="line">		<span class="comment">// 每一页显示100条数据, pageSize</span></span><br><span class="line">		<span class="comment">// 一共有999999条数据, n</span></span><br><span class="line">		<span class="comment">// 请问有多少页 pageCount = (n + pageSize - 1) / pageSize</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加元素1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">		nullCheck(value);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 利用value生成2个整数</span></span><br><span class="line">		<span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line">		<span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">			<span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				combinedHash = ~combinedHash;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">// 生成一个二进位的索引</span></span><br><span class="line">			<span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line">			<span class="comment">// 设置index位置的二进位为1</span></span><br><span class="line">			<span class="keyword">if</span> (set(index)) result = <span class="keyword">true</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//   101010101010010101</span></span><br><span class="line">			<span class="comment">// | 000000000000000100   1 &lt;&lt; index</span></span><br><span class="line">			<span class="comment">//   101010111010010101</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断一个元素是否存在</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">		nullCheck(value);</span><br><span class="line">		<span class="comment">// 利用value生成2个整数</span></span><br><span class="line">		<span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line">		<span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">			<span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				combinedHash = ~combinedHash;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">// 生成一个二进位的索引</span></span><br><span class="line">			<span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line">			<span class="comment">// 查询index位置的二进位是否为0</span></span><br><span class="line">			<span class="keyword">if</span> (!get(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置index位置的二进位为1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line">		<span class="keyword">int</span> bitValue = <span class="number">1</span> &lt;&lt; (index % Long.SIZE);</span><br><span class="line">		bits[index / Long.SIZE] = value | bitValue;</span><br><span class="line">		<span class="keyword">return</span> (value &amp; bitValue) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查看index位置的二进位的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true代表1, false代表0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line">		<span class="keyword">return</span> (value &amp; (<span class="number">1</span> &lt;&lt; (index % Long.SIZE))) != <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nullCheck</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Value must not be null."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>又叫跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能</p>
<p>对比平衡树</p>
<ul>
<li>实现和维护更简单</li>
<li>搜索、删除、添加的平均时间复杂度是O(logn)</li>
</ul>
<p>原理：在链表的基础上，增加了能跳跃的点</p>
<p>首节点是虚拟节点，不存实际的数据</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210102211427706.png" alt="image-20210102211427706"> </p>
<p>搜索、删除、添加：都是先从最顶层开始找，如果小于或为空则返回从下个层开始找，如果大于依然从最顶层开始找，循环前面步骤。如果等于，或下面没有层了就停止。</p>
<p>每个节点都存储的是K-V对。K具有可比较性</p>
<p>实现细节：</p>
<ul>
<li><p>最高层数、有效层数：规定最高到几层、实际用的几层(记录下个节点 )</p>
<ul>
<li>最高层的层数为<img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210103134404478.png" alt="image-20210103134404478">，平均有1/p元素</li>
</ul>
</li>
<li><p>层数用数组实现，在获取时遍历该数组就行了</p>
</li>
<li><p>跳表节点层数的确定：随机，只要不超过最高层数即可。这样做的效率也是能达到logn的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p的值一般为0.5或0.25，redis里p为0.25</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> P = <span class="number">0.25</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Math.random() &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在删除和添加结点的时候，需要知道新添加的节点的若干个前驱节点。可以创建一个有效层数的数组，在搜索添加位置的过程中将它的前驱节点保存在数组中。方便之后遍历来更改前驱节点的指向。</p>
</li>
</ul>
<p><strong>补充</strong></p>
<ul>
<li><p>跳表的层数</p>
<ul>
<li>元素层数恰好等于1的概率为1-p</li>
<li>大于等于2的概率为p，恰好为2的概率为p*(1-p)</li>
<li>大于等于3的概率为p^2^，恰好为3的概率为p^2^*(1-p)</li>
<li>一个元素的平均层数为1/(1-p)</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>每层元素数<ul>
<li>一层固定有n个</li>
<li>二层平均有n*p个</li>
<li>三层平均有n*p^2^个</li>
<li>k层平均有n*p^k^个</li>
</ul>
</li>
</ul>
</li>
<li><p>搜索时，每层链表的预期查找步数最多为1/p，总的查找步数为<img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210103134947055.png" alt="image-20210103134947055">)，时间复杂度O(logn)</p>
</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树变体，常用于数据库和操作系统的文件系统中</p>
<ul>
<li>MySQL的索引就是基于B+树实现的</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>分为内部节点和叶子节点两种节点<ul>
<li>叶子节点就是最底下一层，内部节点就是非叶子节点</li>
<li>内部节点只存储key，不存储具体数据</li>
<li>叶子节点存储key和具体数据</li>
<li>所有的叶子节点形成一条有序链表</li>
</ul>
</li>
<li>m阶B+树非根节点的元素数量X<ul>
<li>元素数量如果为x，子节点数量也为x</li>
<li><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210103150120564.png" alt="image-20210103150120564"></li>
</ul>
</li>
</ul>
<p>MySQL为了减小IO操作数量，把一个节点的大小设计为最小读写的大小(一个扇区)</p>
<ul>
<li>InnoDB的最小读写单位是16k</li>
</ul>
<p>对于B树，B+树的优势是</p>
<ul>
<li>每个节点存储的key数量更多，树的高度更低<ul>
<li>B树节点存K-V。B+树的分支比B树更多</li>
</ul>
</li>
<li>查询速度稳定，高效。区间查询更高效<ul>
<li>B+树的叶子节点是有序链表，区间查询速度快</li>
<li>B树区间查询需要中序遍历，效率较低</li>
</ul>
</li>
</ul>
<p>B*树：B+树的变体，给内部节点增加了指向兄弟节点的指针</p>
<ul>
<li>m阶B*树的非根节点的元素数量x<ul>
<li><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210103153310423.png" alt="image-20210103153310423"></li>
</ul>
</li>
</ul>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>就是字符串，由若干个字符组成的有限序列</p>
<p>概念：</p>
<ul>
<li>前缀(prefix)：</li>
<li>真前缀(proper prefix)</li>
<li>后缀(suffix)</li>
<li>真后缀(proper suffix)</li>
<li>模式串(Pattern)</li>
<li>文本串(Text)</li>
</ul>
<p>以thank举例：</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210103165454429.png" alt="image-20210103165454429"></p>
<p>几个经典的串匹配算法：蛮力、KMP、Boyer-Moore、Rabin-Karp、Sunday</p>
<blockquote>
<p>pl为patternlength，tl为textlength</p>
</blockquote>
<h3 id="蛮力-Brute-Force"><a href="#蛮力-Brute-Force" class="headerlink" title="蛮力(Brute Force)"></a>蛮力(Brute Force)</h3><p>以字符为单位，从左到右移动模式串，直到匹配成功。</p>
<p>蛮力1：用两个值记录，pi和ti。相同的时候两值<code>++</code>，若匹配失败<code>pi=0</code>，<code>ti-=(pi-1)</code>将ti置开始匹配位置的下个位置</p>
<p>蛮力2：用两个值记录，pi和ti。不匹配的时候<code>ti++</code>，<code>pi=0</code>。匹配时<code>pi++</code>比较时比<code>pi+ti</code>和<code>pi</code></p>
<p>时间复杂度O(nm)</p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>相较于蛮力算法，KMP的精妙之处：充分利用了此前比较过的内容，可以很聪明地跳过一些不必要的比较位置。</p>
<p>通过next表来实现快速向后移动</p>
<p>next[pi]是 pi 左边子串的真前缀后缀的最大公共子串长度。然后长度都向后移一位，首字符设置为-1</p>
<p>例：</p>
<p><img src="/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210105144403486.png" alt="image-20210105144403486"></p>
<blockquote>
<p>我认为该算法主要是利用模式串的真前缀和真后缀，重复的部分来实现更优秀的模式匹配</p>
</blockquote>
</div><div class="tags"><a href="/tags/java/"><i class="fa fa-tag"></i>java</a><a href="/tags/%E7%AE%97%E6%B3%95/"><i class="fa fa-tag"></i>算法</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fa fa-tag"></i>数据结构</a></div><div class="post-nav"><a class="pre" href="/2020/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="next" href="/2020/01/03/kafka%E7%AC%94%E8%AE%B0/">kafka笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Scala/" style="font-size: 15px;">Scala</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/nosql/" style="font-size: 15px;">nosql</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 15px;">后端</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/scala/" style="font-size: 15px;">scala</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/springsecurity/" style="font-size: 15px;">springsecurity</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/wordpress/" style="font-size: 15px;">wordpress</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/marjora/" style="font-size: 15px;">marjora</a> <a href="/tags/virtualbox/" style="font-size: 15px;">virtualbox</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 15px;">服务器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 15px;">博客</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机基础</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E6%B5%81%E7%A8%8B/" style="font-size: 15px;">流程</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 15px;">开发</a> <a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/06/Redis/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Git笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/07/JVM/">JVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/27/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/Git%E7%AC%94%E8%AE%B0/">Git笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/manjaro%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">manjaro配置开发环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/25/docker%E7%AC%94%E8%AE%B0/">docker笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">dian的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>